/*
 Orbiter_OpenGL

 Copyright (C) 2004 Pluto, Inc., a Florida Corporation

 www.plutohome.com

 Phone: +1 (877) 758-8648

 This program is distributed according to the terms of the Pluto Public License, available at:
 http://plutohome.com/index.php?section=public_license

 This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. See the Pluto Public License for more details.

 */
#include "Orbiter_OpenGL.h"

#include "PlutoUtils/CommonIncludes.h"
#include "PlutoUtils/MultiThreadIncludes.h"
#include "DCE/Logger.h"
#include "SerializeClass/ShapesColors.h"

#include "PlutoSDLDefs.h"
#include "../RendererOCG.h"
#include "SDLRendererOCGHelper.h"

#include "pluto_main/Define_Effect.h"
#include "pluto_main/Define_DesignObj.h"
#include "pluto_main/Define_Text.h"
#include "pluto_main/Define_DeviceCategory.h"
#include "Gen_Devices/AllCommandsRequests.h"
#include "DataGrid.h"
#include "Orbiter/ScreenHistory.h"

#if !defined(BLUETOOTH_DONGLE) && !defined(PROXY_ORBITER)
#define USE_ONLY_SCREEN_SURFACE
#endif

#ifdef WINCE
    #include "wince.h"
#endif

#if defined(WINCE) || defined(BLUETOOTH_DONGLE) || defined(PROXY_ORBITER)
#define DISABLE_OPENGL
#endif

#ifndef DISABLE_OPENGL
#include "../OpenGL/math3dutils.h"
#include "../OpenGL/GL2DWidgets/basicwindow.h"
#include "../OpenGL/GL2DWidgets/DrawingWidgetsEngine.h"

#include "../OpenGL/orbitergl3dengine.h"

#include "../OpenGL/GL2DEffects/gl2deffecttransit.h"
#include "../OpenGL/GL2DEffects/gl2deffectbeziertranzit.h"
#include "../OpenGL/GL2DEffects/gl2deffectslidefromleft.h"
#include "../OpenGL/GL2DEffects/gl2deffectfadesfromtop.h"
#include "../OpenGL/GL2DEffects/gl2deffectfadesfromunderneath.h"
#include "../OpenGL/Orbiter3DCommons.h" 
#include "../Simulator.h" 

#include "../../pluto_main/Define_Effect.h"
#endif

/**
 * OpenGL drawing thread. It is in three steps: 
 * - Init OpenGL with SDL
 * - looping to drawing frames
 * - end the OpenGL
 */


void *Orbiter_GLThread(void *p)
{
	Orbiter_OpenGL * pOrbiter = (Orbiter_OpenGL*) p;
	// Create the OpenGL window and classes asociated with it
	// OpenGL drawing operations, locked in the mutex
	PLUTO_SAFETY_LOCK(cm, *(pOrbiter->m_GLThreadMutex));

	pOrbiter->m_Desktop = OrbiterGL3D::GetInstance();
	pOrbiter->m_Desktop->BuildOrbiterGL(pOrbiter);
	
	//cm.CondWait(); // This will unlock the mutex and lock it on awakening
	
	pOrbiter->PaintDesktopGL = false;

	while(!pOrbiter->m_bQuit)
	{
		//SDL_Event Event;
		//while(SDL_PollEvent(&Event))
		//	SDL_PushEvent(&Event);

		//nothing to process. let's sleep...
		cm.CondWait(); // This will unlock the mutex and lock it on awakening

		/// Thread is waken up, for more reasons as Quit event or there is one effect pending or 
		/// is idle event
		// Orbiter is in Quit state, end the thread
		if(pOrbiter->m_bQuit)
			return NULL;

		if (!pOrbiter->m_Desktop->EffectBuilder->HasEffects()) {
			if (!pOrbiter->PaintDesktopGL) {
				pOrbiter->PaintDesktopGL = true;
				pOrbiter->m_Desktop->Paint();
			}
			else
			{
				cm.Release();
				Sleep(10);
				cm.Relock();
			}
		}
		else 
		{
			pOrbiter->PaintDesktopGL = false;
			pOrbiter->m_Desktop->Paint();
		}
	}

	delete pOrbiter->m_Desktop;

	return NULL;
}	

using namespace DCE;
//-----------------------------------------------------------------------------------------------------
Orbiter_OpenGL::Orbiter_OpenGL(int DeviceID, int PK_DeviceTemplate, string ServerAddress, string sLocalDirectory,
    bool bLocalMode, int nImageWidth, int nImageHeight, bool bFullScreen/*=false*/,
    pluto_pthread_mutex_t *pExternalScreenMutex/*=NULL*/, 
	bool UseOpenGL /*=false*/)
 : Orbiter(DeviceID, PK_DeviceTemplate, ServerAddress, sLocalDirectory, bLocalMode, nImageWidth,
    nImageHeight, pExternalScreenMutex)
{
	m_spPendingGLEffects.reset(new PendingGLEffects());

	m_pScreenImage = NULL;
	m_bFullScreen=bFullScreen;

	/// if OpenGL is used there is created one OpenGL drawing mutex
	m_GLThreadMutex = new pluto_pthread_mutex_t("open gl worker thread");
	SDLGLthread = 0;

	pthread_cond_init(&m_GLThreadCond, NULL);
	m_GLThreadMutex->Init(NULL, &m_GLThreadCond);
	m_Desktop = NULL;
}

/*virtual*/ Orbiter_OpenGL::~Orbiter_OpenGL()
{
	KillMaintThread(); 
	// We need to do this before freeing the surface.  It's a repeat of what's in Orbiter's destructor
	g_pPlutoLogger->Write(LV_STATUS, "about to free surface");

	#ifndef USE_ONLY_SCREEN_SURFACE
		SDL_FreeSurface(m_pScreenImage);
	#endif

	m_pScreenImage = NULL;

	g_pPlutoLogger->Write(LV_STATUS, "~Orbiter_OpenGL finished");

	/// Wait OpenGL to finish
	pthread_cond_broadcast(&m_GLThreadCond);

	if(SDLGLthread)
		pthread_join(SDLGLthread, NULL);

	delete m_GLThreadMutex;
}

/*virtual*/ bool Orbiter_OpenGL::GetConfig()
{
	if(!Orbiter::GetConfig())
		return false;
	
	/// if OpenGL is used there is created one OpenGL drawing thread 
	pthread_create(&SDLGLthread, NULL, Orbiter_GLThread, (void*)this);
	/// creates 2D surface which is drawed with 2D engine the Orbiter
	/// which lately will be used as a texture
    m_pScreenImage = SDL_CreateRGBSurface(SDL_SWSURFACE, m_iImageWidth, m_iImageHeight, 32,
        rmask, gmask, bmask, amask);
	if (m_pScreenImage == NULL) {
		g_pPlutoLogger->Write(LV_WARNING, "SDL_CreateRGBSurface failed! %s",SDL_GetError());
	}

    return true;
}

/*static*/ Orbiter_OpenGL *Orbiter_OpenGL::GetInstance()
{
	if(!m_pInstance)
		g_pPlutoLogger->Write(LV_STATUS, "The instance of orbiter is NULL");

	return m_pInstance;
}

/*static*/ void Orbiter_OpenGL::Cleanup()
{
	g_pPlutoLogger->Write(LV_STATUS, "Orbiter_OpenGL: need to cleanup orbiter...");

	if(NULL != m_pInstance)
	{
		/*
		//todo for SDL

		if(::IsWindow(m_pInstance->m_hWnd))
		::DestroyWindow(m_pInstance->m_hWnd);
		*/

		m_pInstance->m_bQuit = true;	

		Orbiter_OpenGL *pCopy = m_pInstance;
		m_pInstance = NULL;

		delete pCopy;
		pCopy = NULL;

		g_pPlutoLogger->Write(LV_STATUS, "Orbiter_OpenGL: orbiter deleted.");
	}
}

//-----------------------------------------------------------------------------------------------------
/*static*/ void Orbiter_OpenGL::BuildOrbiter(int DeviceID, int PK_DeviceTemplate, string ServerAddress, string sLocalDirectory, bool bLocalMode,
int nImageWidth, int nImageHeight, bool bFullScreen/*= false*/, bool bUseOpenGL /*= false*/,
pluto_pthread_mutex_t *pExternalScreenMutex/*=NULL*/)
{
	if(NULL == m_pInstance)
	{
		g_pPlutoLogger->Write(LV_STATUS, "Orbiter_OpenGL constructor.");
		m_pInstance = new Orbiter_OpenGL(DeviceID, PK_DeviceTemplate, ServerAddress, 
			sLocalDirectory, bLocalMode, nImageWidth, 
			nImageHeight, bFullScreen, pExternalScreenMutex);

		//g_pCommand_Impl = m_pInstance;  
	}
	else
	{
		throw "Orbiter_PocketFrog already created!";
	}
}

//----------------------------------------------------------------------------------------------------
/*virtual*/ void Orbiter_OpenGL::ObjectOnScreen(VectDesignObj_Orbiter *pVectDesignObj_Orbiter, 
	DesignObj_Orbiter *pObj, PlutoPoint *ptPopup/* = NULL*/)
{
	if(pObj->m_PK_Effect_On_Screen > 0)
		m_spPendingGLEffects->m_nOnScreenTransitionEffectID = pObj->m_PK_Effect_On_Screen;

	Orbiter::ObjectOnScreen(pVectDesignObj_Orbiter, pObj, ptPopup);
}
//----------------------------------------------------------------------------------------------------
/*virtual*/ void Orbiter_OpenGL::ObjectOffScreen(DesignObj_Orbiter *pObj)
{
	if(pObj->m_PK_Effect_Off_Screen > 0)
        m_spPendingGLEffects->m_nOffScreenTransitionEffectID = pObj->m_PK_Effect_Off_Screen;

	Orbiter::ObjectOffScreen(pObj);
}
//----------------------------------------------------------------------------------------------------
/*virtual*/ void Orbiter_OpenGL::RenderScreen( bool bRenderGraphicsOnly )
{
}

/*virtual*/ void Orbiter_OpenGL::DisplayImageOnScreen(SDL_Surface *m_pScreenImage)
{
	if(m_bQuit)
		return;

	WakeupFromCondWait();
}
//-----------------------------------------------------------------------------------------------------
/*virtual*/ void Orbiter_OpenGL::RedrawObjects()
{
    PLUTO_SAFETY_LOCK(cm,m_ScreenMutex);
    Orbiter::RedrawObjects();
}
//-----------------------------------------------------------------------------------------------------
/*virtual*/ void Orbiter_OpenGL::RenderText(string &TextToDisplay,DesignObjText *Text,TextStyle *pTextStyle, PlutoPoint point)
{

}
//-----------------------------------------------------------------------------------------------------
/*virtual*/ void Orbiter_OpenGL::HollowRectangle(int X, int Y, int Width, int Height, PlutoColor color)
{
	ClipRectangle(X, Y, Width, Height);
	//sge_Rect(m_pScreenImage,X,Y,Width + X,Height + Y,color.m_Value);
}

//-----------------------------------------------------------------------------------------------------
/*virtual*/ void Orbiter_OpenGL::SolidRectangle(int x, int y, int width, int height, PlutoColor color)
{
	ClipRectangle(x, y, width, height);

	SDL_Rect Rectangle;
	Rectangle.x = x; Rectangle.y = y; Rectangle.w = width; Rectangle.h = height;

	if(color.A() < 255)
	{
		SDL_Rect rectBar;
		rectBar.x = 0; rectBar.y = 0; rectBar.w = width; rectBar.h = height;
		SDL_Surface *pSDL_Bar = SDL_CreateRGBSurface(SDL_SWSURFACE | SDL_SRCALPHA, rectBar.w, rectBar.h, 32, rmask, gmask, bmask, amask);
		SDL_FillRect(pSDL_Bar, &rectBar, SDL_MapRGBA(pSDL_Bar->format, color.R(), color.G(), color.B(), color.A()));

		X_LockDisplay();
		SDL_BlitSurface(pSDL_Bar, NULL, m_pScreenImage, &Rectangle);
		X_UnlockDisplay();
		SDL_FreeSurface(pSDL_Bar);	
	}
	else
	{
		X_LockDisplay();
		SDL_FillRect(m_pScreenImage, &Rectangle, SDL_MapRGBA(m_pScreenImage->format, color.R(), color.G(), color.B(), color.A()));
		X_UnlockDisplay();
	}
}

//-----------------------------------------------------------------------------------------------------
/*virtual*/ void Orbiter_OpenGL::RenderGraphic(PlutoGraphic *pPlutoGraphic, PlutoRectangle rectTotal,
    bool bDisableAspectRatio, PlutoPoint point)
{

	/*
	if(!pPlutoGraphic || pPlutoGraphic->GraphicType_get() != gtSDLGraphic)
		return;//nothing to render or not an sdl graphic

	if(pPlutoGraphic->IsEmpty())
		return;

    SDLGraphic *pSDLGraphic = (SDLGraphic *) pPlutoGraphic;
	SDL_Surface *pSDL_Surface = pSDLGraphic->m_pSDL_Surface;

	//render the sdl surface
	SDL_Rect Destination;
	Destination.x = point.X + rectTotal.X;
	Destination.y = point.Y + rectTotal.Y;
	Destination.w = rectTotal.Width;
	Destination.h = rectTotal.Height;

	if(pSDL_Surface->w == 0 || pSDL_Surface->h == 0) //nothing to render
		return; //malformated image?
	else
		if(pSDL_Surface->w != rectTotal.Width || pSDL_Surface->h != rectTotal.Height) //different size. we'll have to stretch the surface
		{
			double ZoomX = 1;
			double ZoomY = 1;

			SDL_Surface *rotozoom_picture;

			if(bDisableAspectRatio) //no aspect ratio kept
			{
				ZoomX = rectTotal.Width / double(pSDL_Surface->w);
				ZoomY = rectTotal.Height / double(pSDL_Surface->h);
			}
			else //we'll have to keep the aspect
			{
				ZoomX = ZoomY = min(rectTotal.Width / double(pSDL_Surface->w),
					rectTotal.Height / double(pSDL_Surface->h));
			}

			rotozoom_picture = zoomSurface(pSDL_Surface, ZoomX, ZoomY, SMOOTHING_ON);

            X_LockDisplay();
			SDL_BlitSurface(rotozoom_picture, NULL, m_pScreenImage, &Destination);
			SDL_FreeSurface(rotozoom_picture);
            X_UnlockDisplay();
		}
		else //same size ... just blit the surface
        {
            X_LockDisplay();
            SDL_BlitSurface(pSDL_Surface, NULL, m_pScreenImage, &Destination);
            X_UnlockDisplay();
        }

		*/
}
//-----------------------------------------------------------------------------------------------------
/*virtual*/ void Orbiter_OpenGL::SaveBackgroundForDeselect(DesignObj_Orbiter *pObj, PlutoPoint point)
{
	/*
	SDL_Rect SourceRect;
	SourceRect.x = point.X + pObj->m_rPosition.Left(); SourceRect.y = point.Y + pObj->m_rPosition.Top();
	SourceRect.w = pObj->m_rPosition.Width; SourceRect.h = pObj->m_rPosition.Height;
		
	SDL_Surface *pSDL_Surface = SDL_CreateRGBSurface(SDL_SWSURFACE,
		pObj->m_rPosition.Width, pObj->m_rPosition.Height, 32, rmask, gmask, bmask, amask);
		
	X_LockDisplay();
	SDL_BlitSurface(m_pScreenImage, &SourceRect, pSDL_Surface, NULL);
	SDL_SetAlpha(pSDL_Surface, SDL_RLEACCEL , SDL_ALPHA_OPAQUE);
	X_UnlockDisplay();

	pObj->m_pGraphicToUndoSelect = new SDLGraphic(pSDL_Surface);
	*/
}

PlutoGraphic *Orbiter_OpenGL::GetBackground( PlutoRectangle &rect )
{
  
	return NULL;
}

void Orbiter_OpenGL::Initialize(GraphicType Type, int iPK_Room, int iPK_EntertainArea)
{
    Orbiter::Initialize(Type, iPK_Room, iPK_EntertainArea);
}

void Orbiter_OpenGL::ReplaceColorInRectangle(int x, int y, int width, int height, PlutoColor ColorToReplace, PlutoColor ReplacementColor)
{

}

/*virtual*/ void Orbiter_OpenGL::BeginPaint()
{
}

/*virtual*/ void Orbiter_OpenGL::EndPaint()
{
    //if we are using a buffer surface to blit images and text (Bluetooth_Dongle uses this)
    //will have to update the hole screen
    //if not, the user will call UpdateRect function for each rectangle he must invalidate
#ifndef USE_ONLY_SCREEN_SURFACE
    DisplayImageOnScreen(m_pScreenImage);
#endif

	CallMaintenanceInMiliseconds(0, (DCE::OrbiterCallBack)&Orbiter_OpenGL::OpenGLUpdateScreen, NULL, pe_NO);
}

/*virtual*/ void Orbiter_OpenGL::OnQuit()
{
    g_pPlutoLogger->Write(LV_WARNING,"Got an on quit.  Pushing an event into SDL");
    m_bQuit = true;
    pthread_cond_broadcast( &m_listMessageQueueCond );
    SDL_Event *pEvent = new SDL_Event;
    pEvent->type = SDL_QUIT;
    SDL_PushEvent(pEvent);
    delete pEvent;
}

/*virtual*/ PlutoGraphic *Orbiter_OpenGL::CreateGraphic()
{
    return NULL;
}

/*virtual*/ void Orbiter_OpenGL::UpdateRect(PlutoRectangle rect, PlutoPoint point)
{
    //clipping the rectangle
    PlutoRectangle localrect = rect;
    localrect.X += point.X;
    localrect.Y += point.Y;

	ClipRectangle(localrect);
}

void Orbiter_OpenGL::OnIdle()
{
    WakeupFromCondWait();
    Sleep(5);
}

void Orbiter_OpenGL::WakeupFromCondWait()
{
	pthread_cond_broadcast(&m_GLThreadCond);
}

void Orbiter_OpenGL::DoHighlightObject()
{
	g_pPlutoLogger->Write(LV_WARNING, "Orbiter_OpenGL::DoHighlightObject");

	DoHighlightObjectOpenGL();
}

void Orbiter_OpenGL::DoHighlightObjectOpenGL()
{
	if(sbNoSelection == m_nSelectionBehaviour)
		return;

	PLUTO_SAFETY_LOCK( cm, m_ScreenMutex );  // Protect the highlighed object
	if( m_pGraphicBeforeHighlight )
		UnHighlightObject();

	if( !m_pObj_Highlighted )
		return;

	if( m_pObj_Highlighted->m_ObjectType==DESIGNOBJTYPE_Datagrid_CONST )
	{
		DesignObj_DataGrid *pGrid = (DesignObj_DataGrid *) m_pObj_Highlighted;
		PLUTO_SAFETY_LOCK( dg, m_DatagridMutex );

		int nHColumn = pGrid->m_iHighlightedColumn!=-1 ? pGrid->m_iHighlightedColumn + pGrid->m_GridCurCol : pGrid->m_GridCurCol;
		int nHRow = pGrid->m_iHighlightedRow!=-1 ? pGrid->m_iHighlightedRow + pGrid->m_GridCurRow - (pGrid->m_iUpRow >= 0 ? 1 : 0) : 0;

		if( nHColumn==-1 && nHRow==-1 )
			return;

		if(!pGrid->m_pDataGridTable)
			return;

		if(nHRow < pGrid->m_pDataGridTable->m_StartingRow)
		{
			pGrid->m_iHighlightedRow = 1;
			nHRow = pGrid->m_pDataGridTable->m_StartingRow; //set the highlighted row
		}

		DataGridCell *pCell = pGrid->m_pDataGridTable->GetData(nHColumn, nHRow); 
		if( !pCell )
		{
			g_pPlutoLogger->Write(LV_CRITICAL,"Orbiter::DoHighlightObject cell is null.  obj %s col %d row %d",
				m_pObj_Highlighted->m_ObjectID.c_str(), nHColumn, nHRow);
			return;

		}

		//the datagrid is highlighted, but no row is highlighted; we don't want to select the whole datagrid
		if(pGrid->m_iHighlightedRow == -1)
			pGrid->m_iHighlightedRow = 0;

		PlutoRectangle r;
		GetGridCellDimensions( pGrid,  
			pGrid->m_iHighlightedColumn==-1 ? pGrid->m_MaxCol : pCell->m_Colspan, 
			pGrid->m_iHighlightedRow==-1 ? pGrid->m_MaxRow : pCell->m_Rowspan,
			pGrid->m_iHighlightedColumn==-1 ? 0 : pGrid->m_iHighlightedColumn, 
			pGrid->m_iHighlightedRow==-1 ? 0 : pGrid->m_iHighlightedRow, 
			r.X,  r.Y,  r.Width,  r.Height );

		m_rectLastHighlight.X = max(0,r.X);
		m_rectLastHighlight.Y = max(0,r.Y);
		m_rectLastHighlight.Right( min(r.Right(),m_Width-1) );
		m_rectLastHighlight.Bottom( min(r.Bottom(),m_Height-1) );
	}
	else
		m_rectLastHighlight = m_pObj_Highlighted->GetHighlightRegion();

	m_rectLastHighlight.X += m_pObj_Highlighted->m_pPopupPoint.X;
	m_rectLastHighlight.Y += m_pObj_Highlighted->m_pPopupPoint.Y;

	m_rectLastHighlight.Width++;  // GetBackground always seems to be 1 pixel to little
	m_rectLastHighlight.Height++;

	FloatRect HighLightArea;
	HighLightArea.Left = (float)m_rectLastHighlight.Left();
	HighLightArea.Top = (float)m_rectLastHighlight.Top();
	HighLightArea.Width =  (float)m_rectLastHighlight.Width;
	HighLightArea.Height = (float)m_rectLastHighlight.Height;

	Commons3D::Instance().SetHighLightArea(&HighLightArea);

	g_pPlutoLogger->Write(LV_WARNING, ">> Orbiter_OpenGL::DoHighlightObjectOpenGL : GL2D_EFFECT_HIGHLIGHT_AREA");

	GL2DEffect * Effect = m_Desktop->EffectBuilder->CreateEffect(GL2D_EFFECT_HIGHLIGHT_AREA, 
		Simulator::GetInstance()->m_iMilisecondsHighLight);

	if(Effect)
		Effect->Configure(&m_rectLastHighlight);
	else
		g_pPlutoLogger->Write(LV_CRITICAL, ">> Orbiter_OpenGL::DoHighlightObjectOpenGL : no effect???!");
}

void Orbiter_OpenGL::SelectObject( class DesignObj_Orbiter *pObj, PlutoPoint point )
{
	FloatRect SelectedArea;
	SelectedArea.Left   = (float)point.X + pObj->m_rBackgroundPosition.X;
	SelectedArea.Top    = (float)(point.Y + pObj->m_rBackgroundPosition.Y);
	SelectedArea.Width  = (float)pObj->m_rBackgroundPosition.Width;
	SelectedArea.Height = (float)pObj->m_rBackgroundPosition.Height;

	Commons3D::Instance().SetSelectedArea(&SelectedArea);
	GL2DEffect * Effect = m_Desktop->EffectBuilder->CreateEffect(GL2D_EFFECT_SELECT_AREA, 
		Simulator::GetInstance()->m_iMilisecondsHighLight);

	if(!Effect)
		return;
	PlutoRectangle SeclectedAreaEffectSize;
	SeclectedAreaEffectSize.X = point.X + pObj->m_rBackgroundPosition.X;
	SeclectedAreaEffectSize.Y = point.Y + pObj->m_rBackgroundPosition.Y;
	SeclectedAreaEffectSize.Width = pObj->m_rBackgroundPosition.Width;
	SeclectedAreaEffectSize.Height = pObj->m_rBackgroundPosition.Height;
		
	Effect->Configure(&SeclectedAreaEffectSize);
}  

/*virtual*/ void Orbiter_OpenGL::OpenGLUpdateScreen(void* Data)
{

}
