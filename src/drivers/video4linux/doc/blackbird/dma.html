<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>iTVC15 DMA Info</title>
</head>

<body>
<center>
	<h2>iTVC15 DMA Info</h2>
	<table width="60%"><tr><td>
	<i>This page describes the structures and procedures used by the iTVC15's DMA engine.</i>
	</td></tr></table>

	<br>

    <table width="60%" border="1" cellspacing="0" cellpadding="5">
		<tr><th>Introduction</th></tr>
		<tr><td>
The iTVC15's PCI interface is busmaster capable.  This means it has a DMA
engine to efficiently transfer large volumes of data between the card and
main memory without requiring help from a CPU.  Like most hardware, it must
operate on contiguous physical memory.  This is difficult to come by in large
quantities on virtual memory machines.

<p>Therefore, it also supports a technique called "scatter-gather".  
The card can transfer multiple buffers in one operation.  Instead
of allocating one large contiguous buffer, the driver can allocate
several smaller buffers.</p>

<p>In practice, I've seen the average transfer to be roughly 80K, but
transfers above 128K were not uncommon, particularly at startup.  The
128K figure is important, because that is the largest block that the
kernel can normally allocate.  Even still, 128K blocks are hard to
come by, so the driver writer is urged to choose a smaller block size
and learn the scatter-gather technique.</p>

<p>Mailbox #10 is reserved for DMA transfer information.</p>
		</td></tr>
	</table>

	<br>

    <table width="60%" border="1" cellspacing="0" cellpadding="5">
		<tr><th>Flow</th></tr>
		<tr><td>
This section describes, in general, the order of events when handling 
DMA transfers.  Detailed information follows this section.
<ul>
<li>The card raises the Encoder interrupt.
<li>The driver reads the transfer type, offset and size from Mailbox #10.
<li>The driver constructs the scatter-gather array from enough free dma 
buffers to cover the size.
<li>The driver schedules the DMA transfer via the ScheduleDMAtoHost API
call.
<li>The card raises the DMA Complete interrupt.
<li>The driver checks the DMA status register for any errors.
<li>The driver post-processes the newly transferred buffers.
</ul>				  
NOTE! It is possible that the Encoder and DMA Complete interrupts get
raised simultaneously.  (End of the last, start of the next, etc.)
		</td></tr>
	</table>

	<br>

    <table width="60%" border="1" cellspacing="0" cellpadding="5">
		<tr><th>Mailbox #10</tr>
		<tr><td>
The Flags, Command, Return Value and Timeout fields are ignored.

			<center>
			<pre><table border="1" width="90%">
			<tr><th width="25%">Name</th><td>Mailbox #10</td></tr>
			<tr><th>Enum</th><td>NA</td></tr>
			<tr><th>#Params</td><td>NA</td></tr>
			<tr><th>#Results</td><td>3</td></tr>
			<tr><th>Results[0]</td><td>Type: 0: MPEG.</td></tr>
			<tr><th>Results[1]</td><td>Offset: The position relative to the card's 
				  memory space.</td></tr>
			<tr><th>Results[2]</td><td>Size: The exact number of bytes to transfer.</td></tr>
			</table></pre>
			</center>

My speculation is that since the StartCapture API has a capture
type of "RAW" available, that the type field will have other
values that correspond to YUV and PCM data.
		</td></tr>
	</table>

	<br>

    <table width="60%" border="1" cellspacing="0" cellpadding="5">
		<tr><th>Scatter-Gather Array</th></tr>
		<tr><td>
The scatter-gather array is a contiguously allocated block of memory
that tells the card the source and destination of each data-block to
transfer.  Card "addresses" are derived from the offset supplied by 
Mailbox #10.  Host addresses are the physical memory location of the
target DMA buffer.

<p>Each S-G array element is a struct of three 32-bit words.  The 
first word is the source address, the second is the destination address.  
Both take up the entire 32 bits.  The lowest 16 bits of the third word 
is the transfer byte count.  The high-bit of the third word is the "last"
flag.  The last-flag tells the card to raise the DMA_DONE interrupt.
From hard personal experience, if you forget to set this bit, the
card will still "work" but the stream will most likely get corrupted.</p>

<p>The transfer count must be a multiple of 256.  Therefore, the driver
will need to track how much data in the target buffer is valid and
deal with it accordingly.</p>
			<center>
			<pre><table border="1" width="90%" cellpadding="0">
			<tr><th colspan=32>Array Element</th></tr>
			<tr><td colspan=32><center>Source Address</center></td></tr>
			<tr><td colspan=32><center>Destination Address</center></td></tr>
			<tr><td colspan=1><center>L</center></td>
				<td colspan=15><center>(reserved)</center></td>
				<td colspan=16><center>Byte Count</center></td></tr>
			</table></pre>
			</center>


		</td></tr>
	</table>

	<br>

    <table width="60%" border="1" cellspacing="0" cellpadding="5">
		<tr><th>DMA Transfer Status</th></tr>
		<tr><td>
Register 0x0004 holds the DMA Transfer Status:
<pre>	Bit 
	4 Scatter-Gather array error
	3 DMA write error
	2 DMA read error
	1 write completed</pre>
		</td></tr>
	</table>

	<br>
	<table width="60%" cellspacing="0" cellpadding="5">
	<tr><td><font size="-1"><center>Copyright 2003 The IvyTV Team<br>iTVC15 is a trademark of Conexant Systems, Inc.</center></font>
<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=73219&type=1" width="88" height="31" border="0" alt="SourceForge.net Logo"></a></td></tr>
	</table>

</center>
</body>

</html>
