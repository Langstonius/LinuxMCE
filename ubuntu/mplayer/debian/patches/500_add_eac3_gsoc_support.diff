diff -ruN mplayer.orig/libavcodec/aac_ac3_parser.c mplayer.eac3/libavcodec/aac_ac3_parser.c
--- mplayer.orig/libavcodec/aac_ac3_parser.c	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavcodec/aac_ac3_parser.c	2007-10-19 14:13:32.000000000 +0300
@@ -50,7 +50,7 @@
 
         if (s->frame_size == 0) {
             if ((s->inbuf_ptr - s->inbuf) == s->header_size) {
-                len = s->sync(s->inbuf, &channels, &sample_rate, &bit_rate,
+                len = s->sync(avctx, s->inbuf, &channels, &sample_rate, &bit_rate,
                               &samples);
                 if (len == 0) {
                     /* no sync found : move by one byte (inefficient, but simple!) */
@@ -61,7 +61,7 @@
                     /* update codec info */
                     avctx->sample_rate = sample_rate;
                     /* set channels,except if the user explicitly requests 1 or 2 channels, XXX/FIXME this is a bit ugly */
-                    if(avctx->codec_id == CODEC_ID_AC3){
+                    if(avctx->codec_id == CODEC_ID_AC3 || avctx->codec_id == CODEC_ID_EAC3){
                         if(avctx->channels!=1 && avctx->channels!=2){
                             avctx->channels = channels;
                         }
diff -ruN mplayer.orig/libavcodec/aac_ac3_parser.c.orig mplayer.eac3/libavcodec/aac_ac3_parser.c.orig
--- mplayer.orig/libavcodec/aac_ac3_parser.c.orig	1970-01-01 03:00:00.000000000 +0300
+++ mplayer.eac3/libavcodec/aac_ac3_parser.c.orig	2007-10-19 14:13:18.000000000 +0300
@@ -0,0 +1,86 @@
+/*
+ * Common AAC and AC3 parser
+ * Copyright (c) 2003 Fabrice Bellard.
+ * Copyright (c) 2003 Michael Niedermayer.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "parser.h"
+#include "aac_ac3_parser.h"
+
+int ff_aac_ac3_parse(AVCodecParserContext *s1,
+                     AVCodecContext *avctx,
+                     const uint8_t **poutbuf, int *poutbuf_size,
+                     const uint8_t *buf, int buf_size)
+{
+    AACAC3ParseContext *s = s1->priv_data;
+    const uint8_t *buf_ptr;
+    int len, sample_rate, bit_rate, channels, samples;
+
+    *poutbuf = NULL;
+    *poutbuf_size = 0;
+
+    buf_ptr = buf;
+    while (buf_size > 0) {
+        int size_needed= s->frame_size ? s->frame_size : s->header_size;
+        len = s->inbuf_ptr - s->inbuf;
+
+        if(len<size_needed){
+            len = FFMIN(size_needed - len, buf_size);
+            memcpy(s->inbuf_ptr, buf_ptr, len);
+            buf_ptr      += len;
+            s->inbuf_ptr += len;
+            buf_size     -= len;
+        }
+
+        if (s->frame_size == 0) {
+            if ((s->inbuf_ptr - s->inbuf) == s->header_size) {
+                len = s->sync(s->inbuf, &channels, &sample_rate, &bit_rate,
+                              &samples);
+                if (len == 0) {
+                    /* no sync found : move by one byte (inefficient, but simple!) */
+                    memmove(s->inbuf, s->inbuf + 1, s->header_size - 1);
+                    s->inbuf_ptr--;
+                } else {
+                    s->frame_size = len;
+                    /* update codec info */
+                    avctx->sample_rate = sample_rate;
+                    /* set channels,except if the user explicitly requests 1 or 2 channels, XXX/FIXME this is a bit ugly */
+                    if(avctx->codec_id == CODEC_ID_AC3){
+                        if(avctx->channels!=1 && avctx->channels!=2){
+                            avctx->channels = channels;
+                        }
+                    } else {
+                        avctx->channels = channels;
+                    }
+                    avctx->bit_rate = bit_rate;
+                    avctx->frame_size = samples;
+                }
+            }
+        } else {
+            if(s->inbuf_ptr - s->inbuf == s->frame_size){
+                *poutbuf = s->inbuf;
+                *poutbuf_size = s->frame_size;
+                s->inbuf_ptr = s->inbuf;
+                s->frame_size = 0;
+                break;
+            }
+        }
+    }
+    return buf_ptr - buf;
+}
diff -ruN mplayer.orig/libavcodec/aac_ac3_parser.h mplayer.eac3/libavcodec/aac_ac3_parser.h
--- mplayer.orig/libavcodec/aac_ac3_parser.h	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavcodec/aac_ac3_parser.h	2007-10-19 14:13:32.000000000 +0300
@@ -30,7 +30,7 @@
     uint8_t *inbuf_ptr;
     int frame_size;
     int header_size;
-    int (*sync)(const uint8_t *buf, int *channels, int *sample_rate,
+    int (*sync)(AVCodecContext *avctx, const uint8_t *buf, int *channels, int *sample_rate,
                 int *bit_rate, int *samples);
     uint8_t inbuf[8192]; /* input buffer */
 } AACAC3ParseContext;
diff -ruN mplayer.orig/libavcodec/aac_parser.c mplayer.eac3/libavcodec/aac_parser.c
--- mplayer.orig/libavcodec/aac_parser.c	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavcodec/aac_parser.c	2007-10-19 14:13:32.000000000 +0300
@@ -38,7 +38,7 @@
 };
 
 
-static int aac_sync(const uint8_t *buf, int *channels, int *sample_rate,
+static int aac_sync(AVCodecContext *avctx, const uint8_t *buf, int *channels, int *sample_rate,
                     int *bit_rate, int *samples)
 {
     GetBitContext bits;
diff -ruN mplayer.orig/libavcodec/ac3.c mplayer.eac3/libavcodec/ac3.c
--- mplayer.orig/libavcodec/ac3.c	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavcodec/ac3.c	2007-10-19 14:13:32.000000000 +0300
@@ -173,7 +173,7 @@
 }
 
 void ff_ac3_bit_alloc_calc_bap(int16_t *mask, int16_t *psd, int start, int end,
-                               int snroffset, int floor, uint8_t *bap)
+                               int snroffset, int floor, const uint8_t *baptab, uint8_t *bap)
 {
     int i, j, k, end1, v, address;
 
@@ -190,7 +190,7 @@
         end1 = FFMIN(bndtab[j] + ff_ac3_bndsz[j], end);
         for (k = i; k < end1; k++) {
             address = av_clip((psd[i] - v) >> 5, 0, 63);
-            bap[i] = ff_ac3_baptab[address];
+            bap[i] = baptab[address];
             i++;
         }
     } while (end > bndtab[j++]);
@@ -215,7 +215,7 @@
                                deltbae, deltnseg, deltoffst, deltlen, deltba,
                                mask);
 
-    ff_ac3_bit_alloc_calc_bap(mask, psd, start, end, snroffset, s->floor, bap);
+    ff_ac3_bit_alloc_calc_bap(mask, psd, start, end, snroffset, s->floor, ff_ac3_baptab, bap);
 }
 
 /**
diff -ruN mplayer.orig/libavcodec/ac3dec.c mplayer.eac3/libavcodec/ac3dec.c
--- mplayer.orig/libavcodec/ac3dec.c	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavcodec/ac3dec.c	2007-10-19 14:13:32.000000000 +0300
@@ -37,29 +37,24 @@
 #include "bitstream.h"
 #include "dsputil.h"
 #include "random.h"
-
-/**
- * Table of bin locations for rematrixing bands
- * reference: Section 7.5.2 Rematrixing : Frequency Band Definitions
- */
-static const uint8_t rematrix_band_tab[5] = { 13, 25, 37, 61, 253 };
+#include "ac3dec.h"
 
 /**
  * table for exponent to scale_factor mapping
- * scale_factors[i] = 2 ^ -i
+ * ff_ac3_scale_factors[i] = 2 ^ -i
  */
-static float scale_factors[25];
+float ff_ac3_scale_factors[25];
 
 /** table for grouping exponents */
-static uint8_t exp_ungroup_tab[128][3];
+uint8_t ff_ac3_exp_ungroup_tbl[128][3];
 
 
 /** tables for ungrouping mantissas */
-static float b1_mantissas[32][3];
-static float b2_mantissas[128][3];
-static float b3_mantissas[8];
-static float b4_mantissas[128][2];
-static float b5_mantissas[16];
+float ff_ac3_b1_mantissas[32][3];
+float ff_ac3_b2_mantissas[128][3];
+float ff_ac3_b3_mantissas[8];
+float ff_ac3_b4_mantissas[128][2];
+float ff_ac3_b5_mantissas[16];
 
 /**
  * Quantization table: levels for symmetric. bits for asymmetric.
@@ -71,18 +66,10 @@
 };
 
 /** dynamic range table. converts codes to scale factors. */
-static float dynrng_tab[256];
+float ff_ac3_dynrng_tbl[256];
 
 /** dialogue normalization table */
-static float dialnorm_tab[32];
-
-/** Adjustments in dB gain */
-#define LEVEL_MINUS_3DB         0.7071067811865476
-#define LEVEL_MINUS_4POINT5DB   0.5946035575013605
-#define LEVEL_MINUS_6DB         0.5000000000000000
-#define LEVEL_MINUS_9DB         0.3535533905932738
-#define LEVEL_ZERO              0.0000000000000000
-#define LEVEL_ONE               1.0000000000000000
+float ff_ac3_dialnorm_tbl[32];
 
 static const float gain_levels[6] = {
     LEVEL_ZERO,
@@ -123,7 +110,6 @@
 /* override ac3.h to include coupling channel */
 #undef AC3_MAX_CHANNELS
 #define AC3_MAX_CHANNELS 7
-#define CPL_CH 0
 
 #define AC3_OUTPUT_LFEON  8
 
@@ -201,7 +187,7 @@
 /**
  * Generate a Kaiser-Bessel Derived Window.
  */
-static void ac3_window_init(float *window)
+void ff_ac3_window_init(float *window)
 {
    int i, j;
    double sum = 0.0, bessel, tmp;
@@ -236,7 +222,7 @@
 /*
  * Initialize tables at runtime.
  */
-static void ac3_tables_init(void)
+void ff_ac3_tables_init(void)
 {
     int i;
 
@@ -244,57 +230,57 @@
        reference: Section 7.3.5 Ungrouping of Mantissas */
     for(i=0; i<32; i++) {
         /* bap=1 mantissas */
-        b1_mantissas[i][0] = symmetric_dequant( i / 9     , 3);
-        b1_mantissas[i][1] = symmetric_dequant((i % 9) / 3, 3);
-        b1_mantissas[i][2] = symmetric_dequant((i % 9) % 3, 3);
+        ff_ac3_b1_mantissas[i][0] = symmetric_dequant( i / 9     , 3);
+        ff_ac3_b1_mantissas[i][1] = symmetric_dequant((i % 9) / 3, 3);
+        ff_ac3_b1_mantissas[i][2] = symmetric_dequant((i % 9) % 3, 3);
     }
     for(i=0; i<128; i++) {
         /* bap=2 mantissas */
-        b2_mantissas[i][0] = symmetric_dequant( i / 25     , 5);
-        b2_mantissas[i][1] = symmetric_dequant((i % 25) / 5, 5);
-        b2_mantissas[i][2] = symmetric_dequant((i % 25) % 5, 5);
+        ff_ac3_b2_mantissas[i][0] = symmetric_dequant( i / 25     , 5);
+        ff_ac3_b2_mantissas[i][1] = symmetric_dequant((i % 25) / 5, 5);
+        ff_ac3_b2_mantissas[i][2] = symmetric_dequant((i % 25) % 5, 5);
 
         /* bap=4 mantissas */
-        b4_mantissas[i][0] = symmetric_dequant(i / 11, 11);
-        b4_mantissas[i][1] = symmetric_dequant(i % 11, 11);
+        ff_ac3_b4_mantissas[i][0] = symmetric_dequant(i / 11, 11);
+        ff_ac3_b4_mantissas[i][1] = symmetric_dequant(i % 11, 11);
     }
     /* generate ungrouped mantissa tables
        reference: Tables 7.21 and 7.23 */
     for(i=0; i<7; i++) {
         /* bap=3 mantissas */
-        b3_mantissas[i] = symmetric_dequant(i, 7);
+        ff_ac3_b3_mantissas[i] = symmetric_dequant(i, 7);
     }
     for(i=0; i<15; i++) {
         /* bap=5 mantissas */
-        b5_mantissas[i] = symmetric_dequant(i, 15);
+        ff_ac3_b5_mantissas[i] = symmetric_dequant(i, 15);
     }
 
     /* generate dynamic range table
        reference: Section 7.7.1 Dynamic Range Control */
     for(i=0; i<256; i++) {
         int v = (i >> 5) - ((i >> 7) << 3) - 5;
-        dynrng_tab[i] = powf(2.0f, v) * ((i & 0x1F) | 0x20);
+        ff_ac3_dynrng_tbl[i] = powf(2.0f, v) * ((i & 0x1F) | 0x20);
     }
 
     /* generate dialogue normalization table
        references: Section 5.4.2.8 dialnorm
                    Section 7.6 Dialogue Normalization */
     for(i=1; i<32; i++) {
-        dialnorm_tab[i] = expf((i-31) * M_LN10 / 20.0f);
+        ff_ac3_dialnorm_tbl[i] = expf((i-31) * M_LN10 / 20.0f);
     }
-    dialnorm_tab[0] = dialnorm_tab[31];
+    ff_ac3_dialnorm_tbl[0] = ff_ac3_dialnorm_tbl[31];
 
     /* generate scale factors for exponents and asymmetrical dequantization
        reference: Section 7.3.2 Expansion of Mantissas for Asymmetric Quantization */
     for (i = 0; i < 25; i++)
-        scale_factors[i] = pow(2.0, -i);
+        ff_ac3_scale_factors[i] = pow(2.0, -i);
 
     /* generate exponent tables
        reference: Section 7.1.3 Exponent Decoding */
     for(i=0; i<128; i++) {
-        exp_ungroup_tab[i][0] =  i / 25;
-        exp_ungroup_tab[i][1] = (i % 25) / 5;
-        exp_ungroup_tab[i][2] = (i % 25) % 5;
+        ff_ac3_exp_ungroup_tbl[i][0] =  i / 25;
+        ff_ac3_exp_ungroup_tbl[i][1] = (i % 25) / 5;
+        ff_ac3_exp_ungroup_tbl[i][2] = (i % 25) % 5;
     }
 }
 
@@ -308,10 +294,10 @@
     ctx->avctx = avctx;
 
     ac3_common_init();
-    ac3_tables_init();
+    ff_ac3_tables_init();
     ff_mdct_init(&ctx->imdct_256, 8, 1);
     ff_mdct_init(&ctx->imdct_512, 9, 1);
-    ac3_window_init(ctx->window);
+    ff_ac3_window_init(ctx->window);
     dsputil_init(&ctx->dsp, avctx);
     av_init_random(0, &ctx->dith_state);
 
@@ -382,7 +368,7 @@
     /* read the rest of the bsi. read twice for dual mono mode. */
     i = !(ctx->acmod);
     do {
-        ctx->dialnorm[i] = dialnorm_tab[get_bits(gb, 5)]; // dialogue normalization
+        ctx->dialnorm[i] = ff_ac3_dialnorm_tbl[get_bits(gb, 5)]; // dialogue normalization
         if (get_bits1(gb))
             skip_bits(gb, 8); //skip compression
         if (get_bits1(gb))
@@ -433,7 +419,7 @@
  * Decode the grouped exponents according to exponent strategy.
  * reference: Section 7.1.3 Exponent Decoding
  */
-static void decode_exponents(GetBitContext *gb, int expstr, int ngrps,
+void ff_ac3_decode_exponents(GetBitContext *gb, int expstr, int ngrps,
                              uint8_t absexp, int8_t *dexps)
 {
     int i, j, grp, grpsize;
@@ -444,9 +430,9 @@
     grpsize = expstr + (expstr == EXP_D45);
     for(grp=0,i=0; grp<ngrps; grp++) {
         expacc = get_bits(gb, 7);
-        dexp[i++] = exp_ungroup_tab[expacc][0];
-        dexp[i++] = exp_ungroup_tab[expacc][1];
-        dexp[i++] = exp_ungroup_tab[expacc][2];
+        dexp[i++] = ff_ac3_exp_ungroup_tbl[expacc][0];
+        dexp[i++] = ff_ac3_exp_ungroup_tbl[expacc][1];
+        dexp[i++] = ff_ac3_exp_ungroup_tbl[expacc][2];
     }
 
     /* convert to absolute exps and expand groups */
@@ -485,48 +471,28 @@
 }
 
 /**
- * Grouped mantissas for 3-level 5-level and 11-level quantization
- */
-typedef struct {
-    float b1_mant[3];
-    float b2_mant[3];
-    float b4_mant[2];
-    int b1ptr;
-    int b2ptr;
-    int b4ptr;
-} mant_groups;
-
-/**
  * Get the transform coefficients for a particular channel
  * reference: Section 7.3 Quantization and Decoding of Mantissas
  */
-static int get_transform_coeffs_ch(AC3DecodeContext *ctx, int ch_index, mant_groups *m)
+int ff_ac3_get_transform_coeffs_ch(mant_groups *m, GetBitContext *gb,
+        uint8_t *exps, uint8_t *bap, float *coeffs, int start, int end,
+        AVRandomState *dith_state)
 {
-    GetBitContext *gb = &ctx->gb;
-    int i, gcode, tbap, start, end;
-    uint8_t *exps;
-    uint8_t *bap;
-    float *coeffs;
-
-    exps = ctx->dexps[ch_index];
-    bap = ctx->bap[ch_index];
-    coeffs = ctx->transform_coeffs[ch_index];
-    start = ctx->startmant[ch_index];
-    end = ctx->endmant[ch_index];
+    int i, gcode, tbap;
 
     for (i = start; i < end; i++) {
         tbap = bap[i];
         switch (tbap) {
             case 0:
-                coeffs[i] = ((av_random(&ctx->dith_state) & 0xFFFF) / 65535.0f) - 0.5f;
+                coeffs[i] = ((av_random(dith_state) & 0xFFFF) * LEVEL_MINUS_3DB) / 32768.0f;
                 break;
 
             case 1:
                 if(m->b1ptr > 2) {
                     gcode = get_bits(gb, 5);
-                    m->b1_mant[0] = b1_mantissas[gcode][0];
-                    m->b1_mant[1] = b1_mantissas[gcode][1];
-                    m->b1_mant[2] = b1_mantissas[gcode][2];
+                    m->b1_mant[0] = ff_ac3_b1_mantissas[gcode][0];
+                    m->b1_mant[1] = ff_ac3_b1_mantissas[gcode][1];
+                    m->b1_mant[2] = ff_ac3_b1_mantissas[gcode][2];
                     m->b1ptr = 0;
                 }
                 coeffs[i] = m->b1_mant[m->b1ptr++];
@@ -535,38 +501,38 @@
             case 2:
                 if(m->b2ptr > 2) {
                     gcode = get_bits(gb, 7);
-                    m->b2_mant[0] = b2_mantissas[gcode][0];
-                    m->b2_mant[1] = b2_mantissas[gcode][1];
-                    m->b2_mant[2] = b2_mantissas[gcode][2];
+                    m->b2_mant[0] = ff_ac3_b2_mantissas[gcode][0];
+                    m->b2_mant[1] = ff_ac3_b2_mantissas[gcode][1];
+                    m->b2_mant[2] = ff_ac3_b2_mantissas[gcode][2];
                     m->b2ptr = 0;
                 }
                 coeffs[i] = m->b2_mant[m->b2ptr++];
                 break;
 
             case 3:
-                coeffs[i] = b3_mantissas[get_bits(gb, 3)];
+                coeffs[i] = ff_ac3_b3_mantissas[get_bits(gb, 3)];
                 break;
 
             case 4:
                 if(m->b4ptr > 1) {
                     gcode = get_bits(gb, 7);
-                    m->b4_mant[0] = b4_mantissas[gcode][0];
-                    m->b4_mant[1] = b4_mantissas[gcode][1];
+                    m->b4_mant[0] = ff_ac3_b4_mantissas[gcode][0];
+                    m->b4_mant[1] = ff_ac3_b4_mantissas[gcode][1];
                     m->b4ptr = 0;
                 }
                 coeffs[i] = m->b4_mant[m->b4ptr++];
                 break;
 
             case 5:
-                coeffs[i] = b5_mantissas[get_bits(gb, 4)];
+                coeffs[i] = ff_ac3_b5_mantissas[get_bits(gb, 4)];
                 break;
 
             default:
                 /* asymmetric dequantization */
-                coeffs[i] = get_sbits(gb, qntztab[tbap]) * scale_factors[qntztab[tbap]-1];
+                coeffs[i] = get_sbits(gb, qntztab[tbap]) * ff_ac3_scale_factors[qntztab[tbap]-1];
                 break;
         }
-        coeffs[i] *= scale_factors[exps[i]];
+        coeffs[i] *= ff_ac3_scale_factors[exps[i]];
     }
 
     return 0;
@@ -618,13 +584,19 @@
 
     for (ch = 1; ch <= ctx->nchans; ch++) {
         /* transform coefficients for full-bandwidth channel */
-        if (get_transform_coeffs_ch(ctx, ch, &m))
+        if (ff_ac3_get_transform_coeffs_ch(&m, &ctx->gb, ctx->dexps[ch],
+                    ctx->bap[ch], ctx->transform_coeffs[ch], ctx->startmant[ch],
+                    ctx->endmant[ch], &ctx->dith_state))
             return -1;
         /* tranform coefficients for coupling channel come right after the
            coefficients for the first coupled channel*/
         if (ctx->chincpl[ch])  {
             if (!got_cplchan) {
-                if (get_transform_coeffs_ch(ctx, CPL_CH, &m)) {
+                if (ff_ac3_get_transform_coeffs_ch(&m, &ctx->gb,
+                            ctx->dexps[CPL_CH], ctx->bap[CPL_CH],
+                            ctx->transform_coeffs[CPL_CH],
+                            ctx->startmant[CPL_CH], ctx->endmant[CPL_CH],
+                            &ctx->dith_state)){
                     av_log(ctx->avctx, AV_LOG_ERROR, "error in decoupling channels\n");
                     return -1;
                 }
@@ -651,22 +623,20 @@
  * Stereo rematrixing.
  * reference: Section 7.5.4 Rematrixing : Decoding Technique
  */
-static void do_rematrixing(AC3DecodeContext *ctx)
+void ff_ac3_do_rematrixing(float (*transform_coeffs)[256], int end, int nrematbnd, int *rematflg)
 {
     int bnd, i;
-    int end, bndend;
+    int bndend;
     float tmp0, tmp1;
 
-    end = FFMIN(ctx->endmant[1], ctx->endmant[2]);
-
-    for(bnd=0; bnd<ctx->nrematbnd; bnd++) {
-        if(ctx->rematflg[bnd]) {
-            bndend = FFMIN(end, rematrix_band_tab[bnd+1]);
-            for(i=rematrix_band_tab[bnd]; i<bndend; i++) {
-                tmp0 = ctx->transform_coeffs[1][i];
-                tmp1 = ctx->transform_coeffs[2][i];
-                ctx->transform_coeffs[1][i] = tmp0 + tmp1;
-                ctx->transform_coeffs[2][i] = tmp0 - tmp1;
+    for(bnd=0; bnd<nrematbnd; bnd++) {
+        if(rematflg[bnd]) {
+            bndend = FFMIN(end, ff_ac3_rematrix_band_tbl[bnd+1]);
+            for(i=ff_ac3_rematrix_band_tbl[bnd]; i<bndend; i++) {
+                tmp0 = transform_coeffs[1][i];
+                tmp1 = transform_coeffs[2][i];
+                transform_coeffs[1][i] = tmp0 + tmp1;
+                transform_coeffs[2][i] = tmp0 - tmp1;
             }
         }
     }
@@ -675,41 +645,41 @@
 /**
  * Perform the 256-point IMDCT
  */
-static void do_imdct_256(AC3DecodeContext *ctx, int chindex)
+void ff_ac3_do_imdct_256(float *tmp_output, float *transform_coeffs,
+        MDCTContext *imdct_256, float *tmp_imdct)
 {
     int i, k;
     DECLARE_ALIGNED_16(float, x[128]);
     FFTComplex z[2][64];
-    float *o_ptr = ctx->tmp_output;
 
     for(i=0; i<2; i++) {
         /* de-interleave coefficients */
         for(k=0; k<128; k++) {
-            x[k] = ctx->transform_coeffs[chindex][2*k+i];
+            x[k] = transform_coeffs[2*k+i];
         }
 
         /* run standard IMDCT */
-        ctx->imdct_256.fft.imdct_calc(&ctx->imdct_256, o_ptr, x, ctx->tmp_imdct);
+        imdct_256->fft.imdct_calc(imdct_256, tmp_output, x, tmp_imdct);
 
         /* reverse the post-rotation & reordering from standard IMDCT */
         for(k=0; k<32; k++) {
-            z[i][32+k].re = -o_ptr[128+2*k];
-            z[i][32+k].im = -o_ptr[2*k];
-            z[i][31-k].re =  o_ptr[2*k+1];
-            z[i][31-k].im =  o_ptr[128+2*k+1];
+            z[i][32+k].re = -tmp_output[128+2*k];
+            z[i][32+k].im = -tmp_output[2*k];
+            z[i][31-k].re =  tmp_output[2*k+1];
+            z[i][31-k].im =  tmp_output[128+2*k+1];
         }
     }
 
     /* apply AC-3 post-rotation & reordering */
     for(k=0; k<64; k++) {
-        o_ptr[    2*k  ] = -z[0][   k].im;
-        o_ptr[    2*k+1] =  z[0][63-k].re;
-        o_ptr[128+2*k  ] = -z[0][   k].re;
-        o_ptr[128+2*k+1] =  z[0][63-k].im;
-        o_ptr[256+2*k  ] = -z[1][   k].re;
-        o_ptr[256+2*k+1] =  z[1][63-k].im;
-        o_ptr[384+2*k  ] =  z[1][   k].im;
-        o_ptr[384+2*k+1] = -z[1][63-k].re;
+        tmp_output[    2*k  ] = -z[0][   k].im;
+        tmp_output[    2*k+1] =  z[0][63-k].re;
+        tmp_output[128+2*k  ] = -z[0][   k].re;
+        tmp_output[128+2*k+1] =  z[0][63-k].im;
+        tmp_output[256+2*k  ] = -z[1][   k].re;
+        tmp_output[256+2*k+1] =  z[1][63-k].im;
+        tmp_output[384+2*k  ] =  z[1][   k].im;
+        tmp_output[384+2*k+1] = -z[1][63-k].re;
     }
 }
 
@@ -730,7 +700,8 @@
 
     for (ch=1; ch<=nchans; ch++) {
         if (ctx->blksw[ch]) {
-            do_imdct_256(ctx, ch);
+            ff_ac3_do_imdct_256(ctx->tmp_output, ctx->transform_coeffs[ch],
+                    &ctx->imdct_256, ctx->tmp_imdct);
         } else {
             ctx->imdct_512.fft.imdct_calc(&ctx->imdct_512, ctx->tmp_output,
                                           ctx->transform_coeffs[ch],
@@ -750,7 +721,7 @@
 /**
  * Downmix the output to mono or stereo.
  */
-static void ac3_downmix(float samples[AC3_MAX_CHANNELS][256], int nfchans,
+void ff_ac3_downmix(float samples[AC3_MAX_CHANNELS][256], int nfchans,
                         int output_mode, float coef[AC3_MAX_CHANNELS][2])
 {
     int i, j;
@@ -804,7 +775,7 @@
     i = !(ctx->acmod);
     do {
         if(get_bits1(gb)) {
-            ctx->dynrng[i] = dynrng_tab[get_bits(gb, 8)];
+            ctx->dynrng[i] = ff_ac3_dynrng_tbl[get_bits(gb, 8)];
         } else if(blk == 0) {
             ctx->dynrng[i] = 1.0f;
         }
@@ -866,7 +837,7 @@
                             ctx->cplco[ch][bnd] = cplcomant / 16.0f;
                         else
                             ctx->cplco[ch][bnd] = (cplcomant + 16.0f) / 32.0f;
-                        ctx->cplco[ch][bnd] *= scale_factors[cplcoexp + mstrcplco];
+                        ctx->cplco[ch][bnd] *= ff_ac3_scale_factors[cplcoexp + mstrcplco];
                     }
                 }
             }
@@ -938,7 +909,7 @@
             else
                 ngrps = (ctx->endmant[ch] + grpsize - 4) / grpsize;
             ctx->dexps[ch][0] = get_bits(gb, 4) << !ch;
-            decode_exponents(gb, ctx->expstr[ch], ngrps, ctx->dexps[ch][0],
+            ff_ac3_decode_exponents(gb, ctx->expstr[ch], ngrps, ctx->dexps[ch][0],
                              &ctx->dexps[ch][ctx->startmant[ch]+!!ch]);
             if(ch != CPL_CH && ch != ctx->lfe_ch)
                 skip_bits(gb, 2); /* skip gainrng */
@@ -947,8 +918,8 @@
 
     /* bit allocation information */
     if (get_bits1(gb)) {
-        ctx->bit_alloc_params.sdecay = ff_sdecaytab[get_bits(gb, 2)] >> ctx->bit_alloc_params.halfratecod;
-        ctx->bit_alloc_params.fdecay = ff_fdecaytab[get_bits(gb, 2)] >> ctx->bit_alloc_params.halfratecod;
+        ctx->bit_alloc_params.sdecay = ff_sdecaytab[get_bits(gb, 2)];
+        ctx->bit_alloc_params.fdecay = ff_fdecaytab[get_bits(gb, 2)];
         ctx->bit_alloc_params.sgain  = ff_sgaintab[get_bits(gb, 2)];
         ctx->bit_alloc_params.dbknee = ff_dbkneetab[get_bits(gb, 2)];
         ctx->bit_alloc_params.floor  = ff_floortab[get_bits(gb, 3)];
@@ -1027,6 +998,7 @@
                                       ctx->startmant[ch], ctx->endmant[ch],
                                       ctx->snroffst[ch],
                                       ctx->bit_alloc_params.floor,
+                                      ff_ac3_baptab,
                                       ctx->bap[ch]);
         }
     }
@@ -1047,16 +1019,13 @@
 
     /* recover coefficients if rematrixing is in use */
     if(ctx->acmod == AC3_ACMOD_STEREO)
-        do_rematrixing(ctx);
+        ff_ac3_do_rematrixing(ctx->transform_coeffs,
+                FFMIN(ctx->endmant[1], ctx->endmant[2]),
+                ctx->nrematbnd, ctx->rematflg);
 
     /* apply scaling to coefficients (headroom, dialnorm, dynrng) */
     for(ch=1; ch<=ctx->nchans; ch++) {
         float gain = 2.0f * ctx->mul_bias;
-        if(ctx->acmod == AC3_ACMOD_DUALMONO) {
-            gain *= ctx->dialnorm[ch-1] * ctx->dynrng[ch-1];
-        } else {
-            gain *= ctx->dialnorm[0] * ctx->dynrng[0];
-        }
         for(i=0; i<ctx->endmant[ch]; i++) {
             ctx->transform_coeffs[ch][i] *= gain;
         }
@@ -1067,7 +1036,7 @@
     /* downmix output if needed */
     if(ctx->nchans != ctx->out_channels && !((ctx->output_mode & AC3_OUTPUT_LFEON) &&
             ctx->nfchans == ctx->out_channels)) {
-        ac3_downmix(ctx->output, ctx->nfchans, ctx->output_mode,
+        ff_ac3_downmix(ctx->output, ctx->nfchans, ctx->output_mode,
                     ctx->downmix_coeffs);
     }
 
@@ -1089,43 +1058,21 @@
 {
     AC3DecodeContext *ctx = (AC3DecodeContext *)avctx->priv_data;
     int16_t *out_samples = (int16_t *)data;
-    int i, blk, ch, err;
+    int i, blk, ch;
 
     /* initialize the GetBitContext with the start of valid AC-3 Frame */
     init_get_bits(&ctx->gb, buf, buf_size * 8);
 
     /* parse the syncinfo */
-    err = ac3_parse_header(ctx);
-    if(err) {
-        switch(err) {
-            case AC3_PARSE_ERROR_SYNC:
-                av_log(avctx, AV_LOG_ERROR, "frame sync error\n");
-                break;
-            case AC3_PARSE_ERROR_BSID:
-                av_log(avctx, AV_LOG_ERROR, "invalid bitstream id\n");
-                break;
-            case AC3_PARSE_ERROR_SAMPLE_RATE:
-                av_log(avctx, AV_LOG_ERROR, "invalid sample rate\n");
-                break;
-            case AC3_PARSE_ERROR_FRAME_SIZE:
-                av_log(avctx, AV_LOG_ERROR, "invalid frame size\n");
-                break;
-            default:
-                av_log(avctx, AV_LOG_ERROR, "invalid header\n");
-                break;
-        }
-        return -1;
+    if (ac3_parse_header(ctx)) {
+        av_log(avctx, AV_LOG_ERROR, "\n");
+        *data_size = 0;
+        return buf_size;
     }
 
     avctx->sample_rate = ctx->sampling_rate;
     avctx->bit_rate = ctx->bit_rate;
 
-    /* check that reported frame size fits in input buffer */
-    if(ctx->frame_size > buf_size) {
-        av_log(avctx, AV_LOG_ERROR, "incomplete frame\n");
-        return -1;
-    }
-
     /* channel config */
     ctx->out_channels = ctx->nchans;
     if (avctx->channels == 0) {
@@ -1152,11 +1099,89 @@
             av_log(avctx, AV_LOG_ERROR, "error parsing the audio block\n");
             *data_size = 0;
             return ctx->frame_size;
-        }
-        for (i = 0; i < 256; i++)
-            for (ch = 0; ch < ctx->out_channels; ch++)
-                *(out_samples++) = ctx->int_output[ch][i];
-    }
+       }
+       for (i = 0; i < 256; i++)
+           if (ctx->lfeon) {
+               switch (ctx->out_channels) {
+                   case 6:
+                       *(out_samples++) = ctx->int_output[0][i];   // FL
+                       *(out_samples++) = ctx->int_output[2][i];   // FR
+                       *(out_samples++) = ctx->int_output[1][i];   // FC
+                       *(out_samples++) = ctx->int_output[5][i];   // LFE
+                       *(out_samples++) = ctx->int_output[3][i];   // BL
+                       *(out_samples++) = ctx->int_output[4][i];   // BC
+                       break;
+                   case 5:
+                       if (ctx->acmod == 5) {
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[2][i];    // FR
+                           *(out_samples++) = ctx->int_output[1][i];    // FC
+                           *(out_samples++) = ctx->int_output[4][i];    // LFE
+                           *(out_samples++) = ctx->int_output[3][i];    // BC
+                       } else {                                    // acmod 6
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[1][i];    // FR
+                           *(out_samples++) = ctx->int_output[4][i];    // LFE
+                           *(out_samples++) = ctx->int_output[2][i];    // BL
+                           *(out_samples++) = ctx->int_output[3][i];    // BR
+                       }
+                       break;
+                  case 4:
+                       if (ctx->acmod == 3) {
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[2][i];    // FR
+                           *(out_samples++) = ctx->int_output[1][i];    // FC
+                           *(out_samples++) = ctx->int_output[3][i];    // LFE
+                       } else {                                    // acmod 4
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[1][i];    // FR
+                           *(out_samples++) = ctx->int_output[3][i];    // LFE
+                           *(out_samples++) = ctx->int_output[2][i];    // BC
+                       }
+                       break;
+                   default:
+                       for (ch = 0; ch < avctx->channels; ch++)
+                           *(out_samples++) = ctx->int_output[ch][i];
+               }
+           } else {
+               switch (ctx->out_channels) {
+                   case 5:
+                       *(out_samples++) = ctx->int_output[0][i];   // FL
+                       *(out_samples++) = ctx->int_output[2][i];   // FR
+                       *(out_samples++) = ctx->int_output[1][i];   // FC
+                       *(out_samples++) = ctx->int_output[3][i];   // BL
+                       *(out_samples++) = ctx->int_output[4][i];   // BC
+                       break;
+                   case 4:
+                       if (ctx->acmod == 5) {
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[2][i];    // FR
+                           *(out_samples++) = ctx->int_output[1][i];    // FC
+                            *(out_samples++) = ctx->int_output[3][i];    // BC
+                       } else {                                     // acmod 6
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[1][i];    // FR
+                           *(out_samples++) = ctx->int_output[2][i];    // BL
+                           *(out_samples++) = ctx->int_output[3][i];    // BR
+                       }
+                       break;
+                   case 3:
+                       if (ctx->acmod == 3) {
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[2][i];    // FR
+                           *(out_samples++) = ctx->int_output[1][i];    // FC
+                       } else {                                    // acmod 4
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[1][i];    // FR
+                           *(out_samples++) = ctx->int_output[2][i];    // BC
+                       }
+                       break;
+                   default:
+                       for (ch = 0; ch < ctx->out_channels; ch++)
+                           *(out_samples++) = ctx->int_output[ch][i];
+               }
+           }
+       }
     *data_size = NB_BLOCKS * 256 * avctx->channels * sizeof (int16_t);
     return ctx->frame_size;
 }
diff -ruN mplayer.orig/libavcodec/ac3dec.h mplayer.eac3/libavcodec/ac3dec.h
--- mplayer.orig/libavcodec/ac3dec.h	1970-01-01 03:00:00.000000000 +0300
+++ mplayer.eac3/libavcodec/ac3dec.h	2007-10-19 14:13:32.000000000 +0300
@@ -0,0 +1,103 @@
+/*
+ * Common code between AC3 encoder and decoder
+ * Copyright (c) 2000, 2001, 2002 Fabrice Bellard.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file ac3.h
+ * Common code between AC3 encoder and decoder.
+ */
+
+#ifndef AC3DEC_H
+#define AC3DEC_H
+
+#include "ac3tab.h"
+#include "bitstream.h"
+#include "random.h"
+
+#define CPL_CH 0
+
+void ff_ac3_window_init(float *window);
+void ff_ac3_tables_init(void);
+
+/** tables for ungrouping mantissas */
+extern float ff_ac3_b1_mantissas[32][3];
+extern float ff_ac3_b2_mantissas[128][3];
+extern float ff_ac3_b3_mantissas[8];
+extern float ff_ac3_b4_mantissas[128][2];
+extern float ff_ac3_b5_mantissas[16];
+
+/** dynamic range table. converts codes to scale factors. */
+extern float ff_ac3_dynrng_tbl[256];
+
+/** dialogue normalization table */
+extern float ff_ac3_dialnorm_tbl[32];
+
+/**
+ * table for exponent to scale_factor mapping
+ * ff_ac3_scale_factors[i] = 2 ^ -i
+ */
+extern float ff_ac3_scale_factors[25];
+
+/** table for grouping exponents */
+extern uint8_t ff_ac3_exp_ungroup_tbl[128][3];
+
+/**
+ * Decode the grouped exponents according to exponent strategy.
+ * reference: Section 7.1.3 Exponent Decoding
+ */
+void ff_ac3_decode_exponents(GetBitContext *gb, int expstr, int ngrps,
+                             uint8_t absexp, int8_t *dexps);
+
+/**
+ * Grouped mantissas for 3-level 5-level and 11-level quantization
+ */
+typedef struct {
+    float b1_mant[3];
+    float b2_mant[3];
+    float b4_mant[2];
+    int b1ptr;
+    int b2ptr;
+    int b4ptr;
+} mant_groups;
+
+int ff_ac3_get_transform_coeffs_ch(mant_groups *m, GetBitContext *gb, uint8_t *exps,
+        uint8_t *bap, float *coeffs, int start, int end, AVRandomState *dith_state);
+
+void ff_ac3_do_rematrixing(float (*transform_coeffs)[256], int end, int nrematbnd, int *rematflg);
+
+void ff_ac3_do_imdct_256(float *tmp_output, float *transform_coeffs,
+        MDCTContext *imdct_256, float *tmp_imdct);
+
+void ff_ac3_downmix(float samples[AC3_MAX_CHANNELS][256], int nfchans,
+                        int output_mode, float coef[AC3_MAX_CHANNELS][2]);
+
+/** Adjustments in dB gain */
+#define LEVEL_PLUS_3DB          1.4142135623730950
+#define LEVEL_PLUS_1POINT5DB    1.1892071150027209
+#define LEVEL_MINUS_1POINT5DB   0.8408964152537145
+#define LEVEL_MINUS_3DB         0.7071067811865476
+#define LEVEL_MINUS_4POINT5DB   0.5946035575013605
+#define LEVEL_MINUS_6DB         0.5000000000000000
+#define LEVEL_MINUS_9DB         0.3535533905932738
+#define LEVEL_ZERO              0.0000000000000000
+#define LEVEL_ONE               1.0000000000000000
+
+
+#endif /* AC3DEC_H */
diff -ruN mplayer.orig/libavcodec/ac3enc.c mplayer.eac3/libavcodec/ac3enc.c
--- mplayer.orig/libavcodec/ac3enc.c	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavcodec/ac3enc.c	2007-10-19 14:13:32.000000000 +0300
@@ -67,6 +67,7 @@
 static int16_t fft_rev[512];
 static int16_t xcos1[128];
 static int16_t xsin1[128];
+static int16_t ch_map[8] = { 0, 1, 2, 4, 5, 3, 6, 7};   // Remapping channels from uncompresed input
 
 #define MDCT_NBITS 9
 #define N         (1 << MDCT_NBITS)
@@ -479,7 +480,8 @@
         for(ch=0;ch<s->nb_all_channels;ch++) {
             ff_ac3_bit_alloc_calc_bap(mask[i][ch], psd[i][ch], 0,
                                       s->nb_coefs[ch], snroffset,
-                                      s->bit_alloc.floor, bap[i][ch]);
+                                      s->bit_alloc.floor, ff_ac3_baptab,
+                                      bap[i][ch]);
             frame_bits += compute_mantissa_size(s, bap[i][ch],
                                                  s->nb_coefs[ch]);
         }
@@ -644,6 +646,21 @@
     avctx->frame_size = AC3_FRAME_SIZE;
 
     ac3_common_init();
+    
+    /* Channel mapping limited to acmod_defs */
+   switch (channels) {
+       case 5:
+           ch_map[3] = 3;   // BLwav_3 -> BLac3_3
+           ch_map[4] = 4;   // BRwav_4 -> BRac3_4
+       case 3:
+       case 6:
+           ch_map[1] = 2;   // FRwav_1 -> FRac3_2
+           ch_map[2] = 1;   // FCwav_2 -> FCac3_1
+           break;
+       case 4:
+           ch_map[3] = 3;   // BCwav_3 -> BCac3_3
+           break;
+   }
 
     /* number of channels */
     if (channels < 1 || channels > 6)
@@ -1170,7 +1187,7 @@
             /* compute input samples */
             memcpy(input_samples, s->last_samples[ch], N/2 * sizeof(int16_t));
             sinc = s->nb_all_channels;
-            sptr = samples + (sinc * (N/2) * i) + ch;
+            sptr = samples + (sinc * (N/2) * i) + ch_map[ch];
             for(j=0;j<N/2;j++) {
                 v = *sptr;
                 input_samples[j + N/2] = v;
diff -ruN mplayer.orig/libavcodec/ac3.h mplayer.eac3/libavcodec/ac3.h
--- mplayer.orig/libavcodec/ac3.h	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavcodec/ac3.h	2007-10-19 14:13:32.000000000 +0300
@@ -161,10 +161,11 @@
  * @param[in]  end        ending bin location
  * @param[in]  snroffset  SNR adjustment
  * @param[in]  floor      noise floor
+ * @param[in]  baptab     bit allocation pointer table
  * @param[out] bap        bit allocation pointers
  */
 void ff_ac3_bit_alloc_calc_bap(int16_t *mask, int16_t *psd, int start, int end,
-                               int snroffset, int floor, uint8_t *bap);
+                               int snroffset, int floor, const uint8_t *baptab, uint8_t *bap);
 
 void ac3_parametric_bit_allocation(AC3BitAllocParameters *s, uint8_t *bap,
                                    int8_t *exp, int start, int end,
diff -ruN mplayer.orig/libavcodec/ac3_parser.c mplayer.eac3/libavcodec/ac3_parser.c
--- mplayer.orig/libavcodec/ac3_parser.c	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavcodec/ac3_parser.c	2007-10-19 14:13:32.000000000 +0300
@@ -84,7 +84,7 @@
     return 0;
 }
 
-static int ac3_sync(const uint8_t *buf, int *channels, int *sample_rate,
+static int ac3_sync(AVCodecContext *avctx, const uint8_t *buf, int *channels, int *sample_rate,
                     int *bit_rate, int *samples)
 {
     int err;
@@ -100,12 +100,16 @@
 
     bsid = hdr.bsid;
     if(bsid <= 10) {             /* Normal AC-3 */
+        if(avctx->codec_id == CODEC_ID_EAC3)
+            avctx->codec_id = CODEC_ID_AC3;
         *sample_rate = hdr.sample_rate;
         *bit_rate = hdr.bit_rate;
         *channels = hdr.channels;
         *samples = AC3_FRAME_SIZE;
         return hdr.frame_size;
     } else if (bsid > 10 && bsid <= 16) { /* Enhanced AC-3 */
+        if(avctx->codec_id == CODEC_ID_AC3)
+            avctx->codec_id = CODEC_ID_EAC3;
         init_get_bits(&bits, &buf[2], (AC3_HEADER_SIZE-2) * 8);
         strmtyp = get_bits(&bits, 2);
         substreamid = get_bits(&bits, 3);
@@ -155,6 +159,13 @@
     return 0;
 }
 
+AVCodecParser eac3_parser = {
+    { CODEC_ID_EAC3 },
+    sizeof(AACAC3ParseContext),
+    ac3_parse_init,
+    ff_aac_ac3_parse,
+    NULL,
+};
 
 AVCodecParser ac3_parser = {
     { CODEC_ID_AC3 },
diff -ruN mplayer.orig/libavcodec/ac3_parser.c.orig mplayer.eac3/libavcodec/ac3_parser.c.orig
--- mplayer.orig/libavcodec/ac3_parser.c.orig	1970-01-01 03:00:00.000000000 +0300
+++ mplayer.eac3/libavcodec/ac3_parser.c.orig	2007-10-19 14:13:18.000000000 +0300
@@ -0,0 +1,165 @@
+/*
+ * AC3 parser
+ * Copyright (c) 2003 Fabrice Bellard.
+ * Copyright (c) 2003 Michael Niedermayer.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "parser.h"
+#include "ac3_parser.h"
+#include "aac_ac3_parser.h"
+#include "bitstream.h"
+
+
+#define AC3_HEADER_SIZE 7
+
+
+static const uint8_t eac3_blocks[4] = {
+    1, 2, 3, 6
+};
+
+
+int ff_ac3_parse_header(const uint8_t buf[7], AC3HeaderInfo *hdr)
+{
+    GetBitContext gbc;
+
+    memset(hdr, 0, sizeof(*hdr));
+
+    init_get_bits(&gbc, buf, 54);
+
+    hdr->sync_word = get_bits(&gbc, 16);
+    if(hdr->sync_word != 0x0B77)
+        return AC3_PARSE_ERROR_SYNC;
+
+    /* read ahead to bsid to make sure this is AC-3, not E-AC-3 */
+    hdr->bsid = show_bits_long(&gbc, 29) & 0x1F;
+    if(hdr->bsid > 10)
+        return AC3_PARSE_ERROR_BSID;
+
+    hdr->crc1 = get_bits(&gbc, 16);
+    hdr->fscod = get_bits(&gbc, 2);
+    if(hdr->fscod == 3)
+        return AC3_PARSE_ERROR_SAMPLE_RATE;
+
+    hdr->frmsizecod = get_bits(&gbc, 6);
+    if(hdr->frmsizecod > 37)
+        return AC3_PARSE_ERROR_FRAME_SIZE;
+
+    skip_bits(&gbc, 5); // skip bsid, already got it
+
+    hdr->bsmod = get_bits(&gbc, 3);
+    hdr->acmod = get_bits(&gbc, 3);
+    if((hdr->acmod & 1) && hdr->acmod != AC3_ACMOD_MONO) {
+        hdr->cmixlev = get_bits(&gbc, 2);
+    }
+    if(hdr->acmod & 4) {
+        hdr->surmixlev = get_bits(&gbc, 2);
+    }
+    if(hdr->acmod == AC3_ACMOD_STEREO) {
+        hdr->dsurmod = get_bits(&gbc, 2);
+    }
+    hdr->lfeon = get_bits1(&gbc);
+
+    hdr->halfratecod = FFMAX(hdr->bsid, 8) - 8;
+    hdr->sample_rate = ff_ac3_freqs[hdr->fscod] >> hdr->halfratecod;
+    hdr->bit_rate = (ff_ac3_bitratetab[hdr->frmsizecod>>1] * 1000) >> hdr->halfratecod;
+    hdr->channels = ff_ac3_channels[hdr->acmod] + hdr->lfeon;
+    hdr->frame_size = ff_ac3_frame_sizes[hdr->frmsizecod][hdr->fscod] * 2;
+
+    return 0;
+}
+
+static int ac3_sync(const uint8_t *buf, int *channels, int *sample_rate,
+                    int *bit_rate, int *samples)
+{
+    int err;
+    unsigned int fscod, acmod, bsid, lfeon;
+    unsigned int strmtyp, substreamid, frmsiz, fscod2, numblkscod;
+    GetBitContext bits;
+    AC3HeaderInfo hdr;
+
+    err = ff_ac3_parse_header(buf, &hdr);
+
+    if(err < 0 && err != -2)
+        return 0;
+
+    bsid = hdr.bsid;
+    if(bsid <= 10) {             /* Normal AC-3 */
+        *sample_rate = hdr.sample_rate;
+        *bit_rate = hdr.bit_rate;
+        *channels = hdr.channels;
+        *samples = AC3_FRAME_SIZE;
+        return hdr.frame_size;
+    } else if (bsid > 10 && bsid <= 16) { /* Enhanced AC-3 */
+        init_get_bits(&bits, &buf[2], (AC3_HEADER_SIZE-2) * 8);
+        strmtyp = get_bits(&bits, 2);
+        substreamid = get_bits(&bits, 3);
+
+        if (strmtyp != 0 || substreamid != 0)
+            return 0;   /* Currently don't support additional streams */
+
+        frmsiz = get_bits(&bits, 11) + 1;
+        if(frmsiz*2 < AC3_HEADER_SIZE)
+            return 0;
+
+        fscod = get_bits(&bits, 2);
+        if (fscod == 3) {
+            fscod2 = get_bits(&bits, 2);
+            numblkscod = 3;
+
+            if(fscod2 == 3)
+                return 0;
+
+            *sample_rate = ff_ac3_freqs[fscod2] / 2;
+        } else {
+            numblkscod = get_bits(&bits, 2);
+
+            *sample_rate = ff_ac3_freqs[fscod];
+        }
+
+        acmod = get_bits(&bits, 3);
+        lfeon = get_bits1(&bits);
+
+        *samples = eac3_blocks[numblkscod] * 256;
+        *bit_rate = frmsiz * (*sample_rate) * 16 / (*samples);
+        *channels = ff_ac3_channels[acmod] + lfeon;
+
+        return frmsiz * 2;
+    }
+
+    /* Unsupported bitstream version */
+    return 0;
+}
+
+static int ac3_parse_init(AVCodecParserContext *s1)
+{
+    AACAC3ParseContext *s = s1->priv_data;
+    s->inbuf_ptr = s->inbuf;
+    s->header_size = AC3_HEADER_SIZE;
+    s->sync = ac3_sync;
+    return 0;
+}
+
+
+AVCodecParser ac3_parser = {
+    { CODEC_ID_AC3 },
+    sizeof(AACAC3ParseContext),
+    ac3_parse_init,
+    ff_aac_ac3_parse,
+    NULL,
+};
diff -ruN mplayer.orig/libavcodec/ac3tab.c mplayer.eac3/libavcodec/ac3tab.c
--- mplayer.orig/libavcodec/ac3tab.c	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavcodec/ac3tab.c	2007-10-19 14:13:32.000000000 +0300
@@ -25,6 +25,7 @@
  */
 
 #include "ac3tab.h"
+#include "ac3.h"
 
 /**
  * Possible frame sizes.
@@ -127,32 +128,32 @@
 };
 
 const uint8_t ff_ac3_latab[260]= {
-0x40,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,
-0x36,0x35,0x34,0x34,0x33,0x32,0x31,0x30,0x2f,0x2f,
-0x2e,0x2d,0x2c,0x2c,0x2b,0x2a,0x29,0x29,0x28,0x27,
-0x26,0x26,0x25,0x24,0x24,0x23,0x23,0x22,0x21,0x21,
-0x20,0x20,0x1f,0x1e,0x1e,0x1d,0x1d,0x1c,0x1c,0x1b,
-0x1b,0x1a,0x1a,0x19,0x19,0x18,0x18,0x17,0x17,0x16,
-0x16,0x15,0x15,0x15,0x14,0x14,0x13,0x13,0x13,0x12,
-0x12,0x12,0x11,0x11,0x11,0x10,0x10,0x10,0x0f,0x0f,
-0x0f,0x0e,0x0e,0x0e,0x0d,0x0d,0x0d,0x0d,0x0c,0x0c,
-0x0c,0x0c,0x0b,0x0b,0x0b,0x0b,0x0a,0x0a,0x0a,0x0a,
-0x0a,0x09,0x09,0x09,0x09,0x09,0x08,0x08,0x08,0x08,
-0x08,0x08,0x07,0x07,0x07,0x07,0x07,0x07,0x06,0x06,
-0x06,0x06,0x06,0x06,0x06,0x06,0x05,0x05,0x05,0x05,
-0x05,0x05,0x05,0x05,0x04,0x04,0x04,0x04,0x04,0x04,
-0x04,0x04,0x04,0x04,0x04,0x03,0x03,0x03,0x03,0x03,
-0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x02,
-0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
-0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x01,
-0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x0040,0x003f,0x003e,0x003d,0x003c,0x003b,0x003a,0x0039,0x0038,0x0037,
+0x0036,0x0035,0x0034,0x0034,0x0033,0x0032,0x0031,0x0030,0x002f,0x002f,
+0x002e,0x002d,0x002c,0x002c,0x002b,0x002a,0x0029,0x0029,0x0028,0x0027,
+0x0026,0x0026,0x0025,0x0024,0x0024,0x0023,0x0023,0x0022,0x0021,0x0021,
+0x0020,0x0020,0x001f,0x001e,0x001e,0x001d,0x001d,0x001c,0x001c,0x001b,
+0x001b,0x001a,0x001a,0x0019,0x0019,0x0018,0x0018,0x0017,0x0017,0x0016,
+0x0016,0x0015,0x0015,0x0015,0x0014,0x0014,0x0013,0x0013,0x0013,0x0012,
+0x0012,0x0012,0x0011,0x0011,0x0011,0x0010,0x0010,0x0010,0x000f,0x000f,
+0x000f,0x000e,0x000e,0x000e,0x000d,0x000d,0x000d,0x000d,0x000c,0x000c,
+0x000c,0x000c,0x000b,0x000b,0x000b,0x000b,0x000a,0x000a,0x000a,0x000a,
+0x000a,0x0009,0x0009,0x0009,0x0009,0x0009,0x0008,0x0008,0x0008,0x0008,
+0x0008,0x0008,0x0007,0x0007,0x0007,0x0007,0x0007,0x0007,0x0006,0x0006,
+0x0006,0x0006,0x0006,0x0006,0x0006,0x0006,0x0005,0x0005,0x0005,0x0005,
+0x0005,0x0005,0x0005,0x0005,0x0004,0x0004,0x0004,0x0004,0x0004,0x0004,
+0x0004,0x0004,0x0004,0x0004,0x0004,0x0003,0x0003,0x0003,0x0003,0x0003,
+0x0003,0x0003,0x0003,0x0003,0x0003,0x0003,0x0003,0x0003,0x0003,0x0002,
+0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,
+0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0001,0x0001,
+0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,
+0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,
+0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,
+0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
 };
 
 const uint16_t ff_ac3_hth[50][3]= {
@@ -208,6 +209,16 @@
 { 0x0840,0x0840,0x04e0 },
 };
 
+const uint8_t ff_ac3_hebaptab[64] = {
+    0, 1, 2, 3, 4, 5, 6, 7, 8, 8,
+    8, 8, 9, 9, 9, 10, 10, 10, 10, 11,
+    11, 11, 11, 12, 12, 12, 12, 13, 13, 13,
+    13, 14, 14, 14, 14, 15, 15, 15, 15, 16,
+    16, 16, 16, 17, 17, 17, 17, 18, 18, 18,
+    18, 18, 18, 18, 18, 19, 19, 19, 19, 19,
+    19, 19, 19, 19,
+};
+
 const uint8_t ff_ac3_baptab[64]= {
     0, 1, 1, 1, 1, 1, 2, 2, 3, 3,
     3, 4, 4, 5, 5, 6, 6, 6, 6, 7,
@@ -218,6 +229,11 @@
     15, 15, 15, 15,
 };
 
+const uint8_t ff_bits_vs_hebap[20] = {
+    0,  2,  3,  4,  5,  7,  8,  9,  3,  4,
+    5,  6,  7,  8,  9, 10, 11, 12, 14, 16,
+};
+
 const uint8_t ff_sdecaytab[4]={
     0x0f, 0x11, 0x13, 0x15,
 };
@@ -247,3 +263,1145 @@
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3,
     3, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 24, 24, 24, 24, 24
 };
+
+/**
+ * Quantization table: levels for symmetric. bits for asymmetric.
+ * reference: Table 7.18 Mapping of bap to Quantizer
+ */
+const uint8_t ff_qntztab[16] = {
+    0, 3, 5, 7, 11, 15,
+    5, 6, 7, 8, 9, 10, 11, 12, 14, 16
+};
+
+const uint8_t ff_eac3_blocks[4] = {
+    1, 2, 3, 6
+};
+
+const uint8_t ff_nfchans_tbl[8] = { 2, 1, 2, 3, 3, 4, 4, 5 };
+
+/**
+ * Table E3.6
+ * Large mantissa inverse quantization (remapping) constants
+ * ff_eac3_gaq_remap[hebap+8][x<0,x>=0][Gk=1,2,4][a,b]
+ */
+const int16_t ff_eac3_gaq_remap[12][2][3][2] = {
+{{{   4681,       0}, { -10923,   16384}, {  -4681,    8192}},
+ {{   4681,       0}, { -10923,   -5461}, {  -4681,   -1170}}},
+{{{   2185,       0}, { -14043,   16384}, {  -6554,    8192}},
+ {{   2185,       0}, { -14043,  -11703}, {  -6554,   -4915}}},
+{{{   1057,       0}, { -15292,   16384}, {  -7399,    8192}},
+ {{   1057,       0}, { -15292,  -14199}, {  -7399,   -6606}}},
+{{{    520,       0}, { -15855,   16384}, {  -7802,    8192}},
+ {{    520,       0}, { -15855,  -15327}, {  -7802,   -7412}}},
+{{{    258,       0}, { -16124,   16384}, {  -7998,    8192}},
+ {{    258,       0}, { -16124,  -15864}, {  -7998,   -7805}}},
+{{{    129,       0}, { -16255,   16384}, {  -8096,    8192}},
+ {{    129,       0}, { -16255,  -16126}, {  -8096,   -7999}}},
+{{{     64,       0}, { -16320,   16384}, {  -8144,    8192}},
+ {{     64,       0}, { -16320,  -16255}, {  -8144,   -8096}}},
+{{{     32,       0}, { -16352,   16384}, {  -8168,    8192}},
+ {{     32,       0}, { -16352,  -16320}, {  -8168,   -8144}}},
+{{{     16,       0}, { -16368,   16384}, {  -8180,    8192}},
+ {{     16,       0}, { -16368,  -16352}, {  -8180,   -8168}}},
+{{{      8,       0}, {      0,       0}, {      0,       0}},
+ {{      8,       0}, {      0,       0}, {      0,       0}}},
+{{{      2,       0}, {      0,       0}, {      0,       0}},
+ {{      2,       0}, {      0,       0}, {      0,       0}}},
+{{{      0,       0}, {      0,       0}, {      0,       0}},
+ {{      0,       0}, {      0,       0}, {      0,       0}}},
+};
+
+/**
+ * Map GAQ mode and gaqgain to Gk
+ * Gk = 1 << ff_gaq_gk[GAQ Mode][gaqgain]
+ */
+const uint8_t ff_gaq_gk[4][3]={
+    {0, 0, 0},
+    {0, 1, 0},
+    {0, 2, 0},
+    {0, 1, 2}
+};
+
+const int16_t ff_vq_hebap1[4][6] = {
+{   7167,    4739,    1106,    4269,   10412,    4820},
+{  -5702,   -3187,  -14483,   -1392,   -2027,     849},
+{    633,    6199,    7009,  -12779,   -2306,   -2636},
+{  -1468,   -7031,    7592,   10617,   -5946,   -3062},
+};
+const int16_t ff_vq_hebap2[8][6] = {
+{ -12073,     608,   -7019,     590,    4000,     869},
+{   6692,   15689,   -6178,   -9239,     -74,     133},
+{   1855,    -989,   20596,   -2920,   -4475,     225},
+{  -1194,   -3901,    -821,   -6566,    -875,  -20298},
+{  -2762,   -3181,   -4094,   -5623,  -16945,    9765},
+{   1547,    6839,    1980,   20233,   -1071,   -4986},
+{   6221,  -17915,   -5516,    6266,     358,    1162},
+{   3753,   -1066,    4283,   -3227,   15928,   10186},
+};
+const int16_t ff_vq_hebap3[16][6] = {
+{ -10028,   20779,   10982,   -4560,     798,     -68},
+{  11050,   20490,   -6617,   -5342,   -1797,   -1631},
+{   3977,    -542,    7118,   -1166,   18844,   14678},
+{  -4320,     -96,   -7295,    -492,  -22050,   -4277},
+{   2692,    5856,    5530,   21862,   -7212,   -5325},
+{   -135,  -23391,     962,    8115,    -644,     382},
+{  -1563,    3400,   -3299,    4693,   -6892,   22398},
+{   3535,    3030,    7296,    6214,   20476,  -12099},
+{     57,   -6823,    1848,  -22349,   -5919,    6823},
+{   -821,   -3655,    -387,   -6253,   -1735,  -22373},
+{  -6046,    1586,  -18890,  -14392,    9214,     705},
+{  -5716,     264,  -17964,   14618,    7921,    -337},
+{   -110,     108,       8,      74,     -89,     -50},
+{   6612,   -1517,   21687,   -1658,   -7949,    -246},
+{  21667,   -6335,   -8290,    -101,   -1349,     -22},
+{ -22003,   -6476,    7974,     648,    2054,    -331},
+};
+const int16_t ff_vq_hebap4[32][6] = {
+{   6636,   -4593,   14173,  -17297,  -16523,     864},
+{   3658,   22540,     104,   -1763,     -84,       6},
+{  21580,  -17815,   -7282,   -1575,   -2078,    -320},
+{  -2233,   10017,   -2728,   14938,  -13640,  -17659},
+{  -1564,  -17738,  -19161,   13735,    2757,    2951},
+{   4520,    5510,    7393,   10799,   19231,  -13770},
+{    399,    2976,   -1099,    5013,   -1159,   22095},
+{   3624,   -2359,    4680,   -2238,   22702,    3765},
+{  -4201,   -8285,   -6810,  -12390,  -18414,   15382},
+{  -5198,   -6869,  -10047,   -8364,  -16022,  -20562},
+{   -142,  -22671,    -368,    4391,    -464,     -13},
+{    814,   -1118,   -1089,  -22019,      74,    1553},
+{  -1618,   19222,  -17642,  -13490,     842,   -2309},
+{   4689,   16490,   20813,  -15387,   -4164,   -3968},
+{  -3308,   11214,  -13542,   13599,  -19473,   13770},
+{   1817,     854,   21225,    -966,   -1643,    -268},
+{  -2587,    -107,  -20154,     376,    1174,    -304},
+{  -2919,     453,   -5390,     750,  -22034,    -978},
+{ -19012,   16839,   10000,   -3580,    2211,    1459},
+{   1363,   -2658,     -33,   -4067,    1165,  -21985},
+{  -8592,   -2760,  -17520,  -15985,   14897,    1323},
+{    652,   -9331,    3253,  -14622,   12181,   19692},
+{  -6361,    5773,  -15395,   17291,   16590,   -2922},
+{   -661,    -601,    1609,   22610,     992,   -1045},
+{   4961,    9107,   11225,    7829,   16320,   18627},
+{ -21872,   -1433,     138,    1470,   -1891,    -196},
+{ -19499,  -18203,   11056,    -516,    2543,   -2249},
+{  -1196,  -17574,   20150,   11462,    -401,    2619},
+{   4638,   -8154,   11891,  -15759,   17615,  -14955},
+{    -83,     278,     323,      55,    -154,     232},
+{   7788,    1462,   18395,   15296,  -15763,   -1131},
+};
+const int16_t ff_vq_hebap5[128][6] = {
+{  -3394,  -19730,    2963,    9590,    4660,   19673},
+{ -15665,   -6405,   17671,    3860,   -8232,  -19429},
+{   4467,     412,  -17873,   -8037,     691,  -17307},
+{   3580,    2363,    6886,    3763,    6379,  -20522},
+{ -17230,  -14133,   -1396,  -23939,    8373,  -12537},
+{  -8073,  -21469,  -15638,    3214,    8105,   -5965},
+{   4343,    5169,    2683,  -16822,   -5146,  -16558},
+{   6348,  -10668,   12995,  -25500,  -22090,    4091},
+{  -2880,   -8366,   -5968,  -17158,   -2638,   23132},
+{  -5095,  -14281,  -22371,   21741,    3689,    2961},
+{  -2443,  -17739,   25155,    2707,    1594,       7},
+{ -18379,    9010,    4270,     731,    -426,    -640},
+{ -23695,   24732,    5642,     612,    -308,    -964},
+{   -767,    1268,     225,    1635,     173,     916},
+{   5455,    6493,    4902,   10560,   23041,  -17140},
+{  17219,  -21054,  -18716,    4936,   -3420,    3357},
+{  -1390,   15488,  -21946,  -14611,    1339,     542},
+{  -6866,   -2254,  -12070,   -3075,  -19981,  -20622},
+{  -1803,   11775,    1343,    8917,     693,   24497},
+{ -21610,    9462,    4681,    9254,   -7815,   15904},
+{  -5559,   -3018,   -9169,   -1347,  -22547,   12868},
+{   -366,    5076,   -1727,   20427,    -283,   -2923},
+{  -1886,   -6313,    -939,   -2081,   -1399,    3513},
+{  -3161,    -537,   -5075,   11268,   19396,     989},
+{   2345,    4153,    5769,   -4273,     233,    -399},
+{ -21894,   -1138,  -16474,    5902,    5488,   -3211},
+{  10007,  -12530,   18829,   20932,   -1158,    1790},
+{  -1165,    5014,   -1199,    6415,   -8418,  -21038},
+{   1892,   -3534,    3815,   -5846,   16427,   20288},
+{  -2664,  -11627,   -4147,  -18311,  -22710,   14848},
+{  17256,   10419,    7764,   12040,   18956,    2525},
+{ -21419,  -18685,  -10897,    4368,   -7051,    4539},
+{  -1574,    2050,    5760,   24756,   15983,   17678},
+{   -538,  -22867,   11067,   10301,     385,     528},
+{  -8465,   -3025,  -16357,  -23237,   16491,    3654},
+{   5840,     575,   11890,    1947,   25157,    6653},
+{   6625,   -3516,   -1964,    3850,    -390,    -116},
+{  18005,   20900,   14323,   -7621,  -10922,   11802},
+{  -4857,   -2932,  -13334,   -7815,   21622,    2267},
+{   -579,   -9431,    -748,  -21321,   12367,    8265},
+{  -8317,    1375,  -17847,    2921,    9062,   22046},
+{  18398,    8635,   -1503,   -2418,  -18295,  -14734},
+{  -2987,   15129,   -3331,   22300,   13878,  -13639},
+{   5874,  -19026,   15587,   11350,  -20738,    1971},
+{   1581,   -6955,  -21440,    2455,      65,     414},
+{    515,   -4468,    -665,   -4672,     125,  -19222},
+{  21495,  -20301,   -1872,   -1926,    -211,   -1022},
+{   5189,  -12250,   -1775,  -23550,   -4546,    5813},
+{    321,   -6331,   14646,    6975,   -1773,     867},
+{ -13814,    3180,    7927,     444,   19552,    3146},
+{  -6660,   12252,   -1972,   17408,  -24280,  -12956},
+{   -745,   14356,   -1107,   23742,   -9631,  -18344},
+{  18284,   -7909,   -7531,   19118,    7721,  -12659},
+{   1926,   15101,  -12848,    2153,   21631,    1864},
+{  -2130,   23416,   17056,  -15597,   -1544,      87},
+{   8314,  -11824,   14581,  -20591,    7891,   -2099},
+{  19600,   22814,  -17304,   -2040,     285,   -3863},
+{  -8214,  -18322,   10724,  -13744,  -13469,   -1666},
+{  14351,    4880,  -20034,     964,   -4221,    -180},
+{ -24598,  -16635,   19724,    5925,    4777,    4414},
+{  -2495,   23493,  -16141,    2918,   -1038,   -2010},
+{  18974,   -2540,   13343,    1405,   -6194,   -1136},
+{   2489,   13670,   22638,   -7311,    -129,   -2792},
+{ -13962,   16775,   23012,     728,    3397,     162},
+{   3038,     993,    8774,  -21969,   -6609,     910},
+{ -12444,  -22386,   -2626,   -5295,   19520,    9872},
+{  -1911,  -18274,  -18506,  -14962,    4760,    7119},
+{   8298,   -2978,   25886,    7660,   -7897,    1020},
+{   6132,   15127,   18757,  -24370,   -6529,   -6627},
+{   7924,   12125,   -9459,  -23962,    5502,     937},
+{ -17056,   -5373,    2522,     327,    1129,    -390},
+{  15774,   19955,  -10380,   11172,   -3107,   14853},
+{ -11904,   -8091,  -17928,  -22287,  -17237,   -6803},
+{ -12862,   -2172,   -6509,    5927,   12458,  -22355},
+{   -497,     322,    1038,   -6643,   -5404,   20311},
+{   1083,  -22984,   -8494,   12130,    -762,    2623},
+{   5067,   19712,   -1901,     -30,    -325,      85},
+{    987,   -5830,    4212,   -9030,    9121,  -25038},
+{  -7868,    7284,  -12292,   12914,  -21592,   20941},
+{  -1630,   -7694,   -2187,   -8525,   -5604,  -25196},
+{  -6668,     388,  -22535,    1526,    9082,     193},
+{  -7867,  -22308,    5163,     362,     944,    -259},
+{   3824,  -11850,    7591,  -23176,   25342,   23771},
+{ -10504,    4123,  -21111,   21173,   22439,    -838},
+{  -4723,   21795,    6184,    -122,    1642,    -717},
+{  24504,   19887,   -2043,     986,       7,     -55},
+{ -27313,    -135,    2437,     259,      89,     307},
+{  24446,   -3873,   -5391,    -820,   -2387,     361},
+{   5529,    5784,   18682,     242,  -21896,   -4003},
+{  22304,    4483,     722,  -12242,    7570,   15448},
+{   8673,    3009,   20437,   21108,  -21100,   -3080},
+{  -1132,    2705,   -1825,    5420,    -785,   18532},
+{  16932,  -13517,  -16509,  -14858,  -20327,  -14221},
+{   2219,    1380,   21474,   -1128,     327,      83},
+{  -2177,   21517,   -3856,  -14180,    -204,   -2191},
+{    953,   -9426,   15874,  -10710,   -3231,   21030},
+{   -421,   -1377,     640,   -8239,  -20976,    2174},
+{   4309,   18514,   -9100,  -18319,  -15518,    3704},
+{  -5943,     449,   -8387,    1075,  -22210,   -4992},
+{   2953,   12788,   18285,    1430,   14937,   21731},
+{  -2913,     401,   -4739,  -20105,    1699,   -1147},
+{   3449,    5241,    8853,   22134,   -7547,    1451},
+{  -2154,    8584,   18120,  -15614,   19319,   -5991},
+{   3501,    2841,    5897,    6397,    8630,   23018},
+{   2467,    2956,     379,    5703,  -22047,   -2189},
+{ -16963,    -594,   18822,   -5295,    1640,     774},
+{   2896,   -1424,    3586,   -2292,   19910,   -1822},
+{ -18575,   21219,  -14001,  -12573,   16466,     635},
+{  -1998,  -19314,  -16527,   12208,  -16576,   -7854},
+{  -9674,    1012,  -21645,    2883,  -12712,    2321},
+{  -1005,     471,   -3629,    8045,  -11087,   25533},
+{   4141,  -21472,   -2673,     756,    -663,    -523},
+{   6490,    8531,   19289,   18949,    6092,   -9347},
+{  16965,   24599,   14024,   10072,    -536,  -10438},
+{  -8147,    2145,  -23028,  -17073,    5451,   -4401},
+{ -14873,   20520,  -18303,   -9717,  -11885,  -17831},
+{  -2290,  -14120,    2070,   22467,    1671,     725},
+{  -8538,   14629,    3521,  -20577,    6673,    8200},
+{  20248,    4410,   -1366,    -585,    1229,   -2449},
+{   7467,   -7148,   13667,   -8246,   22392,  -17320},
+{  -1932,    3875,   -9064,   -3812,     958,     265},
+{  -4399,    2959,  -15911,   19598,    4954,   -1105},
+{  18009,   -9923,  -18137,   -3862,   11178,    5821},
+{ -14596,   -1227,    9660,   21619,   11228,  -11721},
+{   -721,   -1700,     109,   -2142,      61,   -6772},
+{ -24619,  -22520,    5608,   -1957,   -1761,   -1012},
+{ -23728,   -4451,   -2688,  -14679,   -4266,    9919},
+{   8495,    -894,   20438,  -13820,  -17267,     139},
+};
+const int16_t ff_vq_hebap6[256][6] = {
+{  10154,    7365,   16861,   18681,  -22893,   -3636},
+{  -2619,   -3788,   -5529,   -5192,   -9009,  -20298},
+{  -5583,  -22800,   21297,    7012,     745,     720},
+{    428,   -1459,     109,   -3082,     361,   -8403},
+{   8161,   22401,     241,    1755,    -874,   -2824},
+{   1140,   12643,    2306,   22263,  -25146,  -17557},
+{  -2609,    3379,   10337,  -19730,  -15468,  -23944},
+{  -4040,  -12796,  -25772,   13096,    3905,    1315},
+{   4624,  -23799,   13608,   25317,   -1175,    2173},
+{    -97,   13747,   -5122,   23255,    4214,  -22145},
+{   6878,    -322,   18264,    -854,  -11916,    -733},
+{  17280,  -12669,   -9693,   23563,  -16240,   -1309},
+{   5802,   -4968,   19526,  -21194,  -24622,    -183},
+{   5851,  -16137,   15229,   -9496,   -1538,     377},
+{  14096,   25057,   13419,    8290,   23320,   16818},
+{  -7261,     118,  -15867,   19097,    9781,    -277},
+{  -4288,   21589,  -13288,  -16259,   16633,   -4862},
+{   4909,  -19217,   23411,   14705,    -722,     125},
+{  19462,   -4732,   -1928,  -11527,   20770,    5425},
+{ -27562,   -2881,   -4331,     384,   -2103,    1367},
+{   -266,   -9175,    5441,   26333,   -1924,    4221},
+{  -2970,  -20170,  -21816,    5450,   -7426,    5344},
+{   -221,   -6696,     603,   -9140,    1308,  -27506},
+{   9621,   -8380,   -1967,    9403,   -1651,   22817},
+{   7566,   -5250,   -4165,    1385,    -990,     560},
+{  -1262,   24738,  -19057,   10741,    7585,   -7098},
+{    451,   20130,   -9949,   -6015,   -2188,   -1458},
+{  22249,    9380,    9096,   10959,   -2365,   -3724},
+{  18668,    -650,   -1234,   11092,    7678,    5969},
+{  19207,   -1485,   -1076,    -731,    -684,      43},
+{  -4973,   13430,   20139,      60,     476,    -935},
+{ -20029,    8710,    2499,    1016,   -1158,     335},
+{ -26413,   18598,   -2201,    -669,    3409,     793},
+{  -4726,    8875,  -24607,   -9646,    3643,    -283},
+{  13303,  -21404,   -3691,   -1184,   -1970,    1612},
+{    173,      60,     919,    1229,    6942,    -665},
+{  16377,   16991,    5341,  -14015,   -2304,  -20390},
+{  25334,  -10609,   11947,   -7653,   -6363,   14058},
+{  23929,  -13259,   -7226,    -937,     234,    -187},
+{   6311,   -1877,   12506,   -1879,   18751,  -23341},
+{    621,    6445,    3354,  -24274,    8406,    5315},
+{  -3297,   -5034,   -4704,   -5080,  -25730,    5347},
+{  -1275,  -13295,    -965,  -23318,    1214,   26259},
+{  -6252,   10035,  -20105,   15301,  -16073,    5136},
+{   9562,   -3911,  -19510,    4745,   22270,   -4171},
+{   7978,  -19600,   14024,   -5745,  -20855,    8939},
+{      7,   -4039,     991,   -6065,      52,  -19423},
+{   3485,    2969,    7732,    7786,   25312,    6206},
+{   -959,  -12812,   -1840,  -22743,    7324,   10830},
+{  -4686,    1678,  -10172,   -5205,    4294,   -1271},
+{   3889,    1302,    7450,     638,   20374,   -3133},
+{ -12496,   -9123,   18463,  -12343,   -7238,   18552},
+{  -6185,    8649,   -6903,    -895,   17109,   16604},
+{  -9896,   28579,    2845,    1640,    2925,    -298},
+{  14968,  -25988,   14878,  -24012,    1815,   -6474},
+{  26107,    5166,   21225,   15873,   21617,   14825},
+{ -21684,   16438,   20504,  -14346,   -7114,   -4162},
+{  28647,      90,   -1572,     789,    -902,     -75},
+{  -1479,    2471,   -4061,    3612,   -2240,   10914},
+{   8616,   17491,   17255,  -17456,   17022,  -16357},
+{ -20722,  -18597,   25274,   17720,   -3573,    1695},
+{   -997,    6129,   -6303,   11250,  -11359,  -19739},
+{    -74,   -4001,   -1584,   13384,     162,    -144},
+{   -529,   21068,    7923,  -11396,     422,     -26},
+{   7102,  -13531,  -20055,    2629,    -178,    -429},
+{   9201,    1368,  -22238,    2623,  -20499,   24889},
+{   -432,    6675,    -266,    8723,      80,   28024},
+{  19493,   -3108,   -9261,    1910,  -21777,    5345},
+{  14079,  -11489,   12604,    6079,   19877,    1315},
+{  10947,    9837,  -18612,   15742,    4792,     605},
+{  -1777,    3758,   -4087,   21696,    6024,    -576},
+{   3567,   -3578,   16379,    2680,   -1752,     716},
+{  -5049,   -1399,   -4550,    -652,  -17721,   -3366},
+{  -3635,   -4372,   -6522,  -22152,    7382,    1458},
+{  12242,   19190,    5646,   -7815,  -20289,   21344},
+{  -7508,   19952,   23542,   -9753,    5669,   -1990},
+{  -2275,   15438,   10907,  -17879,    6497,   13582},
+{ -15894,  -15646,   -4716,    6019,   24250,   -6179},
+{  -2049,   -6856,   -1208,     918,   17735,     -69},
+{  -3721,    9099,  -16065,  -23621,    5981,   -2344},
+{   7862,   -8918,   24033,   25508,  -11033,    -741},
+{ -12588,   19468,   14649,   15451,  -21226,    1171},
+{   2102,    1147,    2789,    4096,    2179,    8750},
+{ -18214,  -17758,  -10366,   -5203,   -1066,   -3541},
+{  -2819,  -19958,  -11921,    6032,    8315,   10374},
+{  -9078,   -2100,   19431,     -17,     732,    -689},
+{ -14512,  -19224,   -7095,   18727,    1870,   22906},
+{   3912,     659,   25597,   -4006,    9619,     877},
+{   2616,   22695,   -5770,   17920,    3812,   20220},
+{   2561,   26847,   -5245,  -10908,    2256,    -517},
+{  -4974,     198,  -21983,   -3608,   22174,  -18924},
+{  21308,   -1211,   19144,   16691,   -1588,   11390},
+{  -1790,    3959,   -3488,    7003,   -7107,   20877},
+{  -6108,  -17955,  -18722,   24763,   16508,    3211},
+{  20462,  -24987,  -20361,    4484,   -5111,    -478},
+{  -6378,   -1998,  -10229,    -561,  -22039,  -22339},
+{   3047,  -18850,    7586,   14743,  -19862,    6351},
+{  -5047,    1405,   -9672,    1055,  -21881,   11170},
+{   3481,   -9699,    6526,  -16655,   22813,   21907},
+{ -18570,   17501,   14664,    1291,    5026,   19676},
+{  16134,  -19810,  -16956,  -17939,  -16933,    5800},
+{  -8224,    4908,    8935,    2272,   -1140,  -23217},
+{   1572,    2753,   -1598,    2143,   -3346,  -21926},
+{  -9832,   -1060,  -27818,    1214,    7289,     150},
+{     98,    1538,     535,   17429,  -23198,    -901},
+{  21340,  -20146,    3297,   -1744,   -8207,  -21462},
+{  -4166,   -4633,  -17902,    5478,    1285,     136},
+{  18713,   21003,   24818,   11421,    1282,   -4618},
+{  -3535,    7636,    -265,    2141,    -829,   -2035},
+{  -3184,   19713,    2775,      -2,    1090,     104},
+{  -6771,  -20185,    2938,   -2125,     -36,    1268},
+{   9560,    9430,    9586,   22100,   13827,    6296},
+{   -535,  -20018,    4276,   -1868,    -448,  -17183},
+{ -24352,   14244,  -13647,  -21040,    2271,   11555},
+{  -2646,   15437,   -4589,   18638,   -4299,    -622},
+{ -20064,    4169,   18115,   -1404,   13722,   -1825},
+{ -16359,    9080,     744,   22021,     125,   10794},
+{   9644,  -14607,  -18479,  -14714,   11174,  -20754},
+{   -326,  -23762,    6144,    7909,     602,    1540},
+{  -6650,    6634,  -12683,   21396,   20785,   -6839},
+{   4252,  -21043,    5628,   18687,   23860,    8328},
+{  17986,    5704,   -5245,  -18093,    -555,    3219},
+{   6091,   14232,   -5117,  -17456,  -19452,  -11649},
+{ -21586,   11302,   15434,   25590,    6777,  -26683},
+{  21355,   -8244,    5877,   -3540,    6079,   -2567},
+{   2603,   -2455,    5421,  -12286,  -19100,    5574},
+{  -1721,  -26393,  -23664,   22904,    -349,    3787},
+{   2189,   -1203,    5340,    3249,  -22617,     104},
+{  -1664,  -11020,   -2857,  -20723,  -24049,   19900},
+{  22873,   -7345,  -18481,  -14616,   -8400,  -12965},
+{   3777,    3958,    8239,   20494,   -6991,   -1201},
+{   -160,   -1613,    -793,   -8681,     573,     776},
+{   4297,   -3786,   20373,    6082,   -5321,  -18400},
+{  18745,    2463,   12546,   -7749,   -7734,   -2183},
+{  11074,   -4720,   22119,    1825,  -24351,    4080},
+{   1503,  -19178,   -1569,      13,    -313,     375},
+{    318,    -575,    2544,     178,     102,      40},
+{ -15996,  -26897,    5008,    3320,     686,    1159},
+{  25755,   26886,     574,   -5930,   -3916,    1407},
+{  -9148,   -7665,   -2875,   -8384,  -18663,   26400},
+{  -7445,  -18040,  -18396,    8802,   -2252,  -21886},
+{   7851,   11773,   27485,  -12847,   -1410,   19590},
+{   2240,    5947,   11247,   15980,   -6499,   24280},
+{  21673,  -18515,    9771,    6550,   -2730,     334},
+{  -4149,    1576,  -11010,      89,  -24429,   -5710},
+{   7720,    1478,   21412,  -25025,   -8385,       9},
+{  -2448,   10218,  -12756,  -16079,    1161,  -21284},
+{  -8757,  -14429,  -22918,  -14812,    2629,   13844},
+{  -7252,    2843,   -9639,    2882,  -14625,   24497},
+{   -674,   -6530,     414,  -23333,  -21343,     454},
+{   2104,   -6312,   10887,   18087,   -1199,     175},
+{   -493,    -562,   -2739,     118,   -1074,      93},
+{ -10011,   -4075,  -28071,   22180,   15077,    -636},
+{  -4637,  -16408,   -9003,  -20418,  -11608,  -20932},
+{   4815,   15892,   24238,  -13634,   -3074,   -1059},
+{  -6724,    4610,  -18772,  -15283,  -16685,   23988},
+{  15349,    -674,   -3682,   21679,    4475,  -12088},
+{   4756,    2593,    5354,    6001,   15063,   26490},
+{ -23815,  -17251,    6944,     378,     694,     670},
+{  23392,   -8839,  -14713,    7544,    -876,   11088},
+{   3640,    3336,   22593,   -3495,   -2328,    -113},
+{    284,    6914,    3097,   10171,    6638,  -18621},
+{   2472,    5976,   11054,  -11936,    -603,    -663},
+{  16175,   16441,   13164,   -4043,    4667,    7431},
+{  19338,   15534,   -6533,    1681,   -4857,   17048},
+{  17027,     532,  -19064,   -1441,   -5130,    1085},
+{ -12617,  -17609,    2062,  -25332,   19009,  -16121},
+{  10056,  -21000,  -13634,   -2949,   15367,   19934},
+{   -648,   -1605,   10046,   -1592,   13296,   19808},
+{  -1054,   10744,     538,   24938,    9630,   -9052},
+{ -10099,    3042,  -25076,  -24052,   13971,     100},
+{   6547,    6907,    7031,   10348,   23775,  -17886},
+{ -22793,   -1984,   -1393,   -3330,    9267,   14317},
+{ -14346,   -3967,    3042,   16254,  -17303,    9646},
+{ -21393,   23628,   16773,     716,    2663,     114},
+{ -19016,   -3038,    1574,    -245,    1463,    -793},
+{  22410,   23441,  -14637,    -530,   17310,   13617},
+{ -11582,    7935,  -13954,   23465,  -24628,   26550},
+{  -1045,    3679,   -2218,   10572,   20999,   -3702},
+{ -15513,     197,   16718,  -24603,    4945,       5},
+{  10781,    4335,   26790,   -9059,  -16152,   -2840},
+{  16075,  -24100,   -3933,   -6833,   12645,   -7029},
+{   2096,  -25572,   -8370,    6814,      11,    1178},
+{ -11848,    -583,   -8889,  -20543,  -10471,    -380},
+{  -2487,   24777,  -21639,  -19341,    1660,    -732},
+{   2313,   13679,    4085,   24549,   24691,  -21179},
+{  -2366,    -504,   -4130,  -10570,   23668,    1961},
+{  20379,   17809,   -9506,    3733,  -18954,   -6292},
+{  -3856,   16802,    -929,  -20310,  -17739,    6797},
+{  12431,    6078,  -11272,  -14450,    6913,   23476},
+{   7636,   -1655,   23017,   10719,   -8292,     838},
+{  -8559,   -1235,  -18096,    3897,   16093,    1490},
+{  -3586,    8276,   15165,   -3791,  -21149,    1741},
+{  -4497,   21739,    2366,    -278,   -4792,   15549},
+{ -23122,  -13708,    7668,   16232,   24120,   15025},
+{ -20043,   12821,  -20160,   16691,  -11655,  -16081},
+{ -12601,   20239,    3496,   -2549,   -6745,  -11850},
+{   4441,    7812,   20783,   17080,   11523,   -9643},
+{  24766,    8494,  -23298,   -3262,   11101,   -7120},
+{ -10107,   -7623,  -22152,  -18303,   26645,    9550},
+{ -25549,     477,    7874,   -1538,    1123,    -168},
+{    470,    9834,    -347,   23945,  -10381,   -9467},
+{  -4096,   -9702,   -6856,  -21544,   20845,    7174},
+{   5370,    9748,  -23765,   -1190,     512,   -1538},
+{  -1006,  -10046,  -12649,   19234,   -1790,    -890},
+{  15108,   23620,  -15646,   -2522,   -1203,   -1325},
+{  -7406,   -2605,    1095,    -247,    -473,     177},
+{   8089,       4,   12424,  -22284,   10405,   -7728},
+{  22196,   10775,   -5043,     690,     534,    -212},
+{  -3153,   -1418,  -16835,   18426,   15821,   22956},
+{   5681,   -2229,    3196,   -3414,  -21817,  -14807},
+{     19,     787,    1032,     170,   -8295,    -645},
+{   -882,   -2319,  -27105,     432,   -4392,    1499},
+{  -1354,  -11819,     -76,  -20380,  -10293,   11328},
+{    211,   -4753,   -4675,   -6933,  -13538,   14479},
+{   6043,    5260,    -459,    -462,     143,     -65},
+{  -2572,    7256,   -3317,    9212,  -23184,   -9990},
+{ -24882,   -9532,   18874,    6101,    2429,  -14482},
+{   8314,    2277,   14192,    3512,   25881,   22000},
+{    208,   20218,    -281,  -24778,     -63,   -1183},
+{   1095,   -6034,    2706,  -21935,   -2655,     563},
+{     23,   -5930,     243,   -8989,    5345,   20558},
+{ -15466,   12699,    4160,   11087,   20621,  -10416},
+{  20995,     -85,   -8468,     194,    1003,   -9515},
+{ -19637,   -3335,  -14081,    3574,  -23381,    -667},
+{  -2076,    3489,   -3192,  -19367,     539,   -1530},
+{   7352,  -15213,   22596,   19369,    1043,   16627},
+{  -1872,    -413,    1235,   -5276,   -3550,   21903},
+{   7931,   -2008,   16968,   -6799,   29393,   -2475},
+{ -13589,    8389,  -23636,  -22091,  -14178,  -14297},
+{ -11575,  -20090,   16056,   -1848,   15721,    4500},
+{   3849,  -16581,   20161,  -21155,    7778,   11864},
+{  -6547,   -1273,  -18837,  -11218,   11636,    1044},
+{   2528,   -6691,  -17917,  -11362,   -4894,   -1008},
+{   1241,    4260,    2319,    6111,    3485,   20209},
+{   3014,   -3048,    5316,   -4539,   20831,    8702},
+{  -1790,  -14683,     278,   13956,  -10065,  -10547},
+{ -22732,   -7957,   -1154,   13821,   -1484,   -1247},
+{  -7317,    -615,   13094,   18927,    9897,    1452},
+{   2552,   -2338,    3424,   -4630,   11124,  -19584},
+{ -11125,  -20553,  -10855,  -10783,  -20767,    6833},
+{    984,  -15095,    5775,   25125,    5377,  -19799},
+{    517,   13272,   -7458,   -1711,   20612,   -6013},
+{ -21417,   13251,  -20795,   13449,   17281,   13104},
+{ -15811,  -16248,   23093,   -4037,   -8195,     871},
+{    582,   12571,  -21129,  -14766,   -9187,    5685},
+{   4318,   -1776,   11425,  -17763,   -9921,     577},
+{   6013,   16830,   17655,  -25766,   -4400,   -3550},
+{ -13744,  -16541,    3636,   -3330,  -21091,  -15886},
+{   6565,  -11147,    8649,  -13114,   23345,  -13565},
+{  -2542,   -9046,   -7558,   29240,    3701,    -383},
+{ -10612,   24995,    1893,   -8210,   20920,  -16210},
+{   5276,   16726,   10659,   19940,   -4799,  -19324},
+{   -532,   -9300,   27856,    4965,    -241,     536},
+{   -765,  -20706,   -3412,   18870,    2765,    1420},
+{  -3059,    2708,  -19022,    -331,    3537,     116},
+};
+const int16_t ff_vq_hebap7[512][6] = {
+{ -21173,   21893,   10390,   13646,   10718,   -9177},
+{ -22519,   -8193,   18328,   -6629,   25518,  -10848},
+{   6800,  -13758,  -13278,   22418,   14667,  -20938},
+{   2347,   10516,    1125,   -3455,    5569,   27136},
+{  -6617,   11851,  -24524,   22937,   20362,   -6019},
+{ -21768,   10681,  -19615,  -15021,   -8478,   -2081},
+{  -2745,    8684,   -4895,   27739,    7554,  -11961},
+{  -1020,    2460,    -954,    4754,    -627,  -16368},
+{ -19702,   23097,      75,  -13684,   -2644,    2108},
+{   4049,   -2872,    5851,   -4459,   22150,   12560},
+{ -21304,  -17129,    -730,    7419,  -11658,  -10523},
+{  11332,    1792,   26666,   23518,  -19561,    -491},
+{ -17827,  -16777,  -13606,  -14389,  -22029,   -2464},
+{   1091,   -5967,   -7975,  -16977,  -20432,  -21931},
+{  18388,   -1103,    1933,   13342,  -17463,   18114},
+{  22646,   17345,   -9966,   17919,   18274,     698},
+{   1484,   20297,   -5754,  -26515,    4941,  -22263},
+{  -2603,    4587,   -5842,   18464,    8767,   -2568},
+{  -2797,   -1602,   21713,    3099,  -25683,    3224},
+{ -19027,    4693,   -5007,    6060,    1972,  -15095},
+{  -2189,    9516,    -530,   20669,   -4662,   -8301},
+{ -22325,   -8887,    2529,  -11352,    5476,     998},
+{  22100,   -5052,    1651,   -2657,    4615,    2319},
+{  20855,   -3078,   -3330,    4105,   13470,    3069},
+{     85,   17289,   10264,  -14752,     214,      90},
+{ -26365,  -18849,  -19352,   19244,  -10218,    9909},
+{  -9739,   20497,   -6579,   -6983,    2891,    -738},
+{  20575,  -15860,  -22913,    6870,      76,     327},
+{   8744,  -12877,  -22945,   -2372,  -19424,   -9771},
+{ -12886,   16183,   21084,    3821,     749,  -13792},
+{ -15995,   18399,    2391,  -17661,   19484,   -6018},
+{   1423,   11734,    4051,   19290,    6857,  -19681},
+{  -5200,    9766,   18246,    2463,   18764,   -4852},
+{   -597,   19498,    1323,   -9096,    -308,   -1104},
+{  -3099,  -25731,  -15665,   25332,    4634,    2635},
+{  19623,   -2384,   -7913,   11796,   -9333,  -14084},
+{   2642,   26453,  -21091,  -10354,   -1693,   -1711},
+{  22031,   21625,   11580,  -22915,   -4141,     129},
+{  -6122,    3542,     915,    -261,     -17,    -383},
+{   1696,    6704,   -1425,   20838,     857,   -4416},
+{   1423,  -15280,   -8550,   -9667,    5210,    5687},
+{  -4520,    -613,  -11683,    5618,    4230,     619},
+{    937,   -4963,  -14102,  -17104,   -6906,   -5952},
+{ -15068,    -481,   -7237,  -14894,   18876,   21673},
+{ -25658,    2910,    1143,    -327,    -458,    -995},
+{  -9656,    -819,  -24900,    2804,   20225,    1083},
+{  -1111,   -3682,   -1788,  -19492,     966,     821},
+{   7293,  -21759,   10790,   -7059,  -23293,   -1723},
+{   -282,  -11093,     170,  -20950,  -28926,   12615},
+{  17938,    3713,   -1563,     885,       5,     564},
+{   6116,   22696,    2242,   -6951,    9975,   -6132},
+{   4338,   26808,   -3705,    1976,   -1079,   -2570},
+{   -661,   -7901,   -2668,  -15194,   17722,    4375},
+{  -4174,  -11053,     717,  -22506,    1562,   12252},
+{  -6405,   18334,    6103,    6983,    5956,   18195},
+{   9851,    5370,   23604,   -6861,   -6569,     -62},
+{  21964,   13359,    -683,    3785,    2168,     209},
+{  -3569,   -1127,  -19724,   -1544,    1308,    -803},
+{  -3083,   16049,  -13791,   -3077,    4294,   23713},
+{  -9999,    9943,  -15872,   12934,  -23631,   21699},
+{   9722,   22837,   12192,   15091,    5533,    4837},
+{   2243,    2099,    1243,    4089,    4748,   12956},
+{   4007,   -2468,    3353,   -3092,    8843,   17024},
+{   4330,    6127,    5549,    9249,   11226,   28592},
+{  -9586,   -8825,     236,    1009,     455,    -964},
+{   6829,   19290,   -1018,     200,    1821,     578},
+{   5196,     957,   10372,    3330,  -12800,    -127},
+{  -3022,   -8193,  -14557,   22061,    5920,    1053},
+{  10982,   25942,  -24546,  -23278,  -11905,   -6789},
+{  22667,  -11010,    5736,    2567,   23705,  -10253},
+{  -3343,   -4233,   -5458,   20667,  -10843,   -3605},
+{  -4131,   -3612,    4575,    -829,    -350,    -847},
+{  -3303,    3451,   -7398,  -11604,    3023,     455},
+{   3200,   -9547,    3202,  -22893,   11184,  -26466},
+{ -14093,   -4117,   15382,   14295,  -10915,  -20377},
+{   3807,  -11016,   22052,   14370,  -15328,   -7733},
+{  -6291,  -17719,   -1560,   12048,  -19805,    -443},
+{  -6147,   -4234,    -160,    8363,   22638,   11911},
+{  19197,    1175,    7422,   -9875,   -4136,    4704},
+{    -72,   -7652,    -112,  -11955,   -3230,   27175},
+{   3274,    5963,    7501,  -17019,     866,  -25452},
+{    737,    1861,    1833,    2022,    2384,    4755},
+{  -5217,    7512,    3323,    2715,    3065,   -1606},
+{   4247,     565,    5629,    2497,   18019,   -4920},
+{  -2833,  -17920,   -8062,   15738,   -1018,    2136},
+{   3050,  -19483,   16930,   29835,  -10222,   15153},
+{ -11346,     118,  -25796,  -13761,   15320,    -468},
+{  -4824,    4960,   -4263,    1575,  -10593,   19561},
+{  -8203,   -1409,    -763,   -1139,    -607,    1408},
+{  -2203,  -11415,    2021,   -6388,   -2600,     711},
+{   -413,   -2511,    -216,   -3519,  -28267,    1719},
+{ -14446,   17050,   13917,   13499,  -25762,  -16121},
+{  19228,    7341,  -12301,     682,   -3791,    -199},
+{  -4193,   20746,  -15651,   11349,    5860,    -824},
+{ -21490,   -3546,      -3,   -1705,   -3959,    9213},
+{  15445,   -1876,    2012,  -19627,   16228,   -4845},
+{  -2867,   -3733,   -7354,    -175,  -20119,   11174},
+{  -3571,  -24587,   19700,    6654,     979,    -654},
+{  21820,   -7430,   -6639,  -10767,   -8362,   15543},
+{  14827,   17977,   -7204,   -3409,    1906,  -17288},
+{   3525,   -3947,   -1415,   -2798,   17648,    2082},
+{  -6580,  -15255,  -17913,    1337,   15338,   21158},
+{   6210,    9698,   15155,  -24666,  -22507,   -3999},
+{  -1740,    -593,    1095,   -7779,   25058,    5601},
+{  21415,    -432,   -1658,   -6898,   -1438,  -14454},
+{  -6943,     700,  -12139,    -745,  -24187,   22466},
+{   6287,    3283,   11006,    3844,   19184,   14781},
+{ -22502,   15274,    5443,   -2808,    -970,   -3343},
+{   3257,   -3708,    4744,   -8301,   22814,  -10208},
+{  24346,  -20970,   19846,     987,  -11958,   -6277},
+{   3906,  -19701,   13060,   -1609,   18641,    7466},
+{ -26409,  -22549,   16305,    2014,   10975,   18032},
+{  -7039,    4655,  -14818,   18739,   15789,    1296},
+{   9310,   -1681,   14667,   -3326,   26535,  -11853},
+{   5728,    5917,   13400,   10020,   -2236,  -24704},
+{   1741,   -6727,   12695,  -22009,    4080,    5450},
+{  -2621,    9393,   21143,  -25938,   -3162,   -2529},
+{  20672,   18894,  -13939,    6990,   -8260,   15811},
+{ -23818,   11183,  -13639,   11868,   16045,    2630},
+{  18361,  -10220,     829,     856,   -1010,     157},
+{  14400,   -4678,    5153,  -13290,  -27434,  -11028},
+{  21613,   11256,   17453,    7604,   13130,    -484},
+{      7,    1236,     573,    4214,    5576,   -3081},
+{    916,   -9092,    1285,   -8958,    1185,  -28699},
+{  21587,   23695,   19116,   -2885,  -14282,   -8438},
+{  23414,   -6161,   12978,    3061,   -9351,    2236},
+{  -3070,   -7344,  -20140,    5788,     582,    -551},
+{  -3993,     315,   -7773,    8224,  -28082,  -12465},
+{  13766,  -15357,   19205,  -20624,   13043,  -19247},
+{   3777,    -177,    8029,   -1001,   17812,    5162},
+{  -7308,   -4327,  -18096,    -620,   -1350,   14932},
+{  14756,   -1221,  -12819,  -14922,    -547,   27125},
+{   2234,    1708,    2764,    5416,    7986,  -25163},
+{   2873,    3636,    3992,    5344,   10142,   21259},
+{   1158,    5379,     508,  -10514,     290,   -1615},
+{   1114,   24789,   16575,  -25168,    -298,   -2832},
+{  -1107,   -6144,   -1918,   -7791,   -2971,  -23276},
+{   4016,   10793,   17317,   -4342,  -20982,   -3383},
+{  -4494,    -207,   -9951,   -3575,    7947,    1154},
+{  -7576,    8117,  -14047,   16982,  -26457,  -27540},
+{ -15164,   16096,  -16844,   -8886,  -23720,   15906},
+{  24922,    5680,   -1874,     420,     132,     117},
+{   -506,  -19310,    -198,     412,    -311,     752},
+{  -1906,    3981,   -7688,   16566,  -19291,  -14722},
+{   -399,    -729,   -3807,   -4196,  -12395,    7639},
+{   3368,    2330,    9092,   23686,  -10290,   -1705},
+{  -3148,    2596,   -7986,   14602,   -4807,   16627},
+{   8057,    1481,      49,   17205,   24869,    7474},
+{ -19304,    -513,   11905,    2346,    5588,    3365},
+{  -5063,  -21812,   11370,   10896,    4881,     261},
+{   4794,   20577,    5109,   -6025,   -8049,   -1521},
+{   8125,  -14756,   20639,  -14918,   23941,   -3650},
+{  12451,    1381,    3613,    8687,  -24002,    4848},
+{   6726,   10643,   10086,   25217,  -25159,   -1065},
+{   6561,   13977,    2911,   21737,   16465,  -26050},
+{  -1776,    2575,  -19606,  -16800,    3032,    6679},
+{  15012,  -17910,   -8438,  -21554,  -27111,   11808},
+{   3448,    -924,  -15913,   -1135,    5126,  -20613},
+{   7720,    2226,   17463,    5434,   28942,   17552},
+{   1246,   15614,  -11743,   24618,  -17539,    3272},
+{   3215,   17950,    2783,    -722,  -22672,    5979},
+{  -5678,   -3184,  -26087,   26034,    6583,    3302},
+{  20310,   -3555,   -2715,    -444,   -1487,    1526},
+{ -20640,  -21970,  -12207,  -25793,    8863,   -1036},
+{  17888,     570,  -16102,    8329,   -2553,   15275},
+{  -2677,    9950,   -1879,   16477,  -12762,  -29007},
+{   -120,   -2221,     219,      97,     365,      35},
+{   1270,    -718,    1480,   -2689,    1930,   -7527},
+{   1896,    8750,    1906,   18235,  -12692,   -6174},
+{  -3733,   13713,   -9882,  -15960,   -1376,   -7146},
+{ -10600,    8496,   15967,   -8792,    7532,   20439},
+{   3041,  -13457,    1032,  -26952,    5787,   24984},
+{  -4590,   -8220,   -9322,   -6112,  -17243,   25745},
+{ -17808,    6970,    3752,     626,    -114,    2178},
+{   4449,   -4862,    7054,   -5404,    4738,   -2827},
+{   4922,    -651,   18939,   -9866,     848,    1886},
+{   -336,   -5410,    7234,   20444,   -9583,    -600},
+{    781,  -19474,  -12648,    6634,    1414,     450},
+{  -3399,  -16770,   11107,   13200,   -5498,   21663},
+{  -3265,    4859,   -5961,    7530,  -10837,   28086},
+{  10350,  -12901,   25699,   25640,    -639,     351},
+{   1163,   18763,   -5466,  -15087,    -145,   -1377},
+{ -14477,   27229,  -31383,  -32653,   21439,   -2894},
+{  15420,   18823,   22128,   19398,   22583,   13587},
+{ -10674,   10710,    5089,   -4756,     909,  -20760},
+{ -12948,  -20660,    7410,    2722,    3427,   11585},
+{  -1105,   18374,   19731,   -9650,   22442,   19634},
+{   -296,   -6798,  -14677,   21603,   19796,   21399},
+{ -19350,   -7501,   25446,   13144,    8588,  -25298},
+{   3092,  -10618,   20896,    9249,   -3326,    1796},
+{   -811,    1449,    3106,    4748,   12073,  -14262},
+{ -20720,   14275,   -4332,  -25838,   -5781,  -21149},
+{  -5132,   10554,  -14020,  -22150,    2840,    -554},
+{  25533,   17648,   14886,  -21074,    2459,   25142},
+{  -9370,   -1788,  -12862,   -5870,  -25811,  -11023},
+{   6698,     819,   10313,     166,   27581,     523},
+{    101,  -19388,    3413,    9638,      64,     806},
+{  -2742,  -17931,   -2576,   22818,    8553,    1126},
+{   2972,   15203,    1792,   25434,   -5728,  -17265},
+{  -1419,    1604,    4398,   11452,    1731,   23787},
+{  -5136,    4625,  -10653,   27981,    9897,   -2510},
+{ -10528,  -28033,    2999,   -1530,    -832,    -830},
+{ -11133,  -12511,   22206,   -7243,  -23578,  -21698},
+{  16935,  -21892,    1861,   -9606,    9432,   19026},
+{  10277,    9516,   26815,    2010,   -4943,   -9080},
+{   5547,   -2210,   14270,  -15300,  -19316,    1822},
+{  -4850,    -783,   -8959,   -3076,  -20056,   -3197},
+{   8232,   -2794,  -17752,   13308,    3229,    -991},
+{ -12237,   -6581,   10315,   -9552,    2260,  -20648},
+{  -7000,    5529,   -7553,   -7490,  -10342,  -10266},
+{   3641,   19479,   -5972,  -19097,  -18570,   12805},
+{   1283,   -4164,    4198,  -28473,   -2498,    1866},
+{  16047,   26826,  -13053,   -6316,     985,   -1597},
+{   -403,   13680,    6457,   25070,   27124,  -20710},
+{ -18070,   -1790,  -24986,    5953,    -954,   26600},
+{ -24224,  -15383,   24788,    1953,   -1136,     187},
+{  -2289,   12505,  -20738,    -904,   18324,   21258},
+{   2658,   -6140,   16179,   22276,    -556,    2154},
+{  -6087,   13950,  -25682,  -27713,    4049,   -4795},
+{ -21452,   26473,   19435,   -9124,     895,     303},
+{ -22200,  -26177,   -6026,   24729,  -22926,   -9030},
+{ -14276,  -15982,   23732,  -22851,    9268,   -3841},
+{  29482,   21923,   -6213,    1679,   -2059,   -1120},
+{   -435,    9802,   -3891,   12359,   -4288,  -18971},
+{  19768,     -86,    2467,    1990,   -1021,   -5354},
+{  20986,   -8783,   -5329,  -23562,   -4730,    2673},
+{  -5095,    5605,   -4629,   19150,   26037,  -12259},
+{    972,    6858,    4551,   27949,   -4025,   -2272},
+{   6075,   -3260,   -4989,    -373,   -1571,   -3730},
+{  -7256,  -12992,   -8820,   -5109,   23054,    5054},
+{    920,    2615,    7912,   -7353,   -4905,   20186},
+{   -250,    5454,    3140,    6928,  -18723,   -2051},
+{ -10299,   -4372,   19608,    4879,    -661,   -1885},
+{  14816,   -8603,  -19815,    6135,  -21210,   14108},
+{ -11945,   -2223,    5018,   11892,   22741,     406},
+{ -13184,   -2613,  -13256,  -22433,  -12482,   -8380},
+{  17066,   25267,   -2273,    5056,    -342,     145},
+{   8401,  -17683,   19112,   10615,  -19453,   17083},
+{  20821,   -5700,   12298,  -25598,   10391,    7692},
+{   4550,   15779,   17338,  -19379,   -4768,    1206},
+{  -7723,   10836,  -27164,  -11439,    6835,   -1776},
+{   2542,    3199,    4442,   17513,   -3711,    -914},
+{  20960,  -16774,   -5814,   11087,     -70,   22961},
+{   3305,    2919,    6256,   -4800,  -20966,   -3230},
+{   5924,  -16547,    2183,    2733,    3446,  -23306},
+{  -6061,    -194,  -13852,  -10971,   19488,    1029},
+{   4467,   -5964,  -19004,    1519,    -359,     855},
+{  -1581,   -7607,   22070,  -11580,  -10032,   17102},
+{ -12412,    2553,    4324,   22500,    5751,   12170},
+{ -25127,   17996,   -6384,    1180,    1182,    9622},
+{  23462,   -8471,   -4392,   -2669,    7638,  -16835},
+{  -5511,   -2887,  -10757,  -20883,    7246,    1053},
+{   2703,  -20602,   -7554,    7516,   -7740,    5868},
+{  20670,   21901,     457,   14969,  -17657,  -11921},
+{   3603,   -1595,   -2177,    -157,     -43,     605},
+{   2513,    8954,   10527,   22559,  -16100,  -16041},
+{   6002,    4951,    6795,   -4862,  -22400,   18849},
+{   7590,   -1693,  -24688,   -3404,   14169,    1214},
+{  -4398,   -6663,   -6870,  -10083,  -24596,    9253},
+{  10468,   17751,   -7748,     147,   -6314,    4419},
+{  16187,  -16557,   -4119,    4302,    7625,    5409},
+{   3303,    2735,    7458,  -19902,   -2254,   -3702},
+{  -2077,   21609,   14870,   12545,   -6081,   -1764},
+{   4678,   11740,    2859,    6953,    1919,   -3871},
+{   3522,  -21853,   -2469,  -10453,   18893,  -10742},
+{   3759,  -10191,   -4866,   -2659,  -17831,   -1242},
+{  14991,    9351,   11870,   -1573,   -4848,   22549},
+{   9509,  -27152,   10734,   20851,  -26185,  -17878},
+{  -7170,   -1392,  -19495,   12746,    8198,   -1988},
+{   1883,   28158,    -846,   -7235,     249,     233},
+{  -7200,     669,    -371,   -2948,   23234,   -5635},
+{   3141,     288,    3223,   -1258,     -98,  -27607},
+{  17373,  -23235,    5110,  -11199,   -2574,  -11487},
+{  -4928,    1518,   -5456,     670,  -18278,    1951},
+{  10334,  -19865,   -4649,     361,    -160,    -923},
+{  18732,   14264,   -3155,   -7485,   -3328,    5959},
+{  -3614,   21077,    7276,    3536,    8121,   -1528},
+{  -8422,     500,  -19182,   18929,   26392,   -1039},
+{  15639,   25668,    8375,    1903,    1945,  -11979},
+{  -2716,    3389,   26850,   -4587,    1803,      22},
+{   1177,    -655,    1233,   -2128,    7844,    1767},
+{   -761,    8209,  -19290,   -4593,    1923,    -343},
+{   -689,   -3530,   -3267,   -3804,   -2753,   18566},
+{  -2110,    1962,   -1353,   16643,    2765,  -23102},
+{   -433,    4905,     302,   13016,   15933,   -5905},
+{   3203,    4126,   11181,   -5496,   -2529,   -1160},
+{  -1091,   -6469,   -1415,    5682,    -268,     583},
+{  -9405,  -19572,    6216,    1658,     993,     -75},
+{  -1695,   -4504,   -2289,   -4088,   -6556,  -16577},
+{   4760,    -892,  -10902,    6516,   24199,   -6011},
+{   -253,    1000,      63,     -81,    -115,    -382},
+{  -1333,   24224,    -698,   -4667,   -2801,  -19144},
+{   -876,  -28866,  -21873,   12677,   -6344,    3235},
+{  16847,   21145,  -26172,   -3183,    -396,     230},
+{  18296,   -7790,  -12857,    -679,   -1473,       5},
+{ -10488,   11429,   25805,   -1122,    1401,    -438},
+{   3782,   -7429,   26720,   17567,   19257,   12542},
+{   6332,    -746,   12789,    9316,  -22542,   -5354},
+{   3418,  -22728,   26978,   18303,    1076,     956},
+{ -27315,   -2988,     920,     235,    2233,      81},
+{   6199,    5296,   16093,   14768,   -8429,   -1112},
+{  -6432,   19244,    9921,   -3253,    1278,    -954},
+{  24213,    2049,  -22931,    2585,   -2410,   -4216},
+{   9286,   14282,  -19735,   -3985,   -2344,    1028},
+{ -20128,   17993,   -9458,   23012,  -16983,    8625},
+{  -6896,  -20730,    3762,   17415,   22341,   19024},
+{    842,   24181,   25062,   -5839,     -78,     937},
+{   -621,   19722,  -24204,   -1962,  -14854,     -56},
+{  22766,   -5119,   17365,   23868,  -19480,   -6558},
+{  -2158,   17490,  -21435,    3340,  -12819,  -20295},
+{  -9621,   17325,     715,    2265,   -4123,    -492},
+{   9156,   12947,   27303,  -21175,   -6072,   -9457},
+{ -13164,  -23269,  -14006,   -4184,    6978,       2},
+{    938,  -13381,    3520,  -24297,   22902,   19589},
+{  -4911,  -19774,   19764,   -9310,  -12650,    3819},
+{  -5462,   -4249,   -6987,   -6260,  -13943,  -25150},
+{   9341,   10369,  -13862,   -6704,   22556,    -519},
+{   6651,   18768,   -4855,   12570,   14730,  -10209},
+{   -823,   18119,     398,   -1582,    -116,    -363},
+{  -6935,  -12694,  -28392,    8552,    6961,    -239},
+{  -2602,   -4704,   -1021,    2015,    5129,   23670},
+{ -12559,   -8190,  -25028,   18544,   14179,    1663},
+{   3813,   21036,   -9620,   -5051,   -1800,   -1087},
+{ -22057,   16675,   14960,    9459,    2786,   16991},
+{ -26040,  -19318,   -6414,    1104,    5798,  -18039},
+{  -1737,   24825,   10417,  -11087,     896,   -5273},
+{  -1855,   11661,   -2803,   24809,  -21435,  -19792},
+{ -23473,  -16729,   -5782,    5643,    2636,    4940},
+{  -1724,    4388,  -26673,  -13695,   10570,  -25895},
+{  15358,  -19496,   26242,  -18493,    1736,    8054},
+{   5684,   20890,    4091,  -19100,  -14588,  -10468},
+{  17260,  -16291,   14859,  -17711,  -19174,   12435},
+{ -27185,  -12573,    6743,    -562,     976,    -257},
+{  12395,   -8618,  -22248,  -19843,   11013,    7762},
+{   3799,   11853,  -27622,   -8473,    1089,   -1495},
+{   4141,   -2182,  -26720,    -735,    -774,    1469},
+{   3125,   13762,    4606,   29257,   18771,   -9958},
+{ -17465,   -9445,  -17562,   -2530,   -6435,   -3726},
+{  -1742,    4351,   -6841,  -19773,    9627,  -10654},
+{   7251,    3525,   10835,    5601,   25198,  -23348},
+{ -10300,  -17830,     631,   11640,    2044,  -20878},
+{   -873,   -8502,   -1063,  -15674,  -10693,   14934},
+{ -15957,   28137,    5268,     477,   -1053,    1158},
+{  -1495,   -8814,   -5764,  -24965,   25988,    7907},
+{  -1038,    -114,   -2308,   -1319,   -6480,    1472},
+{   4895,  -17897,  -25850,    5301,    -188,    1581},
+{   3200,   17225,    4346,   22101,  -18543,   22028},
+{ -10250,     545,  -10932,    2276,  -28070,    8118},
+{  15343,    2329,    9316,   20537,   14908,   21021},
+{   6329,    6130,  -24508,     837,   -8637,   -5844},
+{   7386,    -501,   10503,   20131,   11435,   -4755},
+{  -2745,   24174,   -9274,   15273,   -8389,   -5835},
+{   2992,   -2864,    6048,   -7473,   11687,  -19996},
+{   -883,  -11954,   -9976,  -21829,   -4436,  -27178},
+{   3458,   19626,    1280,    2597,   19849,    5255},
+{  -5315,   19133,  -14518,   -8946,   13749,   -1352},
+{  18642,   17655,   11001,    6817,  -18418,    6336},
+{  -1697,    2244,   -4640,    3948,  -12890,   -5273},
+{  20428,   10542,    4170,   -1012,   19439,   21691},
+{  -2943,  -19735,   -4208,    1320,     909,   -8897},
+{   9351,   -8066,   -2618,  -12933,   26582,    3507},
+{   9705,  -22628,    8311,    8167,  -13293,    5608},
+{   3222,    3749,   -1508,     165,     -52,    -196},
+{    102,  -22744,   -8832,     903,  -11421,  -14662},
+{   -120,    5998,   19765,   13401,    3628,    5197},
+{   8528,    5827,   -1066,     774,     -39,    -166},
+{   9411,   -9476,    9581,  -13004,   24456,   24900},
+{  17878,    2235,  -21639,   20478,    4716,   -7190},
+{  -2482,    9511,    1611,  -21943,   14230,   -1289},
+{   9288,   -2291,   23215,   -3452,  -10842,      11},
+{   9496,    3041,    5130,   -3890,  -21219,  -22589},
+{  14262,   -9838,   20195,   14019,      91,  -17200},
+{ -18591,     980,      17,     821,     120,    -574},
+{  12285,  -19269,   13742,   16373,    -161,    6025},
+{  -3364,    1530,   -4005,    2454,  -10872,  -23839},
+{    105,    5085,    -260,    5790,    -588,   19170},
+{   4121,    4169,   13439,   14644,   20899,    7434},
+{   -175,   13101,   -3704,   23233,    3907,   10106},
+{  -6101,   23467,    5204,   -1341,    1599,   13174},
+{  -3217,   -3494,   15117,   -8387,  -11762,   -4750},
+{   1146,    4675,  -19378,   14917,   -5091,     249},
+{ -21506,   10136,  -16473,  -13305,   18382,   -8601},
+{    628,    2447,    3344,    3130,   -5115,     119},
+{  17900,  -22422,  -17633,   21967,  -16293,   -7676},
+{  16863,   24214,    5612,   -3858,    -809,    3822},
+{  -2291,   10091,   -2360,  -25109,   -1226,     312},
+{   2957,   11256,   26745,  -13266,   -3455,   -1128},
+{ -19762,   -2708,    4604,    6355,    1638,   25501},
+{ -19593,   -7753,    3159,     -85,    -489,   -1855},
+{    814,   12510,   19077,   -4681,   -2610,   -1474},
+{ -23408,  -19027,    8137,   19878,    7912,    -282},
+{    839,  -19652,   11927,   27278,   -3211,    2266},
+{   4020,   -1110,    8226,   -1274,   20922,   25060},
+{  26576,     325,   -8693,    -232,   -2218,    -699},
+{ -11293,   -4200,    1805,   -6673,  -22940,   -1339},
+{  -2005,  -15886,   -1047,  -27687,  -13235,   14370},
+{ -22073,    1949,   13175,  -15656,   -1846,    8055},
+{   3039,   12025,    7132,  -24632,     413,   -2347},
+{ -24048,    -206,   12459,   -6654,    -417,  -10091},
+{  18179,  -23688,  -20515,  -16396,    7230,     763},
+{   5659,   -5085,   13878,  -23729,  -11077,  -19587},
+{  11340,     501,   25040,    7616,  -19658,    1605},
+{ -26650,    8878,   10544,     417,    1299,     261},
+{  14460,   11369,   -3263,    9990,    8194,   18111},
+{   1355,  -20838,   -9196,  -16060,   -8559,    -730},
+{  -1918,  -20937,  -18293,   -2461,   -2651,    4316},
+{  -2810,   24521,  -10996,  -25721,     308,   -1234},
+{  -9075,  -17280,   -1833,  -29342,  -24213,  -16631},
+{  -2843,   10165,   -5339,   -2888,   21858,  -21340},
+{ -15832,   14849,  -23780,    5184,   10113,  -20639},
+{ -19535,  -11361,    8413,    1486,  -23658,   -5759},
+{  -7512,    1027,  -20794,   13732,   19892,  -21934},
+{ -12132,   -7022,  -19175,   -8840,   22125,  -16490},
+{   1937,    5210,   -6318,  -23788,   13141,   11082},
+{   -205,    6036,    -380,    8658,    -233,   28020},
+{  -5523,    7477,    7635,   23595,    9763,   -2590},
+{  21658,  -28313,   -3086,    -300,   -1032,    1744},
+{ -22352,   16646,     208,    6665,  -17400,   -3028},
+{  18482,    9336,   -2737,  -19372,     407,   -4389},
+{  -4913,  -17370,   18819,  -17654,   13416,   15232},
+{   7749,    6368,   23135,  -18174,    7584,   -4248},
+{  -1489,   -6523,     586,  -10157,   14964,   25568},
+{   3844,   -6156,    4897,  -13045,  -22526,    5647},
+{  -8491,   -2105,  -24774,     905,   -9326,    1456},
+{  -3040,   -1476,    1166,   -4428,   11236,    9204},
+{   3397,   -1451,   13598,  -15841,   24540,    5819},
+{   8483,   -2993,   21547,  -16916,    7741,   24018},
+{ -14932,  -23758,   -5332,   -6664,   -4497,   13267},
+{  19379,   12916,   -2142,    -737,   21100,  -22101},
+{   3393,   -4629,    5735,  -18913,   -6969,    2687},
+{   1148,  -16147,  -21433,  -28095,    -630,  -14449},
+{   7300,     672,   18530,  -17452,  -10149,     351},
+{  11356,  -10974,   17212,    4624,     145,   17791},
+{   -711,   -3479,   -2238,   15887,    2027,       0},
+{ -28048,    1794,    -593,   -2758,  -21852,   11535},
+{ -19683,    4937,   22004,   21523,   -3148,    1790},
+{    813,    8231,    2633,   11981,   -3043,   22201},
+{   8952,  -24760,    -690,   14873,   -2366,   -5372},
+{   8406,   -5439,    -274,    -642,    -145,     778},
+{  -6605,    7258,   20780,  -23507,  -18625,   22782},
+{ -22896,  -25488,   10020,   -1614,    1508,   -1393},
+{   7607,     407,  -24678,  -16385,   -1804,   -4699},
+{ -10592,  -19139,   10462,   -3747,    8721,   -6919},
+{  13010,    5292,   -6230,   -4884,  -20904,   -1797},
+{  16891,  -13770,    -465,   19343,  -10741,  -12959},
+{  25193,  -14799,   -5681,    -521,    -321,   -1211},
+{   6917,   -3093,   20183,  -26903,  -12026,    1295},
+{    305,    1992,   19457,    -985,      25,    -521},
+{   6707,   -3698,    8365,   -8687,   21921,  -27166},
+{   4668,    5997,    7117,   11696,   24401,  -10794},
+{    744,   -9416,   19893,    1963,    7922,   -9824},
+{   3430,   21282,   -1736,   10844,    8821,   27015},
+{  -8813,    1521,  -24038,    1651,    7838,   -1208},
+{   3911,  -11221,    3273,  -12541,    7168,   18402},
+{  21642,    9117,  -11536,   -5256,    7077,    2382},
+{    100,    3817,   -6713,    1244,    1518,    -321},
+{   7946,  -18670,   10667,   -4866,     727,     776},
+{ -15883,   -8150,   -2087,   22739,    1567,   -3482},
+{   4380,   -2735,    8469,   -7025,  -11424,    1317},
+{  26970,    4393,    7665,   17561,    -714,     650},
+{ -16191,    -835,    8365,    1795,  -14314,   16297},
+{   4504,  -10048,    7662,  -26690,  -17428,    2580},
+{     48,   -3984,     564,   -5871,    2658,  -18658},
+{  12579,  -26016,  -15642,    2672,   -1347,    -887},
+{  -4950,    4208,   -6811,    2569,  -20621,   -8658},
+{  -1836,  -14818,   -5571,  -23322,  -14800,   25867},
+{   5434,  -28139,   -2357,   -2883,    -570,    2431},
+{  13096,   -2771,   24994,  -12496,  -24723,   -1025},
+{  -5676,   -4339,    1908,   18628,  -21323,   17366},
+{  27660,  -27897,  -15409,    1436,   -7112,   -2241},
+{   8019,    3847,   24568,    -469,    9674,   10683},
+{   -903,  -10149,    1801,  -21260,    4795,   -8751},
+{   1122,   -9582,    2625,   22791,     956,     882},
+{   7876,   19075,   -9900,  -24266,    7496,    9277},
+{    980,  -26764,   -5386,    5396,    1086,    1648},
+{  28838,   -1270,    -447,       5,    -429,     -20},
+{ -15283,    6132,   22812,    1252,   -9963,     511},
+{    851,    7925,    -457,  -12210,    4261,    7579},
+{  -4530,    8452,   -1246,   14501,  -24951,   -5760},
+{ -17814,  -10727,    9887,  -23929,  -13432,    1878},
+{ -15049,   10165,   16491,  -14603,  -11712,  -21156},
+{  -3317,     840,   -5683,   22413,    1994,     586},
+{  23158,   -5788,  -15043,  -10372,   -9271,  -13523},
+{   -773,   -9509,   -3993,  -24264,    8463,    5804},
+{  -8545,    -703,  -12440,   -3985,  -25122,  -28147},
+{ -16659,   16001,    2746,    1611,    5097,   -1043},
+{     41,   -7181,   19903,   31555,  -32237,   13927},
+{  -5658,     845,  -12774,    5705,   16695,     -86},
+{   5282,   14875,   27026,   21124,   15776,  -10477},
+{  14712,   19648,  -11487,  -13361,  -20196,  -15229},
+{   8597,   -9138,    -626,   10891,   -6015,    6346},
+{  -1488,   -1272,   -1479,   -1303,   -3704,   -5485},
+{  -3370,   17871,   -6604,   24930,   25886,   -3127},
+{   8416,   27783,   -1385,    5350,   -4260,   19993},
+{   5688,     362,   17246,    3809,   -3246,    1088},
+{   -105,  -29607,    2747,   15223,    -167,    3722},
+{   3502,   -3195,    8602,    7772,   -1566,    -915},
+{   -491,    3257,   -2423,    5522,   20606,    -100},
+{ -13948,  -11368,  -15375,  -21866,   -8520,   12221},
+{   -616,    2424,   -2023,    4398,   -3805,    8108},
+{  -7204,   21043,   21211,   -9395,  -19391,     896},
+{  -5737,  -15160,  -21298,   17066,   -1006,    -366},
+{   6261,    3240,  -11937,  -16213,  -15820,    6581},
+{  -3155,   24796,    2733,   -1257,    -875,   -1597},
+{ -20469,   11094,   24071,   -8987,   14136,    2220},
+{ -14106,   11959,  -22495,    4135,   -1055,   -5420},
+{    801,   -2655,      60,   -5324,    -790,    5937},
+{  -7372,   -1764,  -22433,  -26060,   21707,    4178},
+{  -5715,   -6648,  -14908,    1325,  -24044,    1493},
+{  -6024,  -12488,   23930,    2950,    1601,    1173},
+{  19067,   17630,   17929,  -10654,   10928,   -4958},
+{   3231,   -3284,   27336,    4174,   -1683,     497},
+};
+
+const int16_t (*ff_vq_hebap[8])[6] = {
+    NULL,
+    ff_vq_hebap1,
+    ff_vq_hebap2,
+    ff_vq_hebap3,
+    ff_vq_hebap4,
+    ff_vq_hebap5,
+    ff_vq_hebap6,
+    ff_vq_hebap7,
+};
+
+/**
+ * Table E2.14 Frame Exponent Strategy Combinations
+ */
+const uint8_t ff_eac3_frm_expstr[32][6] = {
+{    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,    EXP_D45},
+{    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,    EXP_D25,  EXP_REUSE},
+{    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,    EXP_D45,    EXP_D45},
+{    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D25,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D25,  EXP_REUSE,    EXP_D45},
+{    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D45,    EXP_D25,  EXP_REUSE},
+{    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D45,    EXP_D45,    EXP_D45},
+{    EXP_D25,  EXP_REUSE,    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D45},
+{    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE},
+{    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D45},
+{    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D25,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D45},
+{    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE},
+{    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D45},
+{    EXP_D45,    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D45,    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,    EXP_D45},
+{    EXP_D45,    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D25,  EXP_REUSE},
+{    EXP_D45,    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D45,    EXP_D45},
+{    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE,    EXP_D45},
+{    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D25,  EXP_REUSE},
+{    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D45,    EXP_D45},
+{    EXP_D45,    EXP_D45,    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D45},
+{    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE},
+{    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D45},
+{    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D45},
+{    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE},
+{    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D45},
+};
+
+/**
+ * Table E2.16 Default Coupling Banding Structure
+ */
+const uint8_t ff_eac3_defcplbndstrc[18] =
+{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1 };
+
+/**
+ * Table E2.15 Default Spectral Extension Banding Structure
+ */
+const uint8_t ff_eac3_defspxbndstrc[17] =
+{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1};
+
+/**
+ * Table E2.17 Default Enhanced Coupling Banding Structure
+ */
+
+const uint8_t ff_eac3_defecplbndstrc[22] =
+{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1};
+
+
+/**
+ * Table E3.14 Spectral Extension Attenuation Table
+ */
+const float ff_eac3_spxattentab[32][3] = {
+    {0.954841604, 0.911722489, 0.870550563},
+    {0.911722489, 0.831237896, 0.757858283},
+    {0.870550563, 0.757858283, 0.659753955},
+    {0.831237896, 0.690956440, 0.574349177},
+    {0.793700526, 0.629960525, 0.500000000},
+    {0.757858283, 0.574349177, 0.435275282},
+    {0.723634619, 0.523647061, 0.378929142},
+    {0.690956440, 0.477420802, 0.329876978},
+    {0.659753955, 0.435275282, 0.287174589},
+    {0.629960525, 0.396850263, 0.250000000},
+    {0.601512518, 0.361817309, 0.217637641},
+    {0.574349177, 0.329876978, 0.189464571},
+    {0.548412490, 0.300756259, 0.164938489},
+    {0.523647061, 0.274206245, 0.143587294},
+    {0.500000000, 0.250000000, 0.125000000},
+    {0.477420802, 0.227930622, 0.108818820},
+    {0.455861244, 0.207809474, 0.094732285},
+    {0.435275282, 0.189464571, 0.082469244},
+    {0.415618948, 0.172739110, 0.071793647},
+    {0.396850263, 0.157490131, 0.062500000},
+    {0.378929142, 0.143587294, 0.054409410},
+    {0.361817309, 0.130911765, 0.047366143},
+    {0.345478220, 0.119355200, 0.041234622},
+    {0.329876978, 0.108818820, 0.035896824},
+    {0.314980262, 0.099212566, 0.031250000},
+    {0.300756259, 0.090454327, 0.027204705},
+    {0.287174589, 0.082469244, 0.023683071},
+    {0.274206245, 0.075189065, 0.020617311},
+    {0.261823531, 0.068551561, 0.017948412},
+    {0.250000000, 0.062500000, 0.015625000},
+    {0.238710401, 0.056982656, 0.013602353},
+    {0.227930622, 0.051952369, 0.011841536}
+};
+
+/**
+ * Table of bin locations for rematrixing bands
+ * reference: Section 7.5.2 Rematrixing : Frequency Band Definitions
+ */
+const uint8_t ff_ac3_rematrix_band_tbl[5] = { 13, 25, 37, 61, 253 };
+
diff -ruN mplayer.orig/libavcodec/ac3tab.h mplayer.eac3/libavcodec/ac3tab.h
--- mplayer.orig/libavcodec/ac3tab.h	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavcodec/ac3tab.h	2007-10-19 14:13:32.000000000 +0300
@@ -31,6 +31,7 @@
 extern const int16_t  ff_ac3_window[256];
 extern const uint8_t  ff_ac3_latab[260];
 extern const uint16_t ff_ac3_hth[50][3];
+extern const uint8_t  ff_ac3_hebaptab[64];
 extern const uint8_t  ff_ac3_baptab[64];
 extern const uint8_t  ff_sdecaytab[4];
 extern const uint8_t  ff_fdecaytab[4];
@@ -39,5 +40,27 @@
 extern const int16_t  ff_floortab[8];
 extern const uint16_t ff_fgaintab[8];
 extern const uint8_t  ff_ac3_bndsz[50];
+extern const uint8_t  ff_qntztab[16];
+extern const uint8_t ff_nfchans_tbl[8];
+extern const uint8_t ff_eac3_blocks[4];
+extern const uint8_t ff_bits_vs_hebap[20];
+extern const int16_t ff_eac3_gaq_remap[12][2][3][2];
+extern const uint8_t ff_gaq_gk[4][3];
+
+extern const int16_t ff_vq_hebap1[4][6];
+extern const int16_t ff_vq_hebap2[8][6];
+extern const int16_t ff_vq_hebap3[16][6];
+extern const int16_t ff_vq_hebap4[32][6];
+extern const int16_t ff_vq_hebap5[128][6];
+extern const int16_t ff_vq_hebap6[256][6];
+extern const int16_t ff_vq_hebap7[512][6];
+extern const int16_t (*ff_vq_hebap[8])[6];
+extern const uint8_t ff_eac3_frm_expstr[32][6];
+extern const uint8_t ff_eac3_defcplbndstrc[18];
+extern const uint8_t ff_eac3_defspxbndstrc[17];
+extern const uint8_t ff_eac3_defecplbndstrc[22];
+extern const float   ff_eac3_spxattentab[32][3];
+
+extern const uint8_t ff_ac3_rematrix_band_tbl[5];
 
 #endif /* AC3TAB_H */
diff -ruN mplayer.orig/libavcodec/allcodecs.c mplayer.eac3/libavcodec/allcodecs.c
--- mplayer.orig/libavcodec/allcodecs.c	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavcodec/allcodecs.c	2007-10-19 14:13:32.000000000 +0300
@@ -179,6 +179,7 @@
     REGISTER_DECODER (COOK, cook);
     REGISTER_DECODER (DCA, dca);
     REGISTER_DECODER (DSICINAUDIO, dsicinaudio);
+    REGISTER_DECODER (EAC3, eac3);
     REGISTER_ENCDEC  (FLAC, flac);
     REGISTER_DECODER (IMC, imc);
     REGISTER_ENCDEC  (LIBAMR_NB, libamr_nb);
@@ -275,6 +276,7 @@
     REGISTER_PARSER  (DCA, dca);
     REGISTER_PARSER  (DVBSUB, dvbsub);
     REGISTER_PARSER  (DVDSUB, dvdsub);
+    REGISTER_PARSER  (EAC3, eac3);
     REGISTER_PARSER  (H261, h261);
     REGISTER_PARSER  (H263, h263);
     REGISTER_PARSER  (H264, h264);
diff -ruN mplayer.orig/libavcodec/allcodecs.c.orig mplayer.eac3/libavcodec/allcodecs.c.orig
--- mplayer.orig/libavcodec/allcodecs.c.orig	1970-01-01 03:00:00.000000000 +0300
+++ mplayer.eac3/libavcodec/allcodecs.c.orig	2007-10-19 14:13:18.000000000 +0300
@@ -0,0 +1,298 @@
+/*
+ * Provides registration of all codecs, parsers and bitstream filters for libavcodec.
+ * Copyright (c) 2002 Fabrice Bellard.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file allcodecs.c
+ * Provides registration of all codecs, parsers and bitstream filters for libavcodec.
+ */
+
+#include "avcodec.h"
+
+#define REGISTER_ENCODER(X,x) { \
+          extern AVCodec x##_encoder; \
+          if(ENABLE_##X##_ENCODER)  register_avcodec(&x##_encoder); }
+#define REGISTER_DECODER(X,x) { \
+          extern AVCodec x##_decoder; \
+          if(ENABLE_##X##_DECODER)  register_avcodec(&x##_decoder); }
+#define REGISTER_ENCDEC(X,x)  REGISTER_ENCODER(X,x); REGISTER_DECODER(X,x)
+
+#define REGISTER_PARSER(X,x) { \
+          extern AVCodecParser x##_parser; \
+          if(ENABLE_##X##_PARSER)  av_register_codec_parser(&x##_parser); }
+#define REGISTER_BSF(X,x) { \
+          extern AVBitStreamFilter x##_bsf; \
+          if(ENABLE_##X##_BSF)     av_register_bitstream_filter(&x##_bsf); }
+
+/**
+ * Register all the codecs, parsers and bitstream filters which were enabled at
+ * configuration time. If you do not call this function you can select exactly
+ * which formats you want to support, by using the individual registration
+ * functions.
+ *
+ * @see register_avcodec
+ * @see av_register_codec_parser
+ * @see av_register_bitstream_filter
+ */
+void avcodec_register_all(void)
+{
+    static int inited = 0;
+
+    if (inited != 0)
+        return;
+    inited = 1;
+
+    /* video codecs */
+    REGISTER_DECODER (AASC, aasc);
+    REGISTER_DECODER (AMV, amv);
+    REGISTER_ENCDEC  (ASV1, asv1);
+    REGISTER_ENCDEC  (ASV2, asv2);
+    REGISTER_DECODER (AVS, avs);
+    REGISTER_DECODER (BETHSOFTVID, bethsoftvid);
+    REGISTER_ENCDEC  (BMP, bmp);
+    REGISTER_DECODER (C93, c93);
+    REGISTER_DECODER (CAVS, cavs);
+    REGISTER_DECODER (CINEPAK, cinepak);
+    REGISTER_DECODER (CLJR, cljr);
+    REGISTER_DECODER (CSCD, cscd);
+    REGISTER_DECODER (CYUV, cyuv);
+    REGISTER_ENCDEC  (DNXHD, dnxhd);
+    REGISTER_DECODER (DSICINVIDEO, dsicinvideo);
+    REGISTER_ENCDEC  (DVVIDEO, dvvideo);
+    REGISTER_DECODER (DXA, dxa);
+    REGISTER_DECODER (EIGHTBPS, eightbps);
+    REGISTER_ENCDEC  (FFV1, ffv1);
+    REGISTER_ENCDEC  (FFVHUFF, ffvhuff);
+    REGISTER_ENCDEC  (FLASHSV, flashsv);
+    REGISTER_DECODER (FLIC, flic);
+    REGISTER_ENCDEC  (FLV, flv);
+    REGISTER_DECODER (FOURXM, fourxm);
+    REGISTER_DECODER (FRAPS, fraps);
+    REGISTER_ENCDEC  (GIF, gif);
+    REGISTER_ENCDEC  (H261, h261);
+    REGISTER_ENCDEC  (H263, h263);
+    REGISTER_DECODER (H263I, h263i);
+    REGISTER_ENCODER (H263P, h263p);
+    REGISTER_DECODER (H264, h264);
+    REGISTER_ENCDEC  (HUFFYUV, huffyuv);
+    REGISTER_DECODER (IDCIN, idcin);
+    REGISTER_DECODER (INDEO2, indeo2);
+    REGISTER_DECODER (INDEO3, indeo3);
+    REGISTER_DECODER (INTERPLAY_VIDEO, interplay_video);
+    REGISTER_ENCDEC  (JPEGLS, jpegls);
+    REGISTER_DECODER (KMVC, kmvc);
+    REGISTER_ENCODER (LIBX264, libx264);
+    REGISTER_ENCODER (LIBXVID, libxvid);
+    REGISTER_ENCODER (LJPEG, ljpeg);
+    REGISTER_DECODER (LOCO, loco);
+    REGISTER_DECODER (MDEC, mdec);
+    REGISTER_ENCDEC  (MJPEG, mjpeg);
+    REGISTER_DECODER (MJPEGB, mjpegb);
+    REGISTER_DECODER (MMVIDEO, mmvideo);
+    REGISTER_DECODER (MPEG_XVMC, mpeg_xvmc);
+    REGISTER_ENCDEC  (MPEG1VIDEO, mpeg1video);
+    REGISTER_ENCDEC  (MPEG2VIDEO, mpeg2video);
+    REGISTER_ENCDEC  (MPEG4, mpeg4);
+    REGISTER_DECODER (MPEGVIDEO, mpegvideo);
+    REGISTER_ENCDEC  (MSMPEG4V1, msmpeg4v1);
+    REGISTER_ENCDEC  (MSMPEG4V2, msmpeg4v2);
+    REGISTER_ENCDEC  (MSMPEG4V3, msmpeg4v3);
+    REGISTER_DECODER (MSRLE, msrle);
+    REGISTER_DECODER (MSVIDEO1, msvideo1);
+    REGISTER_DECODER (MSZH, mszh);
+    REGISTER_DECODER (NUV, nuv);
+    REGISTER_ENCODER (PAM, pam);
+    REGISTER_ENCODER (PBM, pbm);
+    REGISTER_ENCODER (PGM, pgm);
+    REGISTER_ENCODER (PGMYUV, pgmyuv);
+    REGISTER_ENCDEC  (PNG, png);
+    REGISTER_ENCODER (PPM, ppm);
+    REGISTER_DECODER (PTX, ptx);
+    REGISTER_DECODER (QDRAW, qdraw);
+    REGISTER_DECODER (QPEG, qpeg);
+    REGISTER_ENCDEC  (QTRLE, qtrle);
+    REGISTER_ENCDEC  (RAWVIDEO, rawvideo);
+    REGISTER_ENCDEC  (ROQ, roq);
+    REGISTER_DECODER (RPZA, rpza);
+    REGISTER_ENCDEC  (RV10, rv10);
+    REGISTER_ENCDEC  (RV20, rv20);
+    REGISTER_ENCDEC  (SGI, sgi);
+    REGISTER_DECODER (SMACKER, smacker);
+    REGISTER_DECODER (SMC, smc);
+    REGISTER_ENCDEC  (SNOW, snow);
+    REGISTER_DECODER (SP5X, sp5x);
+    REGISTER_ENCDEC  (SVQ1, svq1);
+    REGISTER_DECODER (SVQ3, svq3);
+    REGISTER_ENCDEC  (TARGA, targa);
+    REGISTER_DECODER (THEORA, theora);
+    REGISTER_DECODER (THP, thp);
+    REGISTER_DECODER (TIERTEXSEQVIDEO, tiertexseqvideo);
+    REGISTER_ENCDEC  (TIFF, tiff);
+    REGISTER_DECODER (TRUEMOTION1, truemotion1);
+    REGISTER_DECODER (TRUEMOTION2, truemotion2);
+    REGISTER_DECODER (TSCC, tscc);
+    REGISTER_DECODER (TXD, txd);
+    REGISTER_DECODER (ULTI, ulti);
+    REGISTER_DECODER (VC1, vc1);
+    REGISTER_DECODER (VCR1, vcr1);
+    REGISTER_DECODER (VMDVIDEO, vmdvideo);
+    REGISTER_DECODER (VMNC, vmnc);
+    REGISTER_DECODER (VP3, vp3);
+    REGISTER_DECODER (VP5, vp5);
+    REGISTER_DECODER (VP6, vp6);
+    REGISTER_DECODER (VP6A, vp6a);
+    REGISTER_DECODER (VP6F, vp6f);
+    REGISTER_DECODER (VQA, vqa);
+    REGISTER_ENCDEC  (WMV1, wmv1);
+    REGISTER_ENCDEC  (WMV2, wmv2);
+    REGISTER_DECODER (WMV3, wmv3);
+    REGISTER_DECODER (WNV1, wnv1);
+    REGISTER_DECODER (XAN_WC3, xan_wc3);
+    REGISTER_DECODER (XL, xl);
+    REGISTER_DECODER (XSUB, xsub);
+    REGISTER_ENCDEC  (ZLIB, zlib);
+    REGISTER_ENCDEC  (ZMBV, zmbv);
+
+    /* audio codecs */
+    REGISTER_DECODER (MPEG4AAC, mpeg4aac);
+    REGISTER_ENCDEC  (AC3, ac3);
+    REGISTER_DECODER (ALAC, alac);
+    REGISTER_DECODER (APE, ape);
+    REGISTER_DECODER (ATRAC3, atrac3);
+    REGISTER_DECODER (COOK, cook);
+    REGISTER_DECODER (DCA, dca);
+    REGISTER_DECODER (DSICINAUDIO, dsicinaudio);
+    REGISTER_ENCDEC  (FLAC, flac);
+    REGISTER_DECODER (IMC, imc);
+    REGISTER_ENCDEC  (LIBAMR_NB, libamr_nb);
+    REGISTER_ENCDEC  (LIBAMR_WB, libamr_wb);
+    REGISTER_DECODER (LIBA52, liba52);
+    REGISTER_ENCODER (LIBFAAC, libfaac);
+    REGISTER_DECODER (LIBFAAD, libfaad);
+    REGISTER_ENCDEC  (LIBGSM, libgsm);
+    REGISTER_ENCDEC  (LIBGSM_MS, libgsm_ms);
+    REGISTER_ENCODER (LIBMP3LAME, libmp3lame);
+    REGISTER_ENCODER (LIBTHEORA, libtheora);
+    if (!ENABLE_VORBIS_ENCODER)  REGISTER_ENCODER (LIBVORBIS, libvorbis);
+    if (!ENABLE_VORBIS_DECODER)  REGISTER_DECODER (LIBVORBIS, libvorbis);
+    REGISTER_DECODER (MACE3, mace3);
+    REGISTER_DECODER (MACE6, mace6);
+    REGISTER_ENCDEC  (MP2, mp2);
+    REGISTER_DECODER (MP3, mp3);
+    REGISTER_DECODER (MP3ADU, mp3adu);
+    REGISTER_DECODER (MP3ON4, mp3on4);
+    REGISTER_DECODER (MPC7, mpc7);
+    REGISTER_DECODER (NELLYMOSER, nellymoser);
+    REGISTER_DECODER (QDM2, qdm2);
+    REGISTER_DECODER (RA_144, ra_144);
+    REGISTER_DECODER (RA_288, ra_288);
+    REGISTER_DECODER (SHORTEN, shorten);
+    REGISTER_DECODER (SMACKAUD, smackaud);
+    REGISTER_ENCDEC  (SONIC, sonic);
+    REGISTER_ENCODER (SONIC_LS, sonic_ls);
+    REGISTER_DECODER (TRUESPEECH, truespeech);
+    REGISTER_DECODER (TTA, tta);
+    REGISTER_DECODER (VMDAUDIO, vmdaudio);
+    REGISTER_ENCDEC  (VORBIS, vorbis);
+    REGISTER_DECODER (WAVPACK, wavpack);
+    REGISTER_ENCDEC  (WMAV1, wmav1);
+    REGISTER_ENCDEC  (WMAV2, wmav2);
+    REGISTER_DECODER (WS_SND1, ws_snd1);
+
+    /* pcm codecs */
+    REGISTER_ENCDEC  (PCM_ALAW, pcm_alaw);
+    REGISTER_ENCDEC  (PCM_MULAW, pcm_mulaw);
+    REGISTER_ENCDEC  (PCM_S8, pcm_s8);
+    REGISTER_ENCDEC  (PCM_S16BE, pcm_s16be);
+    REGISTER_ENCDEC  (PCM_S16LE, pcm_s16le);
+    REGISTER_ENCDEC  (PCM_S24BE, pcm_s24be);
+    REGISTER_ENCDEC  (PCM_S24DAUD, pcm_s24daud);
+    REGISTER_ENCDEC  (PCM_S24LE, pcm_s24le);
+    REGISTER_ENCDEC  (PCM_S32BE, pcm_s32be);
+    REGISTER_ENCDEC  (PCM_S32LE, pcm_s32le);
+    REGISTER_ENCDEC  (PCM_U8, pcm_u8);
+    REGISTER_ENCDEC  (PCM_U16BE, pcm_u16be);
+    REGISTER_ENCDEC  (PCM_U16LE, pcm_u16le);
+    REGISTER_ENCDEC  (PCM_U24BE, pcm_u24be);
+    REGISTER_ENCDEC  (PCM_U24LE, pcm_u24le);
+    REGISTER_ENCDEC  (PCM_U32BE, pcm_u32be);
+    REGISTER_ENCDEC  (PCM_U32LE, pcm_u32le);
+    REGISTER_ENCDEC  (PCM_ZORK , pcm_zork);
+
+    /* dpcm codecs */
+    REGISTER_DECODER (INTERPLAY_DPCM, interplay_dpcm);
+    REGISTER_ENCDEC  (ROQ_DPCM, roq_dpcm);
+    REGISTER_DECODER (SOL_DPCM, sol_dpcm);
+    REGISTER_DECODER (XAN_DPCM, xan_dpcm);
+
+    /* adpcm codecs */
+    REGISTER_ENCDEC  (ADPCM_4XM, adpcm_4xm);
+    REGISTER_ENCDEC  (ADPCM_ADX, adpcm_adx);
+    REGISTER_ENCDEC  (ADPCM_CT, adpcm_ct);
+    REGISTER_ENCDEC  (ADPCM_EA, adpcm_ea);
+    REGISTER_ENCDEC  (ADPCM_G726, adpcm_g726);
+    REGISTER_DECODER (ADPCM_IMA_AMV, adpcm_ima_amv);
+    REGISTER_ENCDEC  (ADPCM_IMA_DK3, adpcm_ima_dk3);
+    REGISTER_ENCDEC  (ADPCM_IMA_DK4, adpcm_ima_dk4);
+    REGISTER_ENCDEC  (ADPCM_IMA_QT, adpcm_ima_qt);
+    REGISTER_ENCDEC  (ADPCM_IMA_SMJPEG, adpcm_ima_smjpeg);
+    REGISTER_ENCDEC  (ADPCM_IMA_WAV, adpcm_ima_wav);
+    REGISTER_ENCDEC  (ADPCM_IMA_WS, adpcm_ima_ws);
+    REGISTER_ENCDEC  (ADPCM_MS, adpcm_ms);
+    REGISTER_ENCDEC  (ADPCM_SBPRO_2, adpcm_sbpro_2);
+    REGISTER_ENCDEC  (ADPCM_SBPRO_3, adpcm_sbpro_3);
+    REGISTER_ENCDEC  (ADPCM_SBPRO_4, adpcm_sbpro_4);
+    REGISTER_ENCDEC  (ADPCM_SWF, adpcm_swf);
+    REGISTER_DECODER (ADPCM_THP, adpcm_thp);
+    REGISTER_ENCDEC  (ADPCM_XA, adpcm_xa);
+    REGISTER_ENCDEC  (ADPCM_YAMAHA, adpcm_yamaha);
+
+    /* subtitles */
+    REGISTER_ENCDEC  (DVBSUB, dvbsub);
+    REGISTER_ENCDEC  (DVDSUB, dvdsub);
+
+    /* parsers */
+    REGISTER_PARSER  (AAC, aac);
+    REGISTER_PARSER  (AC3, ac3);
+    REGISTER_PARSER  (CAVSVIDEO, cavsvideo);
+    REGISTER_PARSER  (DCA, dca);
+    REGISTER_PARSER  (DVBSUB, dvbsub);
+    REGISTER_PARSER  (DVDSUB, dvdsub);
+    REGISTER_PARSER  (H261, h261);
+    REGISTER_PARSER  (H263, h263);
+    REGISTER_PARSER  (H264, h264);
+    REGISTER_PARSER  (MJPEG, mjpeg);
+    REGISTER_PARSER  (MPEG4VIDEO, mpeg4video);
+    REGISTER_PARSER  (MPEGAUDIO, mpegaudio);
+    REGISTER_PARSER  (MPEGVIDEO, mpegvideo);
+    REGISTER_PARSER  (PNM, pnm);
+    REGISTER_PARSER  (VC1, vc1);
+
+    /* bitstream filters */
+    REGISTER_BSF     (DUMP_EXTRADATA, dump_extradata);
+    REGISTER_BSF     (H264_MP4TOANNEXB, h264_mp4toannexb);
+    REGISTER_BSF     (IMX_DUMP_HEADER, imx_dump_header);
+    REGISTER_BSF     (MJPEGA_DUMP_HEADER, mjpega_dump_header);
+    REGISTER_BSF     (MP3_HEADER_COMPRESS, mp3_header_compress);
+    REGISTER_BSF     (MP3_HEADER_DECOMPRESS, mp3_header_decompress);
+    REGISTER_BSF     (NOISE, noise);
+    REGISTER_BSF     (REMOVE_EXTRADATA, remove_extradata);
+}
+
diff -ruN mplayer.orig/libavcodec/avcodec.h mplayer.eac3/libavcodec/avcodec.h
--- mplayer.orig/libavcodec/avcodec.h	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavcodec/avcodec.h	2007-10-19 14:13:32.000000000 +0300
@@ -261,6 +261,7 @@
     CODEC_ID_MUSEPACK7,
     CODEC_ID_MLP,
     CODEC_ID_GSM_MS, /* as found in WAV */
+    CODEC_ID_EAC3,
     CODEC_ID_ATRAC3,
     CODEC_ID_VOXWARE,
     CODEC_ID_APE,
diff -ruN mplayer.orig/libavcodec/avcodec.h.orig mplayer.eac3/libavcodec/avcodec.h.orig
--- mplayer.orig/libavcodec/avcodec.h.orig	1970-01-01 03:00:00.000000000 +0300
+++ mplayer.eac3/libavcodec/avcodec.h.orig	2007-10-19 14:13:18.000000000 +0300
@@ -0,0 +1,2936 @@
+/*
+ * copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_H
+#define AVCODEC_H
+
+/**
+ * @file avcodec.h
+ * external API header
+ */
+
+
+#include "avutil.h"
+#include <sys/types.h> /* size_t */
+
+#define AV_STRINGIFY(s)         AV_TOSTRING(s)
+#define AV_TOSTRING(s) #s
+
+#define LIBAVCODEC_VERSION_INT  ((51<<16)+(46<<8)+0)
+#define LIBAVCODEC_VERSION      51.46.0
+#define LIBAVCODEC_BUILD        LIBAVCODEC_VERSION_INT
+
+#define LIBAVCODEC_IDENT        "Lavc" AV_STRINGIFY(LIBAVCODEC_VERSION)
+
+#define AV_NOPTS_VALUE          INT64_C(0x8000000000000000)
+#define AV_TIME_BASE            1000000
+#define AV_TIME_BASE_Q          (AVRational){1, AV_TIME_BASE}
+
+/**
+ * Identifies the syntax and semantics of the bitstream.
+ * The principle is roughly:
+ * Two decoders with the same ID can decode the same streams.
+ * Two encoders with the same ID can encode compatible streams.
+ * There may be slight deviations from the principle due to implementation
+ * details.
+ *
+ * If you add a codec ID to this list, add it so that
+ * 1. no value of a existing codec ID changes (that would break ABI),
+ * 2. it is as close as possible to similar codecs.
+ */
+enum CodecID {
+    CODEC_ID_NONE,
+    CODEC_ID_MPEG1VIDEO,
+    CODEC_ID_MPEG2VIDEO, /* preferred ID for MPEG-1/2 video decoding */
+    CODEC_ID_MPEG2VIDEO_XVMC,
+    CODEC_ID_H261,
+    CODEC_ID_H263,
+    CODEC_ID_RV10,
+    CODEC_ID_RV20,
+    CODEC_ID_MJPEG,
+    CODEC_ID_MJPEGB,
+    CODEC_ID_LJPEG,
+    CODEC_ID_SP5X,
+    CODEC_ID_JPEGLS,
+    CODEC_ID_MPEG4,
+    CODEC_ID_RAWVIDEO,
+    CODEC_ID_MSMPEG4V1,
+    CODEC_ID_MSMPEG4V2,
+    CODEC_ID_MSMPEG4V3,
+    CODEC_ID_WMV1,
+    CODEC_ID_WMV2,
+    CODEC_ID_H263P,
+    CODEC_ID_H263I,
+    CODEC_ID_FLV1,
+    CODEC_ID_SVQ1,
+    CODEC_ID_SVQ3,
+    CODEC_ID_DVVIDEO,
+    CODEC_ID_HUFFYUV,
+    CODEC_ID_CYUV,
+    CODEC_ID_H264,
+    CODEC_ID_INDEO3,
+    CODEC_ID_VP3,
+    CODEC_ID_THEORA,
+    CODEC_ID_ASV1,
+    CODEC_ID_ASV2,
+    CODEC_ID_FFV1,
+    CODEC_ID_4XM,
+    CODEC_ID_VCR1,
+    CODEC_ID_CLJR,
+    CODEC_ID_MDEC,
+    CODEC_ID_ROQ,
+    CODEC_ID_INTERPLAY_VIDEO,
+    CODEC_ID_XAN_WC3,
+    CODEC_ID_XAN_WC4,
+    CODEC_ID_RPZA,
+    CODEC_ID_CINEPAK,
+    CODEC_ID_WS_VQA,
+    CODEC_ID_MSRLE,
+    CODEC_ID_MSVIDEO1,
+    CODEC_ID_IDCIN,
+    CODEC_ID_8BPS,
+    CODEC_ID_SMC,
+    CODEC_ID_FLIC,
+    CODEC_ID_TRUEMOTION1,
+    CODEC_ID_VMDVIDEO,
+    CODEC_ID_MSZH,
+    CODEC_ID_ZLIB,
+    CODEC_ID_QTRLE,
+    CODEC_ID_SNOW,
+    CODEC_ID_TSCC,
+    CODEC_ID_ULTI,
+    CODEC_ID_QDRAW,
+    CODEC_ID_VIXL,
+    CODEC_ID_QPEG,
+    CODEC_ID_XVID,
+    CODEC_ID_PNG,
+    CODEC_ID_PPM,
+    CODEC_ID_PBM,
+    CODEC_ID_PGM,
+    CODEC_ID_PGMYUV,
+    CODEC_ID_PAM,
+    CODEC_ID_FFVHUFF,
+    CODEC_ID_RV30,
+    CODEC_ID_RV40,
+    CODEC_ID_VC1,
+    CODEC_ID_WMV3,
+    CODEC_ID_LOCO,
+    CODEC_ID_WNV1,
+    CODEC_ID_AASC,
+    CODEC_ID_INDEO2,
+    CODEC_ID_FRAPS,
+    CODEC_ID_TRUEMOTION2,
+    CODEC_ID_BMP,
+    CODEC_ID_CSCD,
+    CODEC_ID_MMVIDEO,
+    CODEC_ID_ZMBV,
+    CODEC_ID_AVS,
+    CODEC_ID_SMACKVIDEO,
+    CODEC_ID_NUV,
+    CODEC_ID_KMVC,
+    CODEC_ID_FLASHSV,
+    CODEC_ID_CAVS,
+    CODEC_ID_JPEG2000,
+    CODEC_ID_VMNC,
+    CODEC_ID_VP5,
+    CODEC_ID_VP6,
+    CODEC_ID_VP6F,
+    CODEC_ID_TARGA,
+    CODEC_ID_DSICINVIDEO,
+    CODEC_ID_TIERTEXSEQVIDEO,
+    CODEC_ID_TIFF,
+    CODEC_ID_GIF,
+    CODEC_ID_FFH264,
+    CODEC_ID_DXA,
+    CODEC_ID_DNXHD,
+    CODEC_ID_THP,
+    CODEC_ID_SGI,
+    CODEC_ID_C93,
+    CODEC_ID_BETHSOFTVID,
+    CODEC_ID_PTX,
+    CODEC_ID_TXD,
+    CODEC_ID_VP6A,
+    CODEC_ID_AMV,
+
+    /* various PCM "codecs" */
+    CODEC_ID_PCM_S16LE= 0x10000,
+    CODEC_ID_PCM_S16BE,
+    CODEC_ID_PCM_U16LE,
+    CODEC_ID_PCM_U16BE,
+    CODEC_ID_PCM_S8,
+    CODEC_ID_PCM_U8,
+    CODEC_ID_PCM_MULAW,
+    CODEC_ID_PCM_ALAW,
+    CODEC_ID_PCM_S32LE,
+    CODEC_ID_PCM_S32BE,
+    CODEC_ID_PCM_U32LE,
+    CODEC_ID_PCM_U32BE,
+    CODEC_ID_PCM_S24LE,
+    CODEC_ID_PCM_S24BE,
+    CODEC_ID_PCM_U24LE,
+    CODEC_ID_PCM_U24BE,
+    CODEC_ID_PCM_S24DAUD,
+    CODEC_ID_PCM_ZORK,
+
+    /* various ADPCM codecs */
+    CODEC_ID_ADPCM_IMA_QT= 0x11000,
+    CODEC_ID_ADPCM_IMA_WAV,
+    CODEC_ID_ADPCM_IMA_DK3,
+    CODEC_ID_ADPCM_IMA_DK4,
+    CODEC_ID_ADPCM_IMA_WS,
+    CODEC_ID_ADPCM_IMA_SMJPEG,
+    CODEC_ID_ADPCM_MS,
+    CODEC_ID_ADPCM_4XM,
+    CODEC_ID_ADPCM_XA,
+    CODEC_ID_ADPCM_ADX,
+    CODEC_ID_ADPCM_EA,
+    CODEC_ID_ADPCM_G726,
+    CODEC_ID_ADPCM_CT,
+    CODEC_ID_ADPCM_SWF,
+    CODEC_ID_ADPCM_YAMAHA,
+    CODEC_ID_ADPCM_SBPRO_4,
+    CODEC_ID_ADPCM_SBPRO_3,
+    CODEC_ID_ADPCM_SBPRO_2,
+    CODEC_ID_ADPCM_THP,
+    CODEC_ID_ADPCM_IMA_AMV,
+
+    /* AMR */
+    CODEC_ID_AMR_NB= 0x12000,
+    CODEC_ID_AMR_WB,
+
+    /* RealAudio codecs*/
+    CODEC_ID_RA_144= 0x13000,
+    CODEC_ID_RA_288,
+
+    /* various DPCM codecs */
+    CODEC_ID_ROQ_DPCM= 0x14000,
+    CODEC_ID_INTERPLAY_DPCM,
+    CODEC_ID_XAN_DPCM,
+    CODEC_ID_SOL_DPCM,
+
+    CODEC_ID_MP2= 0x15000,
+    CODEC_ID_MP3, /* preferred ID for decoding MPEG audio layer 1, 2 or 3 */
+    CODEC_ID_AAC,
+#if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
+    CODEC_ID_MPEG4AAC,
+#endif
+    CODEC_ID_AC3,
+    CODEC_ID_DTS,
+    CODEC_ID_VORBIS,
+    CODEC_ID_DVAUDIO,
+    CODEC_ID_WMAV1,
+    CODEC_ID_WMAV2,
+    CODEC_ID_MACE3,
+    CODEC_ID_MACE6,
+    CODEC_ID_VMDAUDIO,
+    CODEC_ID_SONIC,
+    CODEC_ID_SONIC_LS,
+    CODEC_ID_FLAC,
+    CODEC_ID_MP3ADU,
+    CODEC_ID_MP3ON4,
+    CODEC_ID_SHORTEN,
+    CODEC_ID_ALAC,
+    CODEC_ID_WESTWOOD_SND1,
+    CODEC_ID_GSM, /* as in Berlin toast format */
+    CODEC_ID_QDM2,
+    CODEC_ID_COOK,
+    CODEC_ID_TRUESPEECH,
+    CODEC_ID_TTA,
+    CODEC_ID_SMACKAUDIO,
+    CODEC_ID_QCELP,
+    CODEC_ID_WAVPACK,
+    CODEC_ID_DSICINAUDIO,
+    CODEC_ID_IMC,
+    CODEC_ID_MUSEPACK7,
+    CODEC_ID_MLP,
+    CODEC_ID_GSM_MS, /* as found in WAV */
+    CODEC_ID_ATRAC3,
+    CODEC_ID_VOXWARE,
+    CODEC_ID_APE,
+    CODEC_ID_NELLYMOSER,
+
+    /* subtitle codecs */
+    CODEC_ID_DVD_SUBTITLE= 0x17000,
+    CODEC_ID_DVB_SUBTITLE,
+    CODEC_ID_TEXT,  /* raw UTF-8 text */
+    CODEC_ID_XSUB,
+
+    CODEC_ID_MPEG2TS= 0x20000, /* _FAKE_ codec to indicate a raw MPEG-2 TS
+                                * stream (only used by libavformat) */
+};
+
+#if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
+/* CODEC_ID_MP3LAME is obsolete */
+#define CODEC_ID_MP3LAME CODEC_ID_MP3
+#define CODEC_ID_MPEG4AAC CODEC_ID_AAC
+#endif
+
+enum CodecType {
+    CODEC_TYPE_UNKNOWN = -1,
+    CODEC_TYPE_VIDEO,
+    CODEC_TYPE_AUDIO,
+    CODEC_TYPE_DATA,
+    CODEC_TYPE_SUBTITLE,
+    CODEC_TYPE_NB
+};
+
+/* Currently unused, may be used if 24/32 bits samples are ever supported. */
+/* all in native-endian format */
+enum SampleFormat {
+    SAMPLE_FMT_NONE = -1,
+    SAMPLE_FMT_U8,              ///< unsigned 8 bits
+    SAMPLE_FMT_S16,             ///< signed 16 bits
+    SAMPLE_FMT_S24,             ///< signed 24 bits
+    SAMPLE_FMT_S32,             ///< signed 32 bits
+    SAMPLE_FMT_FLT,             ///< float
+};
+
+/* in bytes */
+#define AVCODEC_MAX_AUDIO_FRAME_SIZE 192000 // 1 second of 48khz 32bit audio
+
+/**
+ * Required number of additionally allocated bytes at the end of the input bitstream for decoding.
+ * This is mainly needed because some optimized bitstream readers read
+ * 32 or 64 bit at once and could read over the end.<br>
+ * Note: If the first 23 bits of the additional bytes are not 0, then damaged
+ * MPEG bitstreams could cause overread and segfault.
+ */
+#define FF_INPUT_BUFFER_PADDING_SIZE 8
+
+/**
+ * minimum encoding buffer size
+ * Used to avoid some checks during header writing.
+ */
+#define FF_MIN_BUFFER_SIZE 16384
+
+/* motion estimation type, EPZS by default */
+enum Motion_Est_ID {
+    ME_ZERO = 1,
+    ME_FULL,
+    ME_LOG,
+    ME_PHODS,
+    ME_EPZS,
+    ME_X1,
+    ME_HEX,
+    ME_UMH,
+    ME_ITER,
+};
+
+enum AVDiscard{
+    /* We leave some space between them for extensions (drop some
+     * keyframes for intra-only or drop just some bidir frames). */
+    AVDISCARD_NONE   =-16, ///< discard nothing
+    AVDISCARD_DEFAULT=  0, ///< discard useless packets like 0 size packets in avi
+    AVDISCARD_NONREF =  8, ///< discard all non reference
+    AVDISCARD_BIDIR  = 16, ///< discard all bidirectional frames
+    AVDISCARD_NONKEY = 32, ///< discard all frames except keyframes
+    AVDISCARD_ALL    = 48, ///< discard all
+};
+
+typedef struct RcOverride{
+    int start_frame;
+    int end_frame;
+    int qscale; // If this is 0 then quality_factor will be used instead.
+    float quality_factor;
+} RcOverride;
+
+#define FF_MAX_B_FRAMES 16
+
+/* encoding support
+   These flags can be passed in AVCodecContext.flags before initialization.
+   Note: Not everything is supported yet.
+*/
+
+#define CODEC_FLAG_QSCALE 0x0002  ///< Use fixed qscale.
+#define CODEC_FLAG_4MV    0x0004  ///< 4 MV per MB allowed / advanced prediction for H.263.
+#define CODEC_FLAG_QPEL   0x0010  ///< Use qpel MC.
+#define CODEC_FLAG_GMC    0x0020  ///< Use GMC.
+#define CODEC_FLAG_MV0    0x0040  ///< Always try a MB with MV=<0,0>.
+#define CODEC_FLAG_PART   0x0080  ///< Use data partitioning.
+/* The parent program guarantees that the input for B-frames containing
+ * streams is not written to for at least s->max_b_frames+1 frames, if
+ * this is not set the input will be copied. */
+#define CODEC_FLAG_INPUT_PRESERVED 0x0100
+#define CODEC_FLAG_PASS1           0x0200   ///< Use internal 2pass ratecontrol in first pass mode.
+#define CODEC_FLAG_PASS2           0x0400   ///< Use internal 2pass ratecontrol in second pass mode.
+#define CODEC_FLAG_EXTERN_HUFF     0x1000   ///< Use external Huffman table (for MJPEG).
+#define CODEC_FLAG_GRAY            0x2000   ///< Only decode/encode grayscale.
+#define CODEC_FLAG_EMU_EDGE        0x4000   ///< Don't draw edges.
+#define CODEC_FLAG_PSNR            0x8000   ///< error[?] variables will be set during encoding.
+#define CODEC_FLAG_TRUNCATED       0x00010000 /** Input bitstream might be truncated at a random
+                                                  location instead of only at frame boundaries. */
+#define CODEC_FLAG_NORMALIZE_AQP  0x00020000 ///< Normalize adaptive quantization.
+#define CODEC_FLAG_INTERLACED_DCT 0x00040000 ///< Use interlaced DCT.
+#define CODEC_FLAG_LOW_DELAY      0x00080000 ///< Force low delay.
+#define CODEC_FLAG_ALT_SCAN       0x00100000 ///< Use alternate scan.
+#define CODEC_FLAG_TRELLIS_QUANT  0x00200000 ///< Use trellis quantization.
+#define CODEC_FLAG_GLOBAL_HEADER  0x00400000 ///< Place global headers in extradata instead of every keyframe.
+#define CODEC_FLAG_BITEXACT       0x00800000 ///< Use only bitexact stuff (except (I)DCT).
+/* Fx : Flag for h263+ extra options */
+#if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
+#define CODEC_FLAG_H263P_AIC      0x01000000 ///< H.263 advanced intra coding / MPEG-4 AC prediction (remove this)
+#endif
+#define CODEC_FLAG_AC_PRED        0x01000000 ///< H.263 advanced intra coding / MPEG-4 AC prediction
+#define CODEC_FLAG_H263P_UMV      0x02000000 ///< unlimited motion vector
+#define CODEC_FLAG_CBP_RD         0x04000000 ///< Use rate distortion optimization for cbp.
+#define CODEC_FLAG_QP_RD          0x08000000 ///< Use rate distortion optimization for qp selectioon.
+#define CODEC_FLAG_H263P_AIV      0x00000008 ///< H.263 alternative inter VLC
+#define CODEC_FLAG_OBMC           0x00000001 ///< OBMC
+#define CODEC_FLAG_LOOP_FILTER    0x00000800 ///< loop filter
+#define CODEC_FLAG_H263P_SLICE_STRUCT 0x10000000
+#define CODEC_FLAG_INTERLACED_ME  0x20000000 ///< interlaced motion estimation
+#define CODEC_FLAG_SVCD_SCAN_OFFSET 0x40000000 ///< Will reserve space for SVCD scan offset user data.
+#define CODEC_FLAG_CLOSED_GOP     ((int)0x80000000)
+#define CODEC_FLAG2_FAST          0x00000001 ///< Allow non spec compliant speedup tricks.
+#define CODEC_FLAG2_STRICT_GOP    0x00000002 ///< Strictly enforce GOP size.
+#define CODEC_FLAG2_NO_OUTPUT     0x00000004 ///< Skip bitstream encoding.
+#define CODEC_FLAG2_LOCAL_HEADER  0x00000008 ///< Place global headers at every keyframe instead of in extradata.
+#define CODEC_FLAG2_BPYRAMID      0x00000010 ///< H.264 allow B-frames to be used as references.
+#define CODEC_FLAG2_WPRED         0x00000020 ///< H.264 weighted biprediction for B-frames
+#define CODEC_FLAG2_MIXED_REFS    0x00000040 ///< H.264 one reference per partition, as opposed to one reference per macroblock
+#define CODEC_FLAG2_8X8DCT        0x00000080 ///< H.264 high profile 8x8 transform
+#define CODEC_FLAG2_FASTPSKIP     0x00000100 ///< H.264 fast pskip
+#define CODEC_FLAG2_AUD           0x00000200 ///< H.264 access unit delimiters
+#define CODEC_FLAG2_BRDO          0x00000400 ///< B-frame rate-distortion optimization
+#define CODEC_FLAG2_INTRA_VLC     0x00000800 ///< Use MPEG-2 intra VLC table.
+#define CODEC_FLAG2_MEMC_ONLY     0x00001000 ///< Only do ME/MC (I frames -> ref, P frame -> ME+MC).
+#define CODEC_FLAG2_DROP_FRAME_TIMECODE 0x00002000 ///< timecode is in drop frame format.
+#define CODEC_FLAG2_SKIP_RD       0x00004000 ///< RD optimal MB level residual skipping
+#define CODEC_FLAG2_CHUNKS        0x00008000 ///< Input bitstream might be truncated at a packet boundaries instead of only at frame boundaries.
+#define CODEC_FLAG2_NON_LINEAR_QUANT 0x00010000 ///< Use MPEG-2 nonlinear quantizer.
+
+/* Unsupported options :
+ *              Syntax Arithmetic coding (SAC)
+ *              Reference Picture Selection
+ *              Independent Segment Decoding */
+/* /Fx */
+/* codec capabilities */
+
+#define CODEC_CAP_DRAW_HORIZ_BAND 0x0001 ///< Decoder can use draw_horiz_band callback.
+/**
+ * Codec uses get_buffer() for allocating buffers.
+ * direct rendering method 1
+ */
+#define CODEC_CAP_DR1             0x0002
+/* If 'parse_only' field is true, then avcodec_parse_frame() can be used. */
+#define CODEC_CAP_PARSE_ONLY      0x0004
+#define CODEC_CAP_TRUNCATED       0x0008
+/* Codec can export data for HW decoding (XvMC). */
+#define CODEC_CAP_HWACCEL         0x0010
+/**
+ * Codec has a nonzero delay and needs to be fed with NULL at the end to get the delayed data.
+ * If this is not set, the codec is guaranteed to never be fed with NULL data.
+ */
+#define CODEC_CAP_DELAY           0x0020
+/**
+ * Codec can be fed a final frame with a smaller size.
+ * This can be used to prevent truncation of the last audio samples.
+ */
+#define CODEC_CAP_SMALL_LAST_FRAME 0x0040
+
+//The following defines may change, don't expect compatibility if you use them.
+#define MB_TYPE_INTRA4x4   0x0001
+#define MB_TYPE_INTRA16x16 0x0002 //FIXME H.264-specific
+#define MB_TYPE_INTRA_PCM  0x0004 //FIXME H.264-specific
+#define MB_TYPE_16x16      0x0008
+#define MB_TYPE_16x8       0x0010
+#define MB_TYPE_8x16       0x0020
+#define MB_TYPE_8x8        0x0040
+#define MB_TYPE_INTERLACED 0x0080
+#define MB_TYPE_DIRECT2    0x0100 //FIXME
+#define MB_TYPE_ACPRED     0x0200
+#define MB_TYPE_GMC        0x0400
+#define MB_TYPE_SKIP       0x0800
+#define MB_TYPE_P0L0       0x1000
+#define MB_TYPE_P1L0       0x2000
+#define MB_TYPE_P0L1       0x4000
+#define MB_TYPE_P1L1       0x8000
+#define MB_TYPE_L0         (MB_TYPE_P0L0 | MB_TYPE_P1L0)
+#define MB_TYPE_L1         (MB_TYPE_P0L1 | MB_TYPE_P1L1)
+#define MB_TYPE_L0L1       (MB_TYPE_L0   | MB_TYPE_L1)
+#define MB_TYPE_QUANT      0x00010000
+#define MB_TYPE_CBP        0x00020000
+//Note bits 24-31 are reserved for codec specific use (h264 ref0, mpeg1 0mv, ...)
+
+/**
+ * Pan Scan area.
+ * This specifies the area which should be displayed.
+ * Note there may be multiple such areas for one frame.
+ */
+typedef struct AVPanScan{
+    /**
+     * id
+     * - encoding: Set by user.
+     * - decoding: Set by libavcodec.
+     */
+    int id;
+
+    /**
+     * width and height in 1/16 pel
+     * - encoding: Set by user.
+     * - decoding: Set by libavcodec.
+     */
+    int width;
+    int height;
+
+    /**
+     * position of the top left corner in 1/16 pel for up to 3 fields/frames
+     * - encoding: Set by user.
+     * - decoding: Set by libavcodec.
+     */
+    int16_t position[3][2];
+}AVPanScan;
+
+#define FF_COMMON_FRAME \
+    /**\
+     * pointer to the picture planes.\
+     * This might be different from the first allocated byte\
+     * - encoding: \
+     * - decoding: \
+     */\
+    uint8_t *data[4];\
+    int linesize[4];\
+    /**\
+     * pointer to the first allocated byte of the picture. Can be used in get_buffer/release_buffer.\
+     * This isn't used by libavcodec unless the default get/release_buffer() is used.\
+     * - encoding: \
+     * - decoding: \
+     */\
+    uint8_t *base[4];\
+    /**\
+     * 1 -> keyframe, 0-> not\
+     * - encoding: Set by libavcodec.\
+     * - decoding: Set by libavcodec.\
+     */\
+    int key_frame;\
+\
+    /**\
+     * Picture type of the frame, see ?_TYPE below.\
+     * - encoding: Set by libavcodec. for coded_picture (and set by user for input).\
+     * - decoding: Set by libavcodec.\
+     */\
+    int pict_type;\
+\
+    /**\
+     * presentation timestamp in time_base units (time when frame should be shown to user)\
+     * If AV_NOPTS_VALUE then frame_rate = 1/time_base will be assumed.\
+     * - encoding: MUST be set by user.\
+     * - decoding: Set by libavcodec.\
+     */\
+    int64_t pts;\
+\
+    /**\
+     * picture number in bitstream order\
+     * - encoding: set by\
+     * - decoding: Set by libavcodec.\
+     */\
+    int coded_picture_number;\
+    /**\
+     * picture number in display order\
+     * - encoding: set by\
+     * - decoding: Set by libavcodec.\
+     */\
+    int display_picture_number;\
+\
+    /**\
+     * quality (between 1 (good) and FF_LAMBDA_MAX (bad)) \
+     * - encoding: Set by libavcodec. for coded_picture (and set by user for input).\
+     * - decoding: Set by libavcodec.\
+     */\
+    int quality; \
+\
+    /**\
+     * buffer age (1->was last buffer and dint change, 2->..., ...).\
+     * Set to INT_MAX if the buffer has not been used yet.\
+     * - encoding: unused\
+     * - decoding: MUST be set by get_buffer().\
+     */\
+    int age;\
+\
+    /**\
+     * is this picture used as reference\
+     * - encoding: unused\
+     * - decoding: Set by libavcodec. (before get_buffer() call)).\
+     */\
+    int reference;\
+\
+    /**\
+     * QP table\
+     * - encoding: unused\
+     * - decoding: Set by libavcodec.\
+     */\
+    int8_t *qscale_table;\
+    /**\
+     * QP store stride\
+     * - encoding: unused\
+     * - decoding: Set by libavcodec.\
+     */\
+    int qstride;\
+\
+    /**\
+     * mbskip_table[mb]>=1 if MB didn't change\
+     * stride= mb_width = (width+15)>>4\
+     * - encoding: unused\
+     * - decoding: Set by libavcodec.\
+     */\
+    uint8_t *mbskip_table;\
+\
+    /**\
+     * motion vector table\
+     * @code\
+     * example:\
+     * int mv_sample_log2= 4 - motion_subsample_log2;\
+     * int mb_width= (width+15)>>4;\
+     * int mv_stride= (mb_width << mv_sample_log2) + 1;\
+     * motion_val[direction][x + y*mv_stride][0->mv_x, 1->mv_y];\
+     * @endcode\
+     * - encoding: Set by user.\
+     * - decoding: Set by libavcodec.\
+     */\
+    int16_t (*motion_val[2])[2];\
+\
+    /**\
+     * macroblock type table\
+     * mb_type_base + mb_width + 2\
+     * - encoding: Set by user.\
+     * - decoding: Set by libavcodec.\
+     */\
+    uint32_t *mb_type;\
+\
+    /**\
+     * log2 of the size of the block which a single vector in motion_val represents: \
+     * (4->16x16, 3->8x8, 2-> 4x4, 1-> 2x2)\
+     * - encoding: unused\
+     * - decoding: Set by libavcodec.\
+     */\
+    uint8_t motion_subsample_log2;\
+\
+    /**\
+     * for some private data of the user\
+     * - encoding: unused\
+     * - decoding: Set by user.\
+     */\
+    void *opaque;\
+\
+    /**\
+     * error\
+     * - encoding: Set by libavcodec. if flags&CODEC_FLAG_PSNR.\
+     * - decoding: unused\
+     */\
+    uint64_t error[4];\
+\
+    /**\
+     * type of the buffer (to keep track of who has to deallocate data[*])\
+     * - encoding: Set by the one who allocates it.\
+     * - decoding: Set by the one who allocates it.\
+     * Note: User allocated (direct rendering) & internal buffers cannot coexist currently.\
+     */\
+    int type;\
+    \
+    /**\
+     * When decoding, this signals how much the picture must be delayed.\
+     * extra_delay = repeat_pict / (2*fps)\
+     * - encoding: unused\
+     * - decoding: Set by libavcodec.\
+     */\
+    int repeat_pict;\
+    \
+    /**\
+     * \
+     */\
+    int qscale_type;\
+    \
+    /**\
+     * The content of the picture is interlaced.\
+     * - encoding: Set by user.\
+     * - decoding: Set by libavcodec. (default 0)\
+     */\
+    int interlaced_frame;\
+    \
+    /**\
+     * If the content is interlaced, is top field displayed first.\
+     * - encoding: Set by user.\
+     * - decoding: Set by libavcodec.\
+     */\
+    int top_field_first;\
+    \
+    /**\
+     * Pan scan.\
+     * - encoding: Set by user.\
+     * - decoding: Set by libavcodec.\
+     */\
+    AVPanScan *pan_scan;\
+    \
+    /**\
+     * Tell user application that palette has changed from previous frame.\
+     * - encoding: ??? (no palette-enabled encoder yet)\
+     * - decoding: Set by libavcodec. (default 0).\
+     */\
+    int palette_has_changed;\
+    \
+    /**\
+     * codec suggestion on buffer type if != 0\
+     * - encoding: unused\
+     * - decoding: Set by libavcodec. (before get_buffer() call)).\
+     */\
+    int buffer_hints;\
+\
+    /**\
+     * DCT coefficients\
+     * - encoding: unused\
+     * - decoding: Set by libavcodec.\
+     */\
+    short *dct_coeff;\
+\
+    /**\
+     * motion referece frame index\
+     * - encoding: Set by user.\
+     * - decoding: Set by libavcodec.\
+     */\
+    int8_t *ref_index[2];
+
+#define FF_QSCALE_TYPE_MPEG1 0
+#define FF_QSCALE_TYPE_MPEG2 1
+#define FF_QSCALE_TYPE_H264  2
+
+#define FF_BUFFER_TYPE_INTERNAL 1
+#define FF_BUFFER_TYPE_USER     2 ///< direct rendering buffers (image is (de)allocated by user)
+#define FF_BUFFER_TYPE_SHARED   4 ///< Buffer from somewhere else; don't deallocate image (data/base), all other tables are not shared.
+#define FF_BUFFER_TYPE_COPY     8 ///< Just a (modified) copy of some other buffer, don't deallocate anything.
+
+
+#define FF_I_TYPE  1 // Intra
+#define FF_P_TYPE  2 // Predicted
+#define FF_B_TYPE  3 // Bi-dir predicted
+#define FF_S_TYPE  4 // S(GMC)-VOP MPEG4
+#define FF_SI_TYPE 5
+#define FF_SP_TYPE 6
+
+#define FF_BUFFER_HINTS_VALID    0x01 // Buffer hints value is meaningful (if 0 ignore).
+#define FF_BUFFER_HINTS_READABLE 0x02 // Codec will read from buffer.
+#define FF_BUFFER_HINTS_PRESERVE 0x04 // User must not alter buffer content.
+#define FF_BUFFER_HINTS_REUSABLE 0x08 // Codec will reuse the buffer (update).
+
+/**
+ * Audio Video Frame.
+ */
+typedef struct AVFrame {
+    FF_COMMON_FRAME
+} AVFrame;
+
+#define DEFAULT_FRAME_RATE_BASE 1001000
+
+/**
+ * main external API structure
+ */
+typedef struct AVCodecContext {
+    /**
+     * information on struct for av_log
+     * - set by avcodec_alloc_context
+     */
+    AVClass *av_class;
+    /**
+     * the average bitrate
+     * - encoding: Set by user; unused for constant quantizer encoding.
+     * - decoding: Set by libavcodec. 0 or some bitrate if this info is available in the stream.
+     */
+    int bit_rate;
+
+    /**
+     * number of bits the bitstream is allowed to diverge from the reference.
+     *           the reference can be CBR (for CBR pass1) or VBR (for pass2)
+     * - encoding: Set by user; unused for constant quantizer encoding.
+     * - decoding: unused
+     */
+    int bit_rate_tolerance;
+
+    /**
+     * CODEC_FLAG_*.
+     * - encoding: Set by user.
+     * - decoding: Set by user.
+     */
+    int flags;
+
+    /**
+     * Some codecs need additional format info. It is stored here.
+     * If any muxer uses this then ALL demuxers/parsers AND encoders for the
+     * specific codec MUST set it correctly otherwise stream copy breaks.
+     * In general use of this field by muxers is not recommanded.
+     * - encoding: Set by libavcodec.
+     * - decoding: Set by libavcodec. (FIXME: Is this OK?)
+     */
+    int sub_id;
+
+    /**
+     * Motion estimation algorithm used for video coding.
+     * 1 (zero), 2 (full), 3 (log), 4 (phods), 5 (epzs), 6 (x1), 7 (hex),
+     * 8 (umh), 9 (iter) [7, 8 are x264 specific, 9 is snow specific]
+     * - encoding: MUST be set by user.
+     * - decoding: unused
+     */
+    int me_method;
+
+    /**
+     * some codecs need / can use extradata like Huffman tables.
+     * mjpeg: Huffman tables
+     * rv10: additional flags
+     * mpeg4: global headers (they can be in the bitstream or here)
+     * The allocated memory should be FF_INPUT_BUFFER_PADDING_SIZE bytes larger
+     * than extradata_size to avoid prolems if it is read with the bitstream reader.
+     * The bytewise contents of extradata must not depend on the architecture or CPU endianness.
+     * - encoding: Set/allocated/freed by libavcodec.
+     * - decoding: Set/allocated/freed by user.
+     */
+    uint8_t *extradata;
+    int extradata_size;
+
+    /**
+     * This is the fundamental unit of time (in seconds) in terms
+     * of which frame timestamps are represented. For fixed-fps content,
+     * timebase should be 1/framerate and timestamp increments should be
+     * identically 1.
+     * - encoding: MUST be set by user.
+     * - decoding: Set by libavcodec.
+     */
+    AVRational time_base;
+
+    /* video only */
+    /**
+     * picture width / height.
+     * - encoding: MUST be set by user.
+     * - decoding: Set by libavcodec.
+     * Note: For compatibility it is possible to set this instead of
+     * coded_width/height before decoding.
+     */
+    int width, height;
+
+#define FF_ASPECT_EXTENDED 15
+
+    /**
+     * the number of pictures in a group of pictures, or 0 for intra_only
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int gop_size;
+
+    /**
+     * Pixel format, see PIX_FMT_xxx.
+     * - encoding: Set by user.
+     * - decoding: Set by libavcodec.
+     */
+    enum PixelFormat pix_fmt;
+
+    /**
+     * Frame rate emulation. If not zero, the lower layer (i.e. format handler)
+     * has to read frames at native frame rate.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int rate_emu;
+
+    /**
+     * If non NULL, 'draw_horiz_band' is called by the libavcodec
+     * decoder to draw a horizontal band. It improves cache usage. Not
+     * all codecs can do that. You must check the codec capabilities
+     * beforehand.
+     * - encoding: unused
+     * - decoding: Set by user.
+     * @param height the height of the slice
+     * @param y the y position of the slice
+     * @param type 1->top field, 2->bottom field, 3->frame
+     * @param offset offset into the AVFrame.data from which the slice should be read
+     */
+    void (*draw_horiz_band)(struct AVCodecContext *s,
+                            const AVFrame *src, int offset[4],
+                            int y, int type, int height);
+
+    /* audio only */
+    int sample_rate; ///< samples per second
+    int channels;
+
+    /**
+     * audio sample format
+     * - encoding: Set by user.
+     * - decoding: Set by libavcodec.
+     */
+    enum SampleFormat sample_fmt;  ///< sample format, currently unused
+
+    /* The following data should not be initialized. */
+    /**
+     * Samples per packet, initialized when calling 'init'.
+     */
+    int frame_size;
+    int frame_number;   ///< audio or video frame number
+    int real_pict_num;  ///< Returns the real picture number of previous encoded frame.
+
+    /**
+     * Number of frames the decoded output will be delayed relative to
+     * the encoded input.
+     * - encoding: Set by libavcodec.
+     * - decoding: unused
+     */
+    int delay;
+
+    /* - encoding parameters */
+    float qcompress;  ///< amount of qscale change between easy & hard scenes (0.0-1.0)
+    float qblur;      ///< amount of qscale smoothing over time (0.0-1.0)
+
+    /**
+     * minimum quantizer
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int qmin;
+
+    /**
+     * maximum quantizer
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int qmax;
+
+    /**
+     * maximum quantizer difference between frames
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int max_qdiff;
+
+    /**
+     * maximum number of B-frames between non-B-frames
+     * Note: The output will be delayed by max_b_frames+1 relative to the input.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int max_b_frames;
+
+    /**
+     * qscale factor between IP and B-frames
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float b_quant_factor;
+
+    /** obsolete FIXME remove */
+    int rc_strategy;
+#define FF_RC_STRATEGY_XVID 1
+
+    int b_frame_strategy;
+
+    /**
+     * hurry up amount
+     * - encoding: unused
+     * - decoding: Set by user. 1-> Skip B-frames, 2-> Skip IDCT/dequant too, 5-> Skip everything except header
+     * @deprecated Deprecated in favor of skip_idct and skip_frame.
+     */
+    int hurry_up;
+
+    struct AVCodec *codec;
+
+    void *priv_data;
+
+#if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
+    /* unused, FIXME remove*/
+    int rtp_mode;
+#endif
+
+    int rtp_payload_size;   /* The size of the RTP payload: the coder will  */
+                            /* do its best to deliver a chunk with size     */
+                            /* below rtp_payload_size, the chunk will start */
+                            /* with a start code on some codecs like H.263. */
+                            /* This doesn't take account of any particular  */
+                            /* headers inside the transmitted RTP payload.  */
+
+
+    /* The RTP callback: This function is called    */
+    /* every time the encoder has a packet to send. */
+    /* It depends on the encoder if the data starts */
+    /* with a Start Code (it should). H.263 does.   */
+    /* mb_nb contains the number of macroblocks     */
+    /* encoded in the RTP payload.                  */
+    void (*rtp_callback)(struct AVCodecContext *avctx, void *data, int size, int mb_nb);
+
+    /* statistics, used for 2-pass encoding */
+    int mv_bits;
+    int header_bits;
+    int i_tex_bits;
+    int p_tex_bits;
+    int i_count;
+    int p_count;
+    int skip_count;
+    int misc_bits;
+
+    /**
+     * number of bits used for the previously encoded frame
+     * - encoding: Set by libavcodec.
+     * - decoding: unused
+     */
+    int frame_bits;
+
+    /**
+     * Private data of the user, can be used to carry app specific stuff.
+     * - encoding: Set by user.
+     * - decoding: Set by user.
+     */
+    void *opaque;
+
+    char codec_name[32];
+    enum CodecType codec_type; /* see CODEC_TYPE_xxx */
+    enum CodecID codec_id; /* see CODEC_ID_xxx */
+
+    /**
+     * fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').
+     * This is used to work around some encoder bugs.
+     * A demuxer should set this to what is stored in the field used to identify the codec.
+     * If there are multiple such fields in a container then the demuxer should choose the one
+     * which maximizes the information about the used codec.
+     * If the codec tag field in a container is larger then 32 bits then the demuxer should
+     * remap the longer ID to 32 bits with a table or other structure. Alternatively a new
+     * extra_codec_tag + size could be added but for this a clear advantage must be demonstrated
+     * first.
+     * - encoding: Set by user, if not then the default based on codec_id will be used.
+     * - decoding: Set by user, will be converted to uppercase by libavcodec during init.
+     */
+    unsigned int codec_tag;
+
+    /**
+     * Work around bugs in encoders which sometimes cannot be detected automatically.
+     * - encoding: Set by user
+     * - decoding: Set by user
+     */
+    int workaround_bugs;
+#define FF_BUG_AUTODETECT       1  ///< autodetection
+#define FF_BUG_OLD_MSMPEG4      2
+#define FF_BUG_XVID_ILACE       4
+#define FF_BUG_UMP4             8
+#define FF_BUG_NO_PADDING       16
+#define FF_BUG_AMV              32
+#define FF_BUG_AC_VLC           0  ///< Will be removed, libavcodec can now handle these non-compliant files by default.
+#define FF_BUG_QPEL_CHROMA      64
+#define FF_BUG_STD_QPEL         128
+#define FF_BUG_QPEL_CHROMA2     256
+#define FF_BUG_DIRECT_BLOCKSIZE 512
+#define FF_BUG_EDGE             1024
+#define FF_BUG_HPEL_CHROMA      2048
+#define FF_BUG_DC_CLIP          4096
+#define FF_BUG_MS               8192 ///< Work around various bugs in Microsoft's broken decoders.
+//#define FF_BUG_FAKE_SCALABILITY 16 //Autodetection should work 100%.
+
+    /**
+     * luma single coefficient elimination threshold
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int luma_elim_threshold;
+
+    /**
+     * chroma single coeff elimination threshold
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int chroma_elim_threshold;
+
+    /**
+     * strictly follow the standard (MPEG4, ...).
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int strict_std_compliance;
+#define FF_COMPLIANCE_VERY_STRICT   2 ///< Strictly conform to a older more strict version of the spec or reference software.
+#define FF_COMPLIANCE_STRICT        1 ///< Strictly conform to all the things in the spec no matter what consequences.
+#define FF_COMPLIANCE_NORMAL        0
+#define FF_COMPLIANCE_INOFFICIAL   -1 ///< Allow inofficial extensions.
+#define FF_COMPLIANCE_EXPERIMENTAL -2 ///< Allow nonstandardized experimental things.
+
+    /**
+     * qscale offset between IP and B-frames
+     * If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).
+     * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float b_quant_offset;
+
+    /**
+     * Error resilience; higher values will detect more errors but may
+     * misdetect some more or less valid parts as errors.
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+    int error_resilience;
+#define FF_ER_CAREFUL         1
+#define FF_ER_COMPLIANT       2
+#define FF_ER_AGGRESSIVE      3
+#define FF_ER_VERY_AGGRESSIVE 4
+
+    /**
+     * Called at the beginning of each frame to get a buffer for it.
+     * If pic.reference is set then the frame will be read later by libavcodec.
+     * avcodec_align_dimensions() should be used to find the required width and
+     * height, as they normally need to be rounded up to the next multiple of 16.
+     * - encoding: unused
+     * - decoding: Set by libavcodec., user can override.
+     */
+    int (*get_buffer)(struct AVCodecContext *c, AVFrame *pic);
+
+    /**
+     * Called to release buffers which where allocated with get_buffer.
+     * A released buffer can be reused in get_buffer().
+     * pic.data[*] must be set to NULL.
+     * - encoding: unused
+     * - decoding: Set by libavcodec., user can override.
+     */
+    void (*release_buffer)(struct AVCodecContext *c, AVFrame *pic);
+
+    /**
+     * If 1 the stream has a 1 frame delay during decoding.
+     * - encoding: Set by libavcodec.
+     * - decoding: Set by libavcodec.
+     */
+    int has_b_frames;
+
+    /**
+     * number of bytes per packet if constant and known or 0
+     * Used by some WAV based audio codecs.
+     */
+    int block_align;
+
+    int parse_only; /* - decoding only: If true, only parsing is done
+                       (function avcodec_parse_frame()). The frame
+                       data is returned. Only MPEG codecs support this now. */
+
+    /**
+     * 0-> h263 quant 1-> mpeg quant
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int mpeg_quant;
+
+    /**
+     * pass1 encoding statistics output buffer
+     * - encoding: Set by libavcodec.
+     * - decoding: unused
+     */
+    char *stats_out;
+
+    /**
+     * pass2 encoding statistics input buffer
+     * Concatenated stuff from stats_out of pass1 should be placed here.
+     * - encoding: Allocated/set/freed by user.
+     * - decoding: unused
+     */
+    char *stats_in;
+
+    /**
+     * ratecontrol qmin qmax limiting method
+     * 0-> clipping, 1-> use a nice continous function to limit qscale wthin qmin/qmax.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float rc_qsquish;
+
+    float rc_qmod_amp;
+    int rc_qmod_freq;
+
+    /**
+     * ratecontrol override, see RcOverride
+     * - encoding: Allocated/set/freed by user.
+     * - decoding: unused
+     */
+    RcOverride *rc_override;
+    int rc_override_count;
+
+    /**
+     * rate control equation
+     * - encoding: Set by user
+     * - decoding: unused
+     */
+    char *rc_eq;
+
+    /**
+     * maximum bitrate
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int rc_max_rate;
+
+    /**
+     * minimum bitrate
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int rc_min_rate;
+
+    /**
+     * decoder bitstream buffer size
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int rc_buffer_size;
+    float rc_buffer_aggressivity;
+
+    /**
+     * qscale factor between P and I-frames
+     * If > 0 then the last p frame quantizer will be used (q= lastp_q*factor+offset).
+     * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float i_quant_factor;
+
+    /**
+     * qscale offset between P and I-frames
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float i_quant_offset;
+
+    /**
+     * initial complexity for pass1 ratecontrol
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float rc_initial_cplx;
+
+    /**
+     * DCT algorithm, see FF_DCT_* below
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int dct_algo;
+#define FF_DCT_AUTO    0
+#define FF_DCT_FASTINT 1
+#define FF_DCT_INT     2
+#define FF_DCT_MMX     3
+#define FF_DCT_MLIB    4
+#define FF_DCT_ALTIVEC 5
+#define FF_DCT_FAAN    6
+
+    /**
+     * luminance masking (0-> disabled)
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float lumi_masking;
+
+    /**
+     * temporary complexity masking (0-> disabled)
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float temporal_cplx_masking;
+
+    /**
+     * spatial complexity masking (0-> disabled)
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float spatial_cplx_masking;
+
+    /**
+     * p block masking (0-> disabled)
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float p_masking;
+
+    /**
+     * darkness masking (0-> disabled)
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float dark_masking;
+
+
+    /* for binary compatibility */
+    int unused;
+
+    /**
+     * IDCT algorithm, see FF_IDCT_* below.
+     * - encoding: Set by user.
+     * - decoding: Set by user.
+     */
+    int idct_algo;
+#define FF_IDCT_AUTO          0
+#define FF_IDCT_INT           1
+#define FF_IDCT_SIMPLE        2
+#define FF_IDCT_SIMPLEMMX     3
+#define FF_IDCT_LIBMPEG2MMX   4
+#define FF_IDCT_PS2           5
+#define FF_IDCT_MLIB          6
+#define FF_IDCT_ARM           7
+#define FF_IDCT_ALTIVEC       8
+#define FF_IDCT_SH4           9
+#define FF_IDCT_SIMPLEARM     10
+#define FF_IDCT_H264          11
+#define FF_IDCT_VP3           12
+#define FF_IDCT_IPP           13
+#define FF_IDCT_XVIDMMX       14
+#define FF_IDCT_CAVS          15
+#define FF_IDCT_SIMPLEARMV5TE 16
+#define FF_IDCT_SIMPLEARMV6   17
+#define FF_IDCT_SIMPLEVIS     18
+
+    /**
+     * slice count
+     * - encoding: Set by libavcodec.
+     * - decoding: Set by user (or 0).
+     */
+    int slice_count;
+    /**
+     * slice offsets in the frame in bytes
+     * - encoding: Set/allocated by libavcodec.
+     * - decoding: Set/allocated by user (or NULL).
+     */
+    int *slice_offset;
+
+    /**
+     * error concealment flags
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+    int error_concealment;
+#define FF_EC_GUESS_MVS   1
+#define FF_EC_DEBLOCK     2
+
+    /**
+     * dsp_mask could be add used to disable unwanted CPU features
+     * CPU features (i.e. MMX, SSE. ...)
+     *
+     * With the FORCE flag you may instead enable given CPU features.
+     * (Dangerous: Usable in case of misdetection, improper usage however will
+     * result into program crash.)
+     */
+    unsigned dsp_mask;
+#define FF_MM_FORCE    0x80000000 /* Force usage of selected flags (OR) */
+    /* lower 16 bits - CPU features */
+#define FF_MM_MMX      0x0001 /* standard MMX */
+#define FF_MM_3DNOW    0x0004 /* AMD 3DNOW */
+#define FF_MM_MMXEXT   0x0002 /* SSE integer functions or AMD MMX ext */
+#define FF_MM_SSE      0x0008 /* SSE functions */
+#define FF_MM_SSE2     0x0010 /* PIV SSE2 functions */
+#define FF_MM_3DNOWEXT 0x0020 /* AMD 3DNowExt */
+#define FF_MM_SSE3     0x0040 /* Prescott SSE3 functions */
+#define FF_MM_SSSE3    0x0080 /* Conroe SSSE3 functions */
+#define FF_MM_IWMMXT   0x0100 /* XScale IWMMXT */
+
+    /**
+     * bits per sample/pixel from the demuxer (needed for huffyuv).
+     * - encoding: Set by libavcodec.
+     * - decoding: Set by user.
+     */
+     int bits_per_sample;
+
+    /**
+     * prediction method (needed for huffyuv)
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+     int prediction_method;
+#define FF_PRED_LEFT   0
+#define FF_PRED_PLANE  1
+#define FF_PRED_MEDIAN 2
+
+    /**
+     * sample aspect ratio (0 if unknown)
+     * Numerator and denominator must be relatively prime and smaller than 256 for some video standards.
+     * - encoding: Set by user.
+     * - decoding: Set by libavcodec.
+     */
+    AVRational sample_aspect_ratio;
+
+    /**
+     * the picture in the bitstream
+     * - encoding: Set by libavcodec.
+     * - decoding: Set by libavcodec.
+     */
+    AVFrame *coded_frame;
+
+    /**
+     * debug
+     * - encoding: Set by user.
+     * - decoding: Set by user.
+     */
+    int debug;
+#define FF_DEBUG_PICT_INFO   1
+#define FF_DEBUG_RC          2
+#define FF_DEBUG_BITSTREAM   4
+#define FF_DEBUG_MB_TYPE     8
+#define FF_DEBUG_QP          16
+#define FF_DEBUG_MV          32
+#define FF_DEBUG_DCT_COEFF   0x00000040
+#define FF_DEBUG_SKIP        0x00000080
+#define FF_DEBUG_STARTCODE   0x00000100
+#define FF_DEBUG_PTS         0x00000200
+#define FF_DEBUG_ER          0x00000400
+#define FF_DEBUG_MMCO        0x00000800
+#define FF_DEBUG_BUGS        0x00001000
+#define FF_DEBUG_VIS_QP      0x00002000
+#define FF_DEBUG_VIS_MB_TYPE 0x00004000
+
+    /**
+     * debug
+     * - encoding: Set by user.
+     * - decoding: Set by user.
+     */
+    int debug_mv;
+#define FF_DEBUG_VIS_MV_P_FOR  0x00000001 //visualize forward predicted MVs of P frames
+#define FF_DEBUG_VIS_MV_B_FOR  0x00000002 //visualize forward predicted MVs of B frames
+#define FF_DEBUG_VIS_MV_B_BACK 0x00000004 //visualize backward predicted MVs of B frames
+
+    /**
+     * error
+     * - encoding: Set by libavcodec if flags&CODEC_FLAG_PSNR.
+     * - decoding: unused
+     */
+    uint64_t error[4];
+
+    /**
+     * minimum MB quantizer
+     * - encoding: unused
+     * - decoding: unused
+     */
+    int mb_qmin;
+
+    /**
+     * maximum MB quantizer
+     * - encoding: unused
+     * - decoding: unused
+     */
+    int mb_qmax;
+
+    /**
+     * motion estimation comparison function
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int me_cmp;
+    /**
+     * subpixel motion estimation comparison function
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int me_sub_cmp;
+    /**
+     * macroblock comparison function (not supported yet)
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int mb_cmp;
+    /**
+     * interlaced DCT comparison function
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int ildct_cmp;
+#define FF_CMP_SAD    0
+#define FF_CMP_SSE    1
+#define FF_CMP_SATD   2
+#define FF_CMP_DCT    3
+#define FF_CMP_PSNR   4
+#define FF_CMP_BIT    5
+#define FF_CMP_RD     6
+#define FF_CMP_ZERO   7
+#define FF_CMP_VSAD   8
+#define FF_CMP_VSSE   9
+#define FF_CMP_NSSE   10
+#define FF_CMP_W53    11
+#define FF_CMP_W97    12
+#define FF_CMP_DCTMAX 13
+#define FF_CMP_DCT264 14
+#define FF_CMP_CHROMA 256
+
+    /**
+     * ME diamond size & shape
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int dia_size;
+
+    /**
+     * amount of previous MV predictors (2a+1 x 2a+1 square)
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int last_predictor_count;
+
+    /**
+     * prepass for motion estimation
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int pre_me;
+
+    /**
+     * motion estimation prepass comparison function
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int me_pre_cmp;
+
+    /**
+     * ME prepass diamond size & shape
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int pre_dia_size;
+
+    /**
+     * subpel ME quality
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int me_subpel_quality;
+
+    /**
+     * callback to negotiate the pixelFormat
+     * @param fmt is the list of formats which are supported by the codec,
+     * it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.
+     * The first is always the native one.
+     * @return the chosen format
+     * - encoding: unused
+     * - decoding: Set by user, if not set the native format will be chosen.
+     */
+    enum PixelFormat (*get_format)(struct AVCodecContext *s, const enum PixelFormat * fmt);
+
+    /**
+     * DTG active format information (additional aspect ratio
+     * information only used in DVB MPEG-2 transport streams)
+     * 0 if not set.
+     *
+     * - encoding: unused
+     * - decoding: Set by decoder.
+     */
+    int dtg_active_format;
+#define FF_DTG_AFD_SAME         8
+#define FF_DTG_AFD_4_3          9
+#define FF_DTG_AFD_16_9         10
+#define FF_DTG_AFD_14_9         11
+#define FF_DTG_AFD_4_3_SP_14_9  13
+#define FF_DTG_AFD_16_9_SP_14_9 14
+#define FF_DTG_AFD_SP_4_3       15
+
+    /**
+     * maximum motion estimation search range in subpel units
+     * If 0 then no limit.
+     *
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int me_range;
+
+    /**
+     * intra quantizer bias
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int intra_quant_bias;
+#define FF_DEFAULT_QUANT_BIAS 999999
+
+    /**
+     * inter quantizer bias
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int inter_quant_bias;
+
+    /**
+     * color table ID
+     * - encoding: unused
+     * - decoding: Which clrtable should be used for 8bit RGB images.
+     *             Tables have to be stored somewhere. FIXME
+     */
+    int color_table_id;
+
+    /**
+     * internal_buffer count
+     * Don't touch, used by libavcodec default_get_buffer().
+     */
+    int internal_buffer_count;
+
+    /**
+     * internal_buffers
+     * Don't touch, used by libavcodec default_get_buffer().
+     */
+    void *internal_buffer;
+
+#define FF_LAMBDA_SHIFT 7
+#define FF_LAMBDA_SCALE (1<<FF_LAMBDA_SHIFT)
+#define FF_QP2LAMBDA 118 ///< factor to convert from H.263 QP to lambda
+#define FF_LAMBDA_MAX (256*128-1)
+
+#define FF_QUALITY_SCALE FF_LAMBDA_SCALE //FIXME maybe remove
+    /**
+     * Global quality for codecs which cannot change it per frame.
+     * This should be proportional to MPEG-1/2/4 qscale.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int global_quality;
+
+#define FF_CODER_TYPE_VLC       0
+#define FF_CODER_TYPE_AC        1
+#define FF_CODER_TYPE_RAW       2
+#define FF_CODER_TYPE_RLE       3
+#define FF_CODER_TYPE_DEFLATE   4
+    /**
+     * coder type
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int coder_type;
+
+    /**
+     * context model
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int context_model;
+#if 0
+    /**
+     *
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+    uint8_t * (*realloc)(struct AVCodecContext *s, uint8_t *buf, int buf_size);
+#endif
+
+    /**
+     * slice flags
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+    int slice_flags;
+#define SLICE_FLAG_CODED_ORDER    0x0001 ///< draw_horiz_band() is called in coded order instead of display
+#define SLICE_FLAG_ALLOW_FIELD    0x0002 ///< allow draw_horiz_band() with field slices (MPEG2 field pics)
+#define SLICE_FLAG_ALLOW_PLANE    0x0004 ///< allow draw_horiz_band() with 1 component at a time (SVQ1)
+
+    /**
+     * XVideo Motion Acceleration
+     * - encoding: forbidden
+     * - decoding: set by decoder
+     */
+    int xvmc_acceleration;
+
+    /**
+     * macroblock decision mode
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int mb_decision;
+#define FF_MB_DECISION_SIMPLE 0        ///< uses mb_cmp
+#define FF_MB_DECISION_BITS   1        ///< chooses the one which needs the fewest bits
+#define FF_MB_DECISION_RD     2        ///< rate distoration
+
+    /**
+     * custom intra quantization matrix
+     * - encoding: Set by user, can be NULL.
+     * - decoding: Set by libavcodec.
+     */
+    uint16_t *intra_matrix;
+
+    /**
+     * custom inter quantization matrix
+     * - encoding: Set by user, can be NULL.
+     * - decoding: Set by libavcodec.
+     */
+    uint16_t *inter_matrix;
+
+    /**
+     * fourcc from the AVI stream header (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').
+     * This is used to work around some encoder bugs.
+     * - encoding: unused
+     * - decoding: Set by user, will be converted to uppercase by libavcodec during init.
+     */
+    unsigned int stream_codec_tag;
+
+    /**
+     * scene change detection threshold
+     * 0 is default, larger means fewer detected scene changes.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int scenechange_threshold;
+
+    /**
+     * minimum Lagrange multipler
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int lmin;
+
+    /**
+     * maximum Lagrange multipler
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int lmax;
+
+    /**
+     * palette control structure
+     * - encoding: ??? (no palette-enabled encoder yet)
+     * - decoding: Set by user.
+     */
+    struct AVPaletteControl *palctrl;
+
+    /**
+     * noise reduction strength
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int noise_reduction;
+
+    /**
+     * Called at the beginning of a frame to get cr buffer for it.
+     * Buffer type (size, hints) must be the same. libavcodec won't check it.
+     * libavcodec will pass previous buffer in pic, function should return
+     * same buffer or new buffer with old frame "painted" into it.
+     * If pic.data[0] == NULL must behave like get_buffer().
+     * - encoding: unused
+     * - decoding: Set by libavcodec., user can override
+     */
+    int (*reget_buffer)(struct AVCodecContext *c, AVFrame *pic);
+
+    /**
+     * Number of bits which should be loaded into the rc buffer before decoding starts.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int rc_initial_buffer_occupancy;
+
+    /**
+     *
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int inter_threshold;
+
+    /**
+     * CODEC_FLAG2_*
+     * - encoding: Set by user.
+     * - decoding: Set by user.
+     */
+    int flags2;
+
+    /**
+     * Simulates errors in the bitstream to test error concealment.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int error_rate;
+
+    /**
+     * MP3 antialias algorithm, see FF_AA_* below.
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+    int antialias_algo;
+#define FF_AA_AUTO    0
+#define FF_AA_FASTINT 1 //not implemented yet
+#define FF_AA_INT     2
+#define FF_AA_FLOAT   3
+    /**
+     * quantizer noise shaping
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int quantizer_noise_shaping;
+
+    /**
+     * thread count
+     * is used to decide how many independent tasks should be passed to execute()
+     * - encoding: Set by user.
+     * - decoding: Set by user.
+     */
+    int thread_count;
+
+    /**
+     * The codec may call this to execute several independent things.
+     * It will return only after finishing all tasks.
+     * The user may replace this with some multithreaded implementation,
+     * the default implementation will execute the parts serially.
+     * @param count the number of things to execute
+     * - encoding: Set by libavcodec, user can override.
+     * - decoding: Set by libavcodec, user can override.
+     */
+    int (*execute)(struct AVCodecContext *c, int (*func)(struct AVCodecContext *c2, void *arg), void **arg2, int *ret, int count);
+
+    /**
+     * thread opaque
+     * Can be used by execute() to store some per AVCodecContext stuff.
+     * - encoding: set by execute()
+     * - decoding: set by execute()
+     */
+    void *thread_opaque;
+
+    /**
+     * Motion estimation threshold below which no motion estimation is
+     * performed, but instead the user specified motion vectors are used.
+     *
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+     int me_threshold;
+
+    /**
+     * Macroblock threshold below which the user specified macroblock types will be used.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+     int mb_threshold;
+
+    /**
+     * precision of the intra DC coefficient - 8
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+     int intra_dc_precision;
+
+    /**
+     * noise vs. sse weight for the nsse comparsion function
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+     int nsse_weight;
+
+    /**
+     * Number of macroblock rows at the top which are skipped.
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+     int skip_top;
+
+    /**
+     * Number of macroblock rows at the bottom which are skipped.
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+     int skip_bottom;
+
+    /**
+     * profile
+     * - encoding: Set by user.
+     * - decoding: Set by libavcodec.
+     */
+     int profile;
+#define FF_PROFILE_UNKNOWN -99
+#define FF_PROFILE_AAC_MAIN 0
+#define FF_PROFILE_AAC_LOW  1
+#define FF_PROFILE_AAC_SSR  2
+#define FF_PROFILE_AAC_LTP  3
+
+    /**
+     * level
+     * - encoding: Set by user.
+     * - decoding: Set by libavcodec.
+     */
+     int level;
+#define FF_LEVEL_UNKNOWN -99
+
+    /**
+     * low resolution decoding, 1-> 1/2 size, 2->1/4 size
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+     int lowres;
+
+    /**
+     * Bitstream width / height, may be different from width/height if lowres
+     * or other things are used.
+     * - encoding: unused
+     * - decoding: Set by user before init if known. Codec should override / dynamically change if needed.
+     */
+    int coded_width, coded_height;
+
+    /**
+     * frame skip threshold
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int frame_skip_threshold;
+
+    /**
+     * frame skip factor
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int frame_skip_factor;
+
+    /**
+     * frame skip exponent
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int frame_skip_exp;
+
+    /**
+     * frame skip comparison function
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int frame_skip_cmp;
+
+    /**
+     * Border processing masking, raises the quantizer for mbs on the borders
+     * of the picture.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float border_masking;
+
+    /**
+     * minimum MB lagrange multipler
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int mb_lmin;
+
+    /**
+     * maximum MB lagrange multipler
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int mb_lmax;
+
+    /**
+     *
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int me_penalty_compensation;
+
+    /**
+     *
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+    enum AVDiscard skip_loop_filter;
+
+    /**
+     *
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+    enum AVDiscard skip_idct;
+
+    /**
+     *
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+    enum AVDiscard skip_frame;
+
+    /**
+     *
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int bidir_refine;
+
+    /**
+     *
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int brd_scale;
+
+    /**
+     * constant rate factor - quality-based VBR - values ~correspond to qps
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float crf;
+
+    /**
+     * constant quantization parameter rate control method
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int cqp;
+
+    /**
+     * minimum GOP size
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int keyint_min;
+
+    /**
+     * number of reference frames
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int refs;
+
+    /**
+     * chroma qp offset from luma
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int chromaoffset;
+
+    /**
+     * Influences how often B-frames are used.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int bframebias;
+
+    /**
+     * trellis RD quantization
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int trellis;
+
+    /**
+     * Reduce fluctuations in qp (before curve compression).
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    float complexityblur;
+
+    /**
+     * in-loop deblocking filter alphac0 parameter
+     * alpha is in the range -6...6
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int deblockalpha;
+
+    /**
+     * in-loop deblocking filter beta parameter
+     * beta is in the range -6...6
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int deblockbeta;
+
+    /**
+     * macroblock subpartition sizes to consider - p8x8, p4x4, b8x8, i8x8, i4x4
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int partitions;
+#define X264_PART_I4X4 0x001  /* Analyse i4x4 */
+#define X264_PART_I8X8 0x002  /* Analyse i8x8 (requires 8x8 transform) */
+#define X264_PART_P8X8 0x010  /* Analyse p16x8, p8x16 and p8x8 */
+#define X264_PART_P4X4 0x020  /* Analyse p8x4, p4x8, p4x4 */
+#define X264_PART_B8X8 0x100  /* Analyse b16x8, b8x16 and b8x8 */
+
+    /**
+     * direct MV prediction mode - 0 (none), 1 (spatial), 2 (temporal)
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int directpred;
+
+    /**
+     * Audio cutoff bandwidth (0 means "automatic"), currently used only by FAAC.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int cutoff;
+
+    /**
+     * Multiplied by qscale for each frame and added to scene_change_score.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int scenechange_factor;
+
+    /**
+     *
+     * Note: Value depends upon the compare function used for fullpel ME.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int mv0_threshold;
+
+    /**
+     * Adjusts sensitivity of b_frame_strategy 1.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int b_sensitivity;
+
+    /**
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int compression_level;
+#define FF_COMPRESSION_DEFAULT -1
+
+    /**
+     * Sets whether to use LPC mode - used by FLAC encoder.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int use_lpc;
+
+    /**
+     * LPC coefficient precision - used by FLAC encoder
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int lpc_coeff_precision;
+
+    /**
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int min_prediction_order;
+
+    /**
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int max_prediction_order;
+
+    /**
+     * search method for selecting prediction order
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int prediction_order_method;
+
+    /**
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int min_partition_order;
+
+    /**
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int max_partition_order;
+
+    /**
+     * GOP timecode frame start number, in non drop frame format
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int64_t timecode_frame_start;
+
+    /**
+     * Decoder should decode to this many channels if it can (0 for default)
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+    int request_channels;
+} AVCodecContext;
+
+/**
+ * AVCodec.
+ */
+typedef struct AVCodec {
+    /**
+     * Name of the codec implementation.
+     * The name is globally unique among encoders and among decoders (but an
+     * encoder and a decoder can share the same name).
+     * This is the primary way to find a codec from the user perspective.
+     */
+    const char *name;
+    enum CodecType type;
+    enum CodecID id;
+    int priv_data_size;
+    int (*init)(AVCodecContext *);
+    int (*encode)(AVCodecContext *, uint8_t *buf, int buf_size, void *data);
+    int (*close)(AVCodecContext *);
+    int (*decode)(AVCodecContext *, void *outdata, int *outdata_size,
+                  uint8_t *buf, int buf_size);
+    int capabilities;
+    struct AVCodec *next;
+    void (*flush)(AVCodecContext *);
+    const AVRational *supported_framerates; ///array of supported framerates, or NULL if any, array is terminated by {0,0}
+    const enum PixelFormat *pix_fmts;       ///array of supported pixel formats, or NULL if unknown, array is terminanted by -1
+} AVCodec;
+
+/**
+ * four components are given, that's all.
+ * the last component is alpha
+ */
+typedef struct AVPicture {
+    uint8_t *data[4];
+    int linesize[4];       ///< number of bytes per line
+} AVPicture;
+
+/**
+ * AVPaletteControl
+ * This structure defines a method for communicating palette changes
+ * between and demuxer and a decoder.
+ *
+ * @deprecated Use AVPacket to send palette changes instead.
+ * This is totally broken.
+ */
+#define AVPALETTE_SIZE 1024
+#define AVPALETTE_COUNT 256
+typedef struct AVPaletteControl {
+
+    /* Demuxer sets this to 1 to indicate the palette has changed;
+     * decoder resets to 0. */
+    int palette_changed;
+
+    /* 4-byte ARGB palette entries, stored in native byte order; note that
+     * the individual palette components should be on a 8-bit scale; if
+     * the palette data comes from an IBM VGA native format, the component
+     * data is probably 6 bits in size and needs to be scaled. */
+    unsigned int palette[AVPALETTE_COUNT];
+
+} AVPaletteControl attribute_deprecated;
+
+typedef struct AVSubtitleRect {
+    uint16_t x;
+    uint16_t y;
+    uint16_t w;
+    uint16_t h;
+    uint16_t nb_colors;
+    int linesize;
+    uint32_t *rgba_palette;
+    uint8_t *bitmap;
+} AVSubtitleRect;
+
+typedef struct AVSubtitle {
+    uint16_t format; /* 0 = graphics */
+    uint32_t start_display_time; /* relative to packet pts, in ms */
+    uint32_t end_display_time; /* relative to packet pts, in ms */
+    uint32_t num_rects;
+    AVSubtitleRect *rects;
+} AVSubtitle;
+
+
+/* resample.c */
+
+struct ReSampleContext;
+struct AVResampleContext;
+
+typedef struct ReSampleContext ReSampleContext;
+
+ReSampleContext *audio_resample_init(int output_channels, int input_channels,
+                                     int output_rate, int input_rate);
+int audio_resample(ReSampleContext *s, short *output, short *input, int nb_samples);
+void audio_resample_close(ReSampleContext *s);
+
+struct AVResampleContext *av_resample_init(int out_rate, int in_rate, int filter_length, int log2_phase_count, int linear, double cutoff);
+int av_resample(struct AVResampleContext *c, short *dst, short *src, int *consumed, int src_size, int dst_size, int update_ctx);
+void av_resample_compensate(struct AVResampleContext *c, int sample_delta, int compensation_distance);
+void av_resample_close(struct AVResampleContext *c);
+
+#if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
+/* YUV420 format is assumed ! */
+
+/**
+ * @deprecated Use the software scaler (swscale) instead.
+ */
+typedef struct ImgReSampleContext ImgReSampleContext attribute_deprecated;
+
+/**
+ * @deprecated Use the software scaler (swscale) instead.
+ */
+attribute_deprecated ImgReSampleContext *img_resample_init(int output_width, int output_height,
+                                      int input_width, int input_height);
+
+/**
+ * @deprecated Use the software scaler (swscale) instead.
+ */
+attribute_deprecated ImgReSampleContext *img_resample_full_init(int owidth, int oheight,
+                                      int iwidth, int iheight,
+                                      int topBand, int bottomBand,
+                                      int leftBand, int rightBand,
+                                      int padtop, int padbottom,
+                                      int padleft, int padright);
+
+/**
+ * @deprecated Use the software scaler (swscale) instead.
+ */
+attribute_deprecated void img_resample(struct ImgReSampleContext *s,
+                  AVPicture *output, const AVPicture *input);
+
+/**
+ * @deprecated Use the software scaler (swscale) instead.
+ */
+attribute_deprecated void img_resample_close(struct ImgReSampleContext *s);
+
+#endif
+
+/**
+ * Allocate memory for a picture.  Call avpicture_free to free it.
+ *
+ * @param picture the picture to be filled in
+ * @param pix_fmt the format of the picture
+ * @param width the width of the picture
+ * @param height the height of the picture
+ * @return zero if successful, a negative value if not
+ */
+int avpicture_alloc(AVPicture *picture, int pix_fmt, int width, int height);
+
+/**
+ * Free a picture previously allocated by avpicture_alloc().
+ *
+ * @param picture the AVPicture to be freed
+ */
+void avpicture_free(AVPicture *picture);
+
+/**
+ * Fill in the AVPicture fields.
+ * The fields of the given AVPicture are filled in by using the 'ptr' address
+ * which points to the image data buffer. Depending on the specified picture
+ * format, one or multiple image data pointers and line sizes will be set.
+ * If a planar format is specified, several pointers will be set pointing to
+ * the different picture planes and the line sizes of the different planes
+ * will be stored in the lines_sizes array.
+ *
+ * @param picture AVPicture whose fields are to be filled in
+ * @param ptr Buffer which will contain or contains the actual image data
+ * @param pix_fmt The format in which the picture data is stored.
+ * @param width the width of the image in pixels
+ * @param height the height of the image in pixels
+ * @return size of the image data in bytes
+ */
+int avpicture_fill(AVPicture *picture, uint8_t *ptr,
+                   int pix_fmt, int width, int height);
+int avpicture_layout(const AVPicture* src, int pix_fmt, int width, int height,
+                     unsigned char *dest, int dest_size);
+
+/**
+ * Calculate the size in bytes that a picture of the given width and height
+ * would occupy if stored in the given picture format.
+ *
+ * @param pix_fmt the given picture format
+ * @param width the width of the image
+ * @param height the height of the image
+ * @return Image data size in bytes
+ */
+int avpicture_get_size(int pix_fmt, int width, int height);
+void avcodec_get_chroma_sub_sample(int pix_fmt, int *h_shift, int *v_shift);
+const char *avcodec_get_pix_fmt_name(int pix_fmt);
+void avcodec_set_dimensions(AVCodecContext *s, int width, int height);
+enum PixelFormat avcodec_get_pix_fmt(const char* name);
+unsigned int avcodec_pix_fmt_to_codec_tag(enum PixelFormat p);
+
+#define FF_LOSS_RESOLUTION  0x0001 /**< loss due to resolution change */
+#define FF_LOSS_DEPTH       0x0002 /**< loss due to color depth change */
+#define FF_LOSS_COLORSPACE  0x0004 /**< loss due to color space conversion */
+#define FF_LOSS_ALPHA       0x0008 /**< loss of alpha bits */
+#define FF_LOSS_COLORQUANT  0x0010 /**< loss due to color quantization */
+#define FF_LOSS_CHROMA      0x0020 /**< loss of chroma (e.g. RGB to gray conversion) */
+
+/**
+ * Computes what kind of losses will occur when converting from one specific
+ * pixel format to another.
+ * When converting from one pixel format to another, information loss may occur.
+ * For example, when converting from RGB24 to GRAY, the color information will
+ * be lost. Similarly, other losses occur when converting from some formats to
+ * other formats. These losses can involve loss of chroma, but also loss of
+ * resolution, loss of color depth, loss due to the color space conversion, loss
+ * of the alpha bits or loss due to color quantization.
+ * avcodec_get_fix_fmt_loss() informs you about the various types of losses
+ * which will occur when converting from one pixel format to another.
+ *
+ * @param[in] dst_pix_fmt destination pixel format
+ * @param[in] src_pix_fmt source pixel format
+ * @param[in] has_alpha Whether the source pixel format alpha channel is used.
+ * @return Combination of flags informing you what kind of losses will occur.
+ */
+int avcodec_get_pix_fmt_loss(int dst_pix_fmt, int src_pix_fmt,
+                             int has_alpha);
+
+/**
+ * Finds the best pixel format to convert to given a certain source pixel
+ * format.  When converting from one pixel format to another, information loss
+ * may occur.  For example, when converting from RGB24 to GRAY, the color
+ * information will be lost. Similarly, other losses occur when converting from
+ * some formats to other formats. avcodec_find_best_pix_fmt() searches which of
+ * the given pixel formats should be used to suffer the least amount of loss.
+ * The pixel formats from which it chooses one, are determined by the
+ * \p pix_fmt_mask parameter.
+ *
+ * @code
+ * src_pix_fmt = PIX_FMT_YUV420P;
+ * pix_fmt_mask = (1 << PIX_FMT_YUV422P) || (1 << PIX_FMT_RGB24);
+ * dst_pix_fmt = avcodec_find_best_pix_fmt(pix_fmt_mask, src_pix_fmt, alpha, &loss);
+ * @endcode
+ *
+ * @param[in] pix_fmt_mask bitmask determining which pixel format to choose from
+ * @param[in] src_pix_fmt source pixel format
+ * @param[in] has_alpha Whether the source pixel format alpha channel is used.
+ * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.
+ * @return The best pixel format to convert to or -1 if none was found.
+ */
+int avcodec_find_best_pix_fmt(int pix_fmt_mask, int src_pix_fmt,
+                              int has_alpha, int *loss_ptr);
+
+
+/**
+ * Print in buf the string corresponding to the pixel format with
+ * number pix_fmt, or an header if pix_fmt is negative.
+ *
+ * @param buf[in] the buffer where to write the string
+ * @param buf_size[in] the size of buf
+ * @param pix_fmt[in] the number of the pixel format to print the corresponding info string, or
+ * a negative value to print the corresponding header.
+ * Meaningful values for obtaining a pixel format info vary from 0 to PIX_FMT_NB -1.
+ */
+void avcodec_pix_fmt_string (char *buf, int buf_size, int pix_fmt);
+
+#define FF_ALPHA_TRANSP       0x0001 /* image has some totally transparent pixels */
+#define FF_ALPHA_SEMI_TRANSP  0x0002 /* image has some transparent pixels */
+
+/**
+ * Tell if an image really has transparent alpha values.
+ * @return ored mask of FF_ALPHA_xxx constants
+ */
+int img_get_alpha_info(const AVPicture *src,
+                       int pix_fmt, int width, int height);
+
+#if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
+/**
+ * convert among pixel formats
+ * @deprecated Use the software scaler (swscale) instead.
+ */
+attribute_deprecated int img_convert(AVPicture *dst, int dst_pix_fmt,
+                const AVPicture *src, int pix_fmt,
+                int width, int height);
+#endif
+
+/* deinterlace a picture */
+/* deinterlace - if not supported return -1 */
+int avpicture_deinterlace(AVPicture *dst, const AVPicture *src,
+                          int pix_fmt, int width, int height);
+
+/* external high level API */
+
+extern AVCodec *first_avcodec;
+
+/* returns LIBAVCODEC_VERSION_INT constant */
+unsigned avcodec_version(void);
+/* returns LIBAVCODEC_BUILD constant */
+unsigned avcodec_build(void);
+
+/**
+ * Initializes libavcodec.
+ *
+ * @warning This function \e must be called before any other libavcodec
+ * function.
+ */
+void avcodec_init(void);
+
+void register_avcodec(AVCodec *format);
+
+/**
+ * Finds a registered encoder with a matching codec ID.
+ *
+ * @param id CodecID of the requested encoder
+ * @return An encoder if one was found, NULL otherwise.
+ */
+AVCodec *avcodec_find_encoder(enum CodecID id);
+
+/**
+ * Finds a registered encoder with the specified name.
+ *
+ * @param name name of the requested encoder
+ * @return An encoder if one was found, NULL otherwise.
+ */
+AVCodec *avcodec_find_encoder_by_name(const char *name);
+
+/**
+ * Finds a registered decoder with a matching codec ID.
+ *
+ * @param id CodecID of the requested decoder
+ * @return A decoder if one was found, NULL otherwise.
+ */
+AVCodec *avcodec_find_decoder(enum CodecID id);
+
+/**
+ * Finds a registered decoder with the specified name.
+ *
+ * @param name name of the requested decoder
+ * @return A decoder if one was found, NULL otherwise.
+ */
+AVCodec *avcodec_find_decoder_by_name(const char *name);
+void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode);
+
+/**
+ * Sets the fields of the given AVCodecContext to default values.
+ *
+ * @param s The AVCodecContext of which the fields should be set to default values.
+ */
+void avcodec_get_context_defaults(AVCodecContext *s);
+
+/** THIS FUNCTION IS NOT YET PART OF THE PUBLIC API!
+ *  we WILL change its arguments and name a few times! */
+void avcodec_get_context_defaults2(AVCodecContext *s, enum CodecType);
+
+/**
+ * Allocates an AVCodecContext and sets its fields to default values.  The
+ * resulting struct can be deallocated by simply calling av_free().
+ *
+ * @return An AVCodecContext filled with default values or NULL on failure.
+ * @see avcodec_get_context_defaults
+ */
+AVCodecContext *avcodec_alloc_context(void);
+
+/** THIS FUNCTION IS NOT YET PART OF THE PUBLIC API!
+ *  we WILL change its arguments and name a few times! */
+AVCodecContext *avcodec_alloc_context2(enum CodecType);
+
+/**
+ * Sets the fields of the given AVFrame to default values.
+ *
+ * @param pic The AVFrame of which the fields should be set to default values.
+ */
+void avcodec_get_frame_defaults(AVFrame *pic);
+
+/**
+ * Allocates an AVFrame and sets its fields to default values.  The resulting
+ * struct can be deallocated by simply calling av_free().
+ *
+ * @return An AVFrame filled with default values or NULL on failure.
+ * @see avcodec_get_frame_defaults
+ */
+AVFrame *avcodec_alloc_frame(void);
+
+int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *pic);
+void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic);
+int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic);
+void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height);
+
+/**
+ * Checks if the given dimension of a picture is valid, meaning that all
+ * bytes of the picture can be addressed with a signed int.
+ *
+ * @param[in] w Width of the picture.
+ * @param[in] h Height of the picture.
+ * @return Zero if valid, a negative value if invalid.
+ */
+int avcodec_check_dimensions(void *av_log_ctx, unsigned int w, unsigned int h);
+enum PixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum PixelFormat * fmt);
+
+int avcodec_thread_init(AVCodecContext *s, int thread_count);
+void avcodec_thread_free(AVCodecContext *s);
+int avcodec_thread_execute(AVCodecContext *s, int (*func)(AVCodecContext *c2, void *arg2),void **arg, int *ret, int count);
+int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2),void **arg, int *ret, int count);
+//FIXME func typedef
+
+/**
+ * Initializes the AVCodecContext to use the given AVCodec. Prior to using this
+ * function the context has to be allocated.
+ *
+ * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),
+ * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for
+ * retrieving a codec.
+ *
+ * @warning This function is not thread safe!
+ *
+ * @code
+ * avcodec_register_all();
+ * codec = avcodec_find_decoder(CODEC_ID_H264);
+ * if (!codec)
+ *     exit(1);
+ *
+ * context = avcodec_alloc_context();
+ *
+ * if (avcodec_open(context, codec) < 0)
+ *     exit(1);
+ * @endcode
+ *
+ * @param avctx The context which will be set up to use the given codec.
+ * @param codec The codec to use within the context.
+ * @return zero on success, a negative value on error
+ * @see avcodec_alloc_context, avcodec_find_decoder, avcodec_find_encoder
+ */
+int avcodec_open(AVCodecContext *avctx, AVCodec *codec);
+
+/**
+ * @deprecated Use avcodec_decode_audio2() instead.
+ */
+attribute_deprecated int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
+                         int *frame_size_ptr,
+                         uint8_t *buf, int buf_size);
+
+/**
+ * Decodes an audio frame from \p buf into \p samples.
+ * The avcodec_decode_audio2() function decodes an audio frame from the input
+ * buffer \p buf of size \p buf_size. To decode it, it makes use of the
+ * audio codec which was coupled with \p avctx using avcodec_open(). The
+ * resulting decoded frame is stored in output buffer \p samples.  If no frame
+ * could be decompressed, \p frame_size_ptr is zero. Otherwise, it is the
+ * decompressed frame size in \e bytes.
+ *
+ * @warning You \e must set \p frame_size_ptr to the allocated size of the
+ * output buffer before calling avcodec_decode_audio2().
+ *
+ * @warning The input buffer must be \c FF_INPUT_BUFFER_PADDING_SIZE larger than
+ * the actual read bytes because some optimized bitstream readers read 32 or 64
+ * bits at once and could read over the end.
+ *
+ * @warning The end of the input buffer \p buf should be set to 0 to ensure that
+ * no overreading happens for damaged MPEG streams.
+ *
+ * @note You might have to align the input buffer \p buf and output buffer \p
+ * samples. The alignment requirements depend on the CPU: On some CPUs it isn't
+ * necessary at all, on others it won't work at all if not aligned and on others
+ * it will work but it will have an impact on performance. In practice, the
+ * bitstream should have 4 byte alignment at minimum and all sample data should
+ * be 16 byte aligned unless the CPU doesn't need it (AltiVec and SSE do). If
+ * the linesize is not a multiple of 16 then there's no sense in aligning the
+ * start of the buffer to 16.
+ *
+ * @param avctx the codec context
+ * @param[out] samples the output buffer
+ * @param[in,out] frame_size_ptr the output buffer size in bytes
+ * @param[in] buf the input buffer
+ * @param[in] buf_size the input buffer size in bytes
+ * @return On error a negative value is returned, otherwise the number of bytes
+ * used or zero if no frame could be decompressed.
+ */
+int avcodec_decode_audio2(AVCodecContext *avctx, int16_t *samples,
+                         int *frame_size_ptr,
+                         uint8_t *buf, int buf_size);
+
+/**
+ * Decodes a video frame from \p buf into \p picture.
+ * The avcodec_decode_video() function decodes a video frame from the input
+ * buffer \p buf of size \p buf_size. To decode it, it makes use of the
+ * video codec which was coupled with \p avctx using avcodec_open(). The
+ * resulting decoded frame is stored in \p picture.
+ *
+ * @warning The input buffer must be \c FF_INPUT_BUFFER_PADDING_SIZE larger than
+ * the actual read bytes because some optimized bitstream readers read 32 or 64
+ * bits at once and could read over the end.
+ *
+ * @warning The end of the input buffer \p buf should be set to 0 to ensure that
+ * no overreading happens for damaged MPEG streams.
+ *
+ * @note You might have to align the input buffer \p buf and output buffer \p
+ * samples. The alignment requirements depend on the CPU: on some CPUs it isn't
+ * necessary at all, on others it won't work at all if not aligned and on others
+ * it will work but it will have an impact on performance. In practice, the
+ * bitstream should have 4 byte alignment at minimum and all sample data should
+ * be 16 byte aligned unless the CPU doesn't need it (AltiVec and SSE do). If
+ * the linesize is not a multiple of 16 then there's no sense in aligning the
+ * start of the buffer to 16.
+ *
+ * @param avctx the codec context
+ * @param[out] picture The AVFrame in which the decoded video frame will be stored.
+ * @param[in] buf the input buffer
+ * @param[in] buf_size the size of the input buffer in bytes
+ * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.
+ * @return On error a negative value is returned, otherwise the number of bytes
+ * used or zero if no frame could be decompressed.
+ */
+int avcodec_decode_video(AVCodecContext *avctx, AVFrame *picture,
+                         int *got_picture_ptr,
+                         uint8_t *buf, int buf_size);
+
+/* Decode a subtitle message. Return -1 if error, otherwise return the
+ * number of bytes used. If no subtitle could be decompressed,
+ * got_sub_ptr is zero. Otherwise, the subtitle is stored in *sub. */
+int avcodec_decode_subtitle(AVCodecContext *avctx, AVSubtitle *sub,
+                            int *got_sub_ptr,
+                            const uint8_t *buf, int buf_size);
+int avcodec_parse_frame(AVCodecContext *avctx, uint8_t **pdata,
+                        int *data_size_ptr,
+                        uint8_t *buf, int buf_size);
+
+/**
+ * Encodes an audio frame from \p samples into \p buf.
+ * The avcodec_encode_audio() function encodes an audio frame from the input
+ * buffer \p samples. To encode it, it makes use of the audio codec which was
+ * coupled with \p avctx using avcodec_open(). The resulting encoded frame is
+ * stored in output buffer \p buf.
+ *
+ * @note The output buffer should be at least \c FF_MIN_BUFFER_SIZE bytes large.
+ *
+ * @param avctx the codec context
+ * @param[out] buf the output buffer
+ * @param[in] buf_size the output buffer size
+ * @param[in] samples the input buffer containing the samples
+ * @return On error a negative value is returned, on succes zero or the number
+ * of bytes used from the input buffer.
+ */
+int avcodec_encode_audio(AVCodecContext *avctx, uint8_t *buf, int buf_size,
+                         const short *samples);
+
+/**
+ * Encodes a video frame from \p pict into \p buf.
+ * The avcodec_encode_video() function encodes a video frame from the input
+ * \p pict. To encode it, it makes use of the video codec which was coupled with
+ * \p avctx using avcodec_open(). The resulting encoded bytes representing the
+ * frame are stored in the output buffer \p buf. The input picture should be
+ * stored using a specific format, namely \c avctx.pix_fmt.
+ *
+ * @param avctx the codec context
+ * @param[out] buf the output buffer for the bitstream of encoded frame
+ * @param[in] buf_size the size of the output buffer in bytes
+ * @param[in] pict the input picture to encode
+ * @return On error a negative value is returned, on success zero or the number
+ * of bytes used from the input buffer.
+ */
+int avcodec_encode_video(AVCodecContext *avctx, uint8_t *buf, int buf_size,
+                         const AVFrame *pict);
+int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size,
+                            const AVSubtitle *sub);
+
+int avcodec_close(AVCodecContext *avctx);
+
+void avcodec_register_all(void);
+
+/**
+ * Flush buffers, should be called when seeking or when switching to a different stream.
+ */
+void avcodec_flush_buffers(AVCodecContext *avctx);
+
+void avcodec_default_free_buffers(AVCodecContext *s);
+
+/* misc useful functions */
+
+/**
+ * Returns a single letter to describe the given picture type \p pict_type.
+ *
+ * @param[in] pict_type the picture type
+ * @return A single character representing the picture type.
+ */
+char av_get_pict_type_char(int pict_type);
+
+/**
+ * Returns codec bits per sample.
+ *
+ * @param[in] codec_id the codec
+ * @return Number of bits per sample or zero if unknown for the given codec.
+ */
+int av_get_bits_per_sample(enum CodecID codec_id);
+
+/**
+ * Returns sample format bits per sample.
+ *
+ * @param[in] sample_fmt the sample format
+ * @return Number of bits per sample or zero if unknown for the given sample format.
+ */
+int av_get_bits_per_sample_format(enum SampleFormat sample_fmt);
+
+/* frame parsing */
+typedef struct AVCodecParserContext {
+    void *priv_data;
+    struct AVCodecParser *parser;
+    int64_t frame_offset; /* offset of the current frame */
+    int64_t cur_offset; /* current offset
+                           (incremented by each av_parser_parse()) */
+    int64_t last_frame_offset; /* offset of the last frame */
+    /* video info */
+    int pict_type; /* XXX: Put it back in AVCodecContext. */
+    int repeat_pict; /* XXX: Put it back in AVCodecContext. */
+    int64_t pts;     /* pts of the current frame */
+    int64_t dts;     /* dts of the current frame */
+
+    /* private data */
+    int64_t last_pts;
+    int64_t last_dts;
+    int fetch_timestamp;
+
+#define AV_PARSER_PTS_NB 4
+    int cur_frame_start_index;
+    int64_t cur_frame_offset[AV_PARSER_PTS_NB];
+    int64_t cur_frame_pts[AV_PARSER_PTS_NB];
+    int64_t cur_frame_dts[AV_PARSER_PTS_NB];
+
+    int flags;
+#define PARSER_FLAG_COMPLETE_FRAMES           0x0001
+
+    int64_t offset;      ///< byte offset from starting packet start
+    int64_t last_offset;
+} AVCodecParserContext;
+
+typedef struct AVCodecParser {
+    int codec_ids[5]; /* several codec IDs are permitted */
+    int priv_data_size;
+    int (*parser_init)(AVCodecParserContext *s);
+    int (*parser_parse)(AVCodecParserContext *s,
+                        AVCodecContext *avctx,
+                        const uint8_t **poutbuf, int *poutbuf_size,
+                        const uint8_t *buf, int buf_size);
+    void (*parser_close)(AVCodecParserContext *s);
+    int (*split)(AVCodecContext *avctx, const uint8_t *buf, int buf_size);
+    struct AVCodecParser *next;
+} AVCodecParser;
+
+extern AVCodecParser *av_first_parser;
+
+void av_register_codec_parser(AVCodecParser *parser);
+AVCodecParserContext *av_parser_init(int codec_id);
+int av_parser_parse(AVCodecParserContext *s,
+                    AVCodecContext *avctx,
+                    uint8_t **poutbuf, int *poutbuf_size,
+                    const uint8_t *buf, int buf_size,
+                    int64_t pts, int64_t dts);
+int av_parser_change(AVCodecParserContext *s,
+                     AVCodecContext *avctx,
+                     uint8_t **poutbuf, int *poutbuf_size,
+                     const uint8_t *buf, int buf_size, int keyframe);
+void av_parser_close(AVCodecParserContext *s);
+
+
+typedef struct AVBitStreamFilterContext {
+    void *priv_data;
+    struct AVBitStreamFilter *filter;
+    AVCodecParserContext *parser;
+    struct AVBitStreamFilterContext *next;
+} AVBitStreamFilterContext;
+
+
+typedef struct AVBitStreamFilter {
+    const char *name;
+    int priv_data_size;
+    int (*filter)(AVBitStreamFilterContext *bsfc,
+                  AVCodecContext *avctx, const char *args,
+                  uint8_t **poutbuf, int *poutbuf_size,
+                  const uint8_t *buf, int buf_size, int keyframe);
+    void (*close)(AVBitStreamFilterContext *bsfc);
+    struct AVBitStreamFilter *next;
+} AVBitStreamFilter;
+
+void av_register_bitstream_filter(AVBitStreamFilter *bsf);
+AVBitStreamFilterContext *av_bitstream_filter_init(const char *name);
+int av_bitstream_filter_filter(AVBitStreamFilterContext *bsfc,
+                               AVCodecContext *avctx, const char *args,
+                               uint8_t **poutbuf, int *poutbuf_size,
+                               const uint8_t *buf, int buf_size, int keyframe);
+void av_bitstream_filter_close(AVBitStreamFilterContext *bsf);
+
+
+/* memory */
+
+/**
+ * Reallocates the given block if it is not large enough, otherwise it
+ * does nothing.
+ *
+ * @see av_realloc
+ */
+void *av_fast_realloc(void *ptr, unsigned int *size, unsigned int min_size);
+
+/* for static data only */
+
+/**
+ * Frees all static arrays and resets their pointers to 0.
+ * Call this function to release all statically allocated tables.
+ *
+ * @deprecated. Code which uses av_free_static is broken/misdesigned
+ * and should correctly use static arrays
+ *
+ */
+attribute_deprecated void av_free_static(void);
+
+/**
+ * Allocation of static arrays.
+ *
+ * @warning Do not use for normal allocation.
+ *
+ * @param[in] size The amount of memory you need in bytes.
+ * @return block of memory of the requested size
+ * @deprecated. Code which uses av_mallocz_static is broken/misdesigned
+ * and should correctly use static arrays
+ */
+attribute_deprecated void *av_mallocz_static(unsigned int size);
+
+/**
+ * Copy image 'src' to 'dst'.
+ */
+void av_picture_copy(AVPicture *dst, const AVPicture *src,
+              int pix_fmt, int width, int height);
+
+/**
+ * Crop image top and left side.
+ */
+int av_picture_crop(AVPicture *dst, const AVPicture *src,
+             int pix_fmt, int top_band, int left_band);
+
+/**
+ * Pad image.
+ */
+int av_picture_pad(AVPicture *dst, const AVPicture *src, int height, int width, int pix_fmt,
+            int padtop, int padbottom, int padleft, int padright, int *color);
+
+#if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)
+/**
+ * @deprecated Use the software scaler (swscale) instead.
+ */
+attribute_deprecated void img_copy(AVPicture *dst, const AVPicture *src,
+              int pix_fmt, int width, int height);
+
+/**
+ * @deprecated Use the software scaler (swscale) instead.
+ */
+attribute_deprecated int img_crop(AVPicture *dst, const AVPicture *src,
+             int pix_fmt, int top_band, int left_band);
+
+/**
+ * @deprecated Use the software scaler (swscale) instead.
+ */
+attribute_deprecated int img_pad(AVPicture *dst, const AVPicture *src, int height, int width, int pix_fmt,
+            int padtop, int padbottom, int padleft, int padright, int *color);
+#endif
+
+extern unsigned int av_xiphlacing(unsigned char *s, unsigned int v);
+
+/**
+ * Parses \p str and put in \p width_ptr and \p height_ptr the detected values.
+ *
+ * @return 0 in case of a successful parsing, a negative value otherwise
+ * @param[in] str the string to parse: it has to be a string in the format
+ * <width>x<height> or a valid video frame size abbreviation.
+ * @param[in,out] width_ptr pointer to the variable which will contain the detected
+ * frame width value
+ * @param[in,out] height_ptr pointer to the variable which will contain the detected
+ * frame height value
+ */
+int av_parse_video_frame_size(int *width_ptr, int *height_ptr, const char *str);
+
+/**
+ * Parses \p str and put in \p frame_rate the detected values.
+ *
+ * @return 0 in case of a successful parsing, a negative value otherwise
+ * @param[in] str the string to parse: it has to be a string in the format
+ * <frame_rate_nom>/<frame_rate_den>, a float number or a valid video rate abbreviation
+ * @param[in,out] frame_rate pointer to the AVRational which will contain the detected
+ * frame rate
+ */
+int av_parse_video_frame_rate(AVRational *frame_rate, const char *str);
+
+/* error handling */
+#if EINVAL > 0
+#define AVERROR(e) (-(e)) /**< Returns a negative error code from a POSIX error code, to return from library functions. */
+#define AVUNERROR(e) (-(e)) /**< Returns a POSIX error code from a library function error return value. */
+#else
+/* Some platforms have E* and errno already negated. */
+#define AVERROR(e) (e)
+#define AVUNERROR(e) (e)
+#endif
+#define AVERROR_UNKNOWN     AVERROR(EINVAL)  /**< unknown error */
+#define AVERROR_IO          AVERROR(EIO)     /**< I/O error */
+#define AVERROR_NUMEXPECTED AVERROR(EDOM)    /**< Number syntax expected in filename. */
+#define AVERROR_INVALIDDATA AVERROR(EINVAL)  /**< invalid data found */
+#define AVERROR_NOMEM       AVERROR(ENOMEM)  /**< not enough memory */
+#define AVERROR_NOFMT       AVERROR(EILSEQ)  /**< unknown format */
+#define AVERROR_NOTSUPP     AVERROR(ENOSYS)  /**< Operation not supported. */
+#define AVERROR_NOENT       AVERROR(ENOENT)  /**< No such file or directory. */
+#define AVERROR_PATCHWELCOME    -MKTAG('P','A','W','E') /**< Not yet implemented in FFmpeg. Patches welcome. */
+
+#endif /* AVCODEC_H */
diff -ruN mplayer.orig/libavcodec/eac3dec.c mplayer.eac3/libavcodec/eac3dec.c
--- mplayer.orig/libavcodec/eac3dec.c	1970-01-01 03:00:00.000000000 +0300
+++ mplayer.eac3/libavcodec/eac3dec.c	2007-10-19 14:13:32.000000000 +0300
@@ -0,0 +1,1463 @@
+/*
+ * EAC3 decoder
+ * Copyright (c) 2007 Bartlomiej Wolowiec <bartek.wolowiec@gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avcodec.h"
+#include "eac3.h"
+#include "ac3dec.h"
+#include "ac3.h"
+
+/**
+ * Table for default stereo downmixing coefficients
+ * reference: Section 7.8.2 Downmixing Into Two Channels
+ */
+static const uint8_t eac3_default_coeffs[8][5][2] = {
+    { { 2, 7 }, { 7, 2 },                               },
+    { { 4, 4 },                                         },
+    { { 2, 7 }, { 7, 2 },                               },
+    { { 2, 7 }, { 5, 5 }, { 7, 2 },                     },
+    { { 2, 7 }, { 7, 2 }, { 6, 6 },                     },
+    { { 2, 7 }, { 5, 5 }, { 7, 2 }, { 8, 8 },           },
+    { { 2, 7 }, { 7, 2 }, { 6, 7 }, { 7, 6 },           },
+    { { 2, 7 }, { 5, 5 }, { 7, 2 }, { 6, 7 }, { 7, 6 }, },
+};
+
+static const float mixlevels[9] = {
+    LEVEL_PLUS_3DB,
+    LEVEL_PLUS_1POINT5DB,
+    LEVEL_ONE,
+    LEVEL_MINUS_1POINT5DB,
+    LEVEL_MINUS_3DB,
+    LEVEL_MINUS_4POINT5DB,
+    LEVEL_MINUS_6DB,
+    LEVEL_ZERO,
+    LEVEL_MINUS_9DB
+};
+
+static void log_missing_feature(AVCodecContext *avctx, const char *log){
+    av_log(avctx, AV_LOG_ERROR, "%s is not implemented. If you want to help, "
+            "update your FFmpeg version to the newest one from SVN. If the "
+            "problem still occurs, it means that your file has extension "
+            "which has not been tested due to a lack of samples exhibiting "
+            "this feature. Upload a sample of the audio from this file to "
+            "ftp://upload.mplayerhq.hu/incoming and contact the ffmpeg-devel "
+            "mailing list.\n", log);
+}
+
+static void uncouple_channels(EAC3Context *s){
+    int i, j, ch, bnd, subbnd;
+
+    subbnd = s->cplbegf+1;
+    i = s->strtmant[CPL_CH];
+    for (bnd = 0; bnd < s->ncplbnd; bnd++) {
+        do {
+            for (j = 0; j < 12; j++) {
+                for (ch = 1; ch <= s->nfchans; ch++) {
+                    if (s->chincpl[ch]) {
+                        s->transform_coeffs[ch][i] =
+                            s->transform_coeffs[CPL_CH][i] *
+                            s->cplco[ch][bnd] * 8.0f;
+                    }
+                }
+                i++;
+            }
+        } while(s->cplbndstrc[subbnd++] && subbnd<=s->cplendf);
+    }
+}
+
+static void spectral_extension(EAC3Context *s){
+    //Now turned off, because there are no samples for testing it.
+#if 0
+    int copystartmant, copyendmant, copyindex, insertindex;
+    int wrapflag[18];
+    int bandsize, bnd, bin, spxmant, filtbin, ch;
+    float nratio, accum, nscale, sscale, spxcotemp;
+    float noffset[AC3_MAX_CHANNELS], nblendfact[AC3_MAX_CHANNELS][18], sblendfact[AC3_MAX_CHANNELS][18];
+    float rmsenergy[AC3_MAX_CHANNELS][18];
+
+    //XXX spxbandtable[bnd] = 25 + 12 * bnd ?
+
+    copystartmant = spxbandtable[s->spxstrtf];
+    copyendmant = spxbandtable[s->spxbegf];
+
+    for (ch = 1; ch <= s->nfchans; ch++) {
+        if (!s->chinspx[ch])
+            continue;
+
+        copyindex = copystartmant;
+        insertindex = copyendmant;
+
+        for (bnd = 0; bnd < s->nspxbnds; bnd++){
+            bandsize = s->spxbndsztab[bnd];
+            if ((copyindex + bandsize) > copyendmant) {
+                copyindex = copystartmant;
+                wrapflag[bnd] = 1;
+            } else
+                wrapflag[bnd] = 0;
+            for (bin = 0; bin < bandsize; bin++){
+                if (copyindex == copyendmant)
+                    copyindex = copystartmant;
+                s->transform_coeffs[ch][insertindex++] = s->transform_coeffs[ch][copyindex++];
+            }
+        }
+
+        noffset[ch] = s->spxblnd[ch] / 32.0;
+        spxmant = spxbandtable[s->spxbegf];
+        if (s->spxcoe[ch]) {
+            for (bnd = 0; bnd < s->nspxbnds; bnd++){
+                bandsize = s->spxbndsztab[bnd];
+                nratio = ((spxmant + 0.5*bandsize) / spxbandtable[s->spxendf]) - noffset[ch];
+                if (nratio < 0.0)
+                    nratio = 0.0;
+                else
+                    if (nratio > 1.0)
+                        nratio = 1.0;
+                nblendfact[ch][bnd] = sqrt(nratio);
+                sblendfact[ch][bnd] = sqrt(1 - nratio);
+                spxmant += bandsize;
+            }
+        }
+
+        spxmant = spxbandtable[s->spxbegf];
+        for (bnd = 0; bnd < s->nspxbnds; bnd++){
+            bandsize = s->spxbndsztab[bnd];
+            accum = 0;
+            for (bin = 0; bin < bandsize; bin++){
+                accum += (s->transform_coeffs[ch][spxmant] * s->transform_coeffs[ch][spxmant]);
+                spxmant++;
+            }
+            rmsenergy[ch][bnd] = sqrt(accum / bandsize);
+        }
+
+        if (s->chinspxatten[ch]) {
+            /* apply notch filter at baseband / extension region border */
+            filtbin = spxbandtable[s->spxbegf] - 2;
+            for (bin = 0; bin < 3; bin++){
+                s->transform_coeffs[ch][filtbin] *= ff_eac3_spxattentab[s->spxattencod[ch]][bin];
+                filtbin++;
+            }
+            for (bin = 1; bin >= 0; bin--){
+                s->transform_coeffs[ch][filtbin] *= ff_eac3_spxattentab[s->spxattencod[ch]][bin];
+                filtbin++;
+            }
+            filtbin += s->spxbndsztab[0];
+            /* apply notch at all other wrap points */
+            for (bnd = 1; bnd < s->nspxbnds; bnd++){
+                if (wrapflag[bnd]) {
+                    filtbin = filtbin - 5;
+                    for (bin = 0; bin < 3; bin++){
+                        s->transform_coeffs[ch][filtbin] *= ff_eac3_spxattentab[s->spxattencod[ch]][bin];
+                        filtbin++;
+                    }
+                    for (bin = 1; bin >= 0; bin--){
+                        s->transform_coeffs[ch][filtbin] *= ff_eac3_spxattentab[s->spxattencod[ch]][bin];
+                        filtbin++;
+                    }
+                }
+                filtbin += s->spxbndsztab[bnd];
+            }
+        }
+
+        spxmant = spxbandtable[s->spxbegf];
+        for (bnd = 0; bnd < s->nspxbnds; bnd++){
+            nscale = rmsenergy[ch][bnd] * nblendfact[ch][bnd];
+            sscale = sblendfact[ch][bnd];
+            for (bin = 0; bin < s->spxbndsztab[bnd]; bin++){
+                //TODO generate noise()
+                s->transform_coeffs[ch][spxmant] =
+                    s->transform_coeffs[ch][spxmant] * sscale + noise() * nscale;
+                spxmant++;
+            }
+        }
+
+        spxmant = spxbandtable[s->spxbegf];
+        for (bnd = 0; bnd < s->nspxbnds; bnd++){
+            spxcotemp = s->spxco[ch][bnd];
+            for (bin = 0; bin < s->spxbndsztab[bnd]; bin++){
+                s->transform_coeffs[ch][spxmant] *= spxcotemp * 32;
+                spxmant++;
+            }
+        }
+    }
+#endif
+}
+
+static void get_transform_coeffs_aht_ch(GetBitContext *gbc, EAC3Context *s, int ch){
+    int endbap, bin, n, m;
+    int bg, g, bits, pre_chmant, remap, chgaqsections, chgaqmod;
+    float mant;
+
+    chgaqmod = get_bits(gbc, 2);
+
+    endbap = chgaqmod<2?12:17;
+
+    chgaqsections = 0;
+    for (bin = 0; bin < s->endmant[ch]; bin++) {
+        if (s->hebap[ch][bin] > 7 && s->hebap[ch][bin] < endbap)
+            chgaqsections++;
+    }
+
+    if (chgaqmod == EAC3_GAQ_12 || chgaqmod == EAC3_GAQ_14) {
+        for (n = 0; n < chgaqsections; n++) {
+            s->chgaqgain[n] = get_bits1(gbc);
+        }
+    } else {
+        if (chgaqmod == EAC3_GAQ_124) {
+            int grpgain;
+            chgaqsections = (chgaqsections+2)/3;
+            for (n = 0; n < chgaqsections; n++) {
+                grpgain = get_bits(gbc, 5);
+                s->chgaqgain[3*n]   = grpgain/9;
+                s->chgaqgain[3*n+1] = (grpgain%9)/3;
+                s->chgaqgain[3*n+2] = grpgain%3;
+            }
+        }
+    }
+
+    m=0;
+    for (bin = s->strtmant[ch]; bin < s->endmant[ch]; bin++) {
+        if (s->hebap[ch][bin] > 7) {
+            // GAQ (E3.3.4.2)
+            // XXX what about gaqmod = 0 ?
+            // difference between Gk=1 and gaqmod=0 ?
+            if (s->hebap[ch][bin] < endbap) {
+                // hebap in active range
+                // Gk = 1<<bg
+                bg = ff_gaq_gk[chgaqmod][s->chgaqgain[m++]];
+            } else {
+                bg = 0;
+            }
+            bits = ff_bits_vs_hebap[s->hebap[ch][bin]];
+
+            for (n = 0; n < 6; n++) {
+                // pre_chmant[n][ch][bin]
+                pre_chmant = get_sbits(gbc, bits-bg);
+                if (bg && pre_chmant == -(1 << (bits - bg - 1))) {
+                    // large mantissa
+                    pre_chmant = get_sbits(gbc, bits - ((bg==1)?1:0));
+                    if (bg == 1)
+                        //Gk = 2
+                        mant = (float)pre_chmant/((1<<(bits-1))-1);
+                    else
+                        //Gk = 4
+                        mant = (float)pre_chmant*3.0f/((1<<(bits+1))-2);
+
+                    g = 0;
+                    remap = 1;
+                } else {
+                    // small mantissa
+                    if (bg)
+                        //Gk = 2 or 4
+                        mant = (float)pre_chmant/((1<<(bits-1))-1);
+                    else
+                        //Gk = 1
+                        mant = (float)pre_chmant*2.0f/((1<<bits)-1); ///XXX
+
+                    g = bg;
+                    remap = (!bg) && (s->hebap[ch][bin] < endbap);
+                }
+
+                //TODO when remap needed ?
+                if (remap) {
+                    mant = (float)
+                        (ff_eac3_gaq_remap[s->hebap[ch][bin]-8][0][g][0]/32768.0f + 1.0f)
+                        * mant / (1<<g) +
+                        (ff_eac3_gaq_remap[s->hebap[ch][bin]-8][mant<0][g][1]) / 32768.0f;
+                }
+                s->pre_chmant[n][ch][bin] = mant;
+            }
+        } else {
+            // hebap = 0 or VQ
+            if (s->hebap[ch][bin]) {
+                pre_chmant = get_bits(gbc, ff_bits_vs_hebap[s->hebap[ch][bin]]);
+                for (n = 0; n < 6; n++) {
+                    s->pre_chmant[n][ch][bin] =
+                        ff_vq_hebap[s->hebap[ch][bin]][pre_chmant][n] / 32768.0f;
+                }
+            } else {
+                for (n = 0; n < 6; n++) {
+                    s->pre_chmant[n][ch][bin] = 0;
+                }
+            }
+        }
+    }
+}
+
+static void idct_transform_coeffs_ch(EAC3Context *s, int ch, int blk){
+    // TODO fast IDCT
+    int bin, i;
+    float tmp;
+    for (bin = s->strtmant[ch]; bin < s->endmant[ch]; bin++) {
+        tmp = 0;
+        for (i = 0; i < 6; i++) {
+            tmp += (i?sqrt(2):1) * s->pre_chmant[i][ch][bin] * cos(M_PI*i*(2*blk + 1)/12);
+        }
+        s->transform_coeffs[ch][bin] = tmp * ff_ac3_scale_factors[s->dexps[ch][bin]];
+    }
+}
+
+static void get_eac3_transform_coeffs_ch(GetBitContext *gbc, EAC3Context *s, int blk,
+        int ch, mant_groups *m){
+    if (s->chahtinu[ch] == 0) {
+        ff_ac3_get_transform_coeffs_ch(m, gbc, s->dexps[ch], s->bap[ch],
+                s->transform_coeffs[ch], s->strtmant[ch], s->endmant[ch],
+                &s->dith_state);
+    } else {
+        if (s->chahtinu[ch] == 1) {
+            get_transform_coeffs_aht_ch(gbc, s, ch);
+            s->chahtinu[ch] = -1; /* AHT info for this frame has been read - do not read again */
+        }
+    }
+    if (s->chahtinu[ch] != 0) {
+        idct_transform_coeffs_ch(s, ch, blk);
+    }
+}
+
+static int parse_bsi(GetBitContext *gbc, EAC3Context *s){
+    int i, blk;
+
+    s->strmtyp = get_bits(gbc, 2);
+    if (s->strmtyp) {
+        log_missing_feature(s->avctx, "Dependent substream");
+        return -1;
+    }
+    s->substreamid = get_bits(gbc, 3);
+    s->frmsiz = get_bits(gbc, 11);
+    s->fscod = get_bits(gbc, 2);
+    if (s->fscod == 3) {
+        log_missing_feature(s->avctx, "Reduced Sampling Rates");
+        return -1;
+#if 0
+        s->fscod2 = get_bits(gbc, 2);
+        s->numblkscod = 3; /* six blocks per frame */
+#endif
+    } else {
+        s->numblkscod = get_bits(gbc, 2);
+    }
+    s->acmod = get_bits(gbc, 3);
+    s->lfeon = get_bits1(gbc);
+
+    // calculate number of channels
+    s->nfchans = ff_ac3_channels[s->acmod];
+    s->num_channels = s->nfchans;
+    s->lfe_channel = s->num_channels+1;
+    if (s->lfeon) {
+        s->strtmant[s->lfe_channel] = 0;
+        s->endmant [s->lfe_channel] = 7;
+        s->nchgrps [s->lfe_channel] = 2;
+        s->chincpl [s->lfe_channel] = 0;
+        s->num_channels++;
+    }
+
+    s->bsid = get_bits(gbc, 5);
+    if (s->bsid < 11 || s->bsid > 16) {
+        av_log(s->avctx, AV_LOG_ERROR, "bsid should be between 11 and 16\n");
+        return -1;
+    }
+
+    for (i = 0; i < (s->acmod ? 1 : 2); i++) {
+        s->dialnorm[i] = ff_ac3_dialnorm_tbl[get_bits(gbc, 5)];
+        if (get_bits1(gbc)) {
+            skip_bits(gbc, 8); //skip Compression gain word
+        }
+    }
+    if (s->strmtyp == 1) {
+        /* if dependent stream */
+        if (get_bits1(gbc)) {
+            s->chanmap = get_bits(gbc, 16);
+        } else {
+            //TODO default channel map based on acmod and lfeon
+        }
+    }
+
+    /* set stereo downmixing coefficients
+       reference: Section 7.8.2 Downmixing Into Two Channels */
+    for (i = 0; i < s->nfchans; i++) {
+        s->downmix_coeffs[i][0] = mixlevels[eac3_default_coeffs[s->acmod][i][0]];
+        s->downmix_coeffs[i][1] = mixlevels[eac3_default_coeffs[s->acmod][i][1]];
+    }
+
+    s->mixmdate = get_bits1(gbc);
+    if (s->mixmdate) {
+        /* Mixing metadata */
+        if (s->acmod > 2) {
+            /* if more than 2 channels */
+            s->dmixmod = get_bits(gbc, 2);
+        }
+        if ((s->acmod & 1) && (s->acmod > 2)) {
+            /* if three front channels exist */
+            skip_bits(gbc, 3); //skip Lt/Rt center mix level
+            s->downmix_coeffs[1][0] = s->downmix_coeffs[1][1] = mixlevels[get_bits(gbc, 3)];
+        }
+        if (s->acmod & 4) {
+            /* if a surround channel exists */
+            float surmixlev;
+            skip_bits(gbc, 3); //skip Lt/Rt surround mix level
+            surmixlev = mixlevels[get_bits(gbc, 3)];
+            if (s->acmod & 2) {
+                //two surround channels
+                s->downmix_coeffs[s->acmod-4][0] = s->downmix_coeffs[s->acmod-3][1] =
+                    surmixlev;
+            } else {
+                s->downmix_coeffs[s->acmod-2][0] = s->downmix_coeffs[s->acmod-2][1] =
+                    surmixlev * LEVEL_MINUS_3DB;
+            }
+        }
+        if (s->lfeon) {
+            /* if the LFE channel exists */
+            s->lfemixlevcode = get_bits1(gbc);
+            if (s->lfemixlevcode) {
+                s->lfemixlevcod = get_bits(gbc, 5);
+            }
+        }
+        if (!s->strmtyp) {
+            /* if independent stream */
+            for (i = 0; i < (s->acmod ? 1 : 2); i++) {
+                if (get_bits1(gbc)) {
+                    s->pgmscl[i] = get_bits(gbc, 6);
+                } else {
+                    //TODO program scale factor = 0dB
+                }
+            }
+            if (get_bits1(gbc)) {
+                s->extpgmscl = get_bits(gbc, 6);
+            }
+            s->mixdef = get_bits(gbc, 2);
+            if (s->mixdef == 1) {
+                /* mixing option 2 */
+                skip_bits(gbc, 5);
+            } else {
+                if (s->mixdef == 2) {
+                    /* mixing option 3 */
+                    skip_bits(gbc, 12);
+                } else {
+                    if (s->mixdef == 3) {
+                        /* mixing option 4 */
+                        s->mixdeflen = get_bits(gbc, 5);
+                        skip_bits(gbc, 8*(s->mixdeflen+2));
+                    }
+                }
+                if (s->acmod < 2) {
+                    /* if mono or dual mono source */
+                    for (i = 0; i < (s->acmod ? 1 : 2); i++) {
+                        if (get_bits1(gbc)) {
+                            s->paninfo[i] = get_bits(gbc, 14);
+                        } else {
+                            //TODO default = center
+                        }
+                    }
+                }
+                s->frmmixcfginfoe = get_bits1(gbc);
+                if (s->frmmixcfginfoe) {
+                    /* mixing configuration information */
+                    if (!s->numblkscod) {
+                        s->blkmixcfginfo[0] = get_bits(gbc, 5);
+                    } else {
+                        for (blk = 0; blk < ff_eac3_blocks[s->numblkscod]; blk++) {
+                            if (get_bits1(gbc)) {
+                                s->blkmixcfginfo[blk] = get_bits(gbc, 5);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    s->infomdate = get_bits1(gbc);
+    if (s->infomdate) {
+        /* Informational metadata */
+        skip_bits(gbc, 3); //skip Bit stream mode
+        skip_bits(gbc, 2); //skip copyright bit and original bitstream bit
+        if (s->acmod == AC3_ACMOD_STEREO) { /* if in 2/0 mode */
+            skip_bits(gbc, 4); //skip Dolby surround and headphone mode
+        }
+        if (s->acmod >= 6) {
+            /* if both surround channels exist */
+            skip_bits(gbc, 2); //skip Dolby surround EX mode
+        }
+        for (i = 0; i < (s->acmod ? 1 : 2); i++) {
+            if (get_bits1(gbc)) {
+                skip_bits(gbc, 8); //skip Mix level, Room type and A/D converter type
+            }
+        }
+        if (s->fscod < 3) {
+            /* if not half sample rate */
+            skip_bits1(gbc); //skip Source sample rate code
+        }
+    }
+    if ((!s->strmtyp) && (s->numblkscod != 3)) {
+        skip_bits1(gbc); //converter synchronization flag
+    }
+    if (s->strmtyp == 2) {
+        /* if bit stream converted from AC-3 */
+        if (s->numblkscod == 3 || get_bits1(gbc)) {
+            /* 6 blocks per frame */
+            skip_bits(gbc, 6); // skip Frame size code
+        }
+    }
+    if (get_bits1(gbc)) {
+        int addbsil = get_bits(gbc, 6);
+        for (i = 0; i < addbsil + 1; i++) {
+            skip_bits(gbc, 8); // Additional bit stream information
+        }
+    }
+
+    return 0;
+} /* end of bsi */
+
+static int parse_audfrm(GetBitContext *gbc, EAC3Context *s){
+    int blk, ch;
+
+    /* Audio frame exist flags and strategy data */
+    if (s->numblkscod == 3) {
+        /* six blocks per frame */
+        /* LUT-based exponent strategy syntax */
+        s->expstre = get_bits1(gbc);
+        s->ahte = get_bits1(gbc);
+    } else {
+        /* AC-3 style exponent strategy syntax */
+        s->expstre = 1;
+        s->ahte = 0;
+    }
+    s->snroffststr = get_bits(gbc, 2);
+    s->transproce = get_bits1(gbc);
+    s->blkswe = get_bits1(gbc);
+    if (!s->blkswe) {
+        for (ch = 1; ch <= s->nfchans; ch++)
+            s->blksw[ch] = 0;
+    }
+    s->dithflage = get_bits1(gbc);
+    if (!s->dithflage) {
+        for (ch = 1; ch <= s->nfchans; ch++)
+            s->dithflag[ch] = 1; /* dither on */
+    }
+    s->dithflag[CPL_CH] = s->dithflag[s->lfe_channel] = 0;
+
+    /* frame-based syntax flags */
+    s->bamode = get_bits1(gbc);
+    s->frmfgaincode = get_bits1(gbc);
+    s->dbaflde = get_bits1(gbc);
+    s->skipflde = get_bits1(gbc);
+    s->spxattene = get_bits1(gbc);
+    /* Coupling data */
+    if (s->acmod > 1) {
+        s->cplstre[0] = 1;
+        s->cplinu[0] = get_bits1(gbc);
+        s->ncplblks = s->cplinu[0];
+        for (blk = 1; blk < ff_eac3_blocks[s->numblkscod]; blk++) {
+            s->cplstre[blk] = get_bits1(gbc);
+
+            if (s->cplstre[blk]) {
+                s->cplinu[blk] = get_bits1(gbc);
+            } else {
+                s->cplinu[blk] = s->cplinu[blk-1];
+            }
+            s->ncplblks += s->cplinu[blk];
+        }
+    } else {
+        memset(s->cplinu, 0, sizeof(int) * ff_eac3_blocks[s->numblkscod]);
+        s->ncplblks = 0;
+    }
+
+    /* Exponent strategy data */
+    if (s->expstre) {
+        /* AC-3 style exponent strategy syntax */
+        for (blk = 0; blk < ff_eac3_blocks[s->numblkscod]; blk++) {
+            for (ch = !s->cplinu[blk]; ch <= s->nfchans; ch++) {
+                s->chexpstr[blk][ch] = get_bits(gbc, 2);
+            }
+        }
+    } else {
+        /* LUT-based exponent strategy syntax */
+        int frmchexpstr;
+        /* cplexpstr[blk] and chexpstr[blk][ch] derived from table lookups. see Table E2.14 */
+        for (ch = !((s->acmod > 1) && (s->ncplblks)); ch <= s->nfchans; ch++) {
+            frmchexpstr = get_bits(gbc, 5);
+            for (blk = 0; blk < 6; blk++) {
+                s->chexpstr[blk][ch] = ff_eac3_frm_expstr[frmchexpstr][blk];
+            }
+        }
+    }
+    /* LFE exponent strategy */
+    if (s->lfeon) {
+        for (blk = 0; blk < ff_eac3_blocks[s->numblkscod]; blk++) {
+            s->chexpstr[blk][s->lfe_channel] = get_bits1(gbc);
+        }
+    }
+    /* Converter exponent strategy data */
+    if (!s->strmtyp) {
+        if (s->numblkscod == 3 || get_bits1(gbc)) {
+            for (ch = 1; ch <= s->nfchans; ch++) {
+                skip_bits(gbc, 5); //skip Converter channel exponent strategy
+            }
+        }
+    }
+    /* AHT data */
+    if (s->ahte) {
+        /* AHT is only available in 6 block mode (numblkscod ==3) */
+        /* coupling can use AHT only when coupling in use for all blocks */
+        /* ncplregs derived from cplstre and cplexpstr - see Section E3.3.2 */
+        int nchregs;
+        s->chahtinu[CPL_CH]=0;
+        for (ch = (s->ncplblks != 6); ch <= s->num_channels; ch++) {
+            nchregs = 0;
+            for (blk = 0; blk < 6; blk++)
+                nchregs += (s->chexpstr[blk][ch] != EXP_REUSE);
+            s->chahtinu[ch] = (nchregs == 1) && get_bits1(gbc);
+        }
+    } else {
+        for (ch = 0; ch <= s->num_channels; ch++)
+            s->chahtinu[ch] = 0;
+    }
+    /* Audio frame SNR offset data */
+    if (!s->snroffststr) {
+        int csnroffst = (get_bits(gbc, 6) - 15) << 4;
+        int snroffst = (csnroffst + get_bits(gbc, 4)) << 2;
+        for (ch = 0; ch <= s->num_channels; ch++)
+            s->snroffst[ch] = snroffst;
+    }
+    /* Audio frame transient pre-noise processing data */
+    if (s->transproce) {
+        av_log(s->avctx, AV_LOG_ERROR, "transient pre-noise processing NOT IMPLEMENTED\n");
+//        return -1;
+//#if 0
+        for (ch = 1; ch <= s->nfchans; ch++) {
+            s->chintransproc[ch] = get_bits1(gbc);
+            if (s->chintransproc[ch]) {
+                s->transprocloc[ch] = get_bits(gbc, 10);
+                s->transproclen[ch] = get_bits(gbc, 8);
+            }
+        }
+//#endif
+    }
+    /* Spectral extension attenuation data */
+    if (s->spxattene) {
+        for (ch = 1; ch <= s->nfchans; ch++) {
+            s->chinspxatten[ch] = get_bits1(gbc);
+            if (s->chinspxatten[ch]) {
+                s->spxattencod[ch] = get_bits(gbc, 5);
+            }
+        }
+    } else {
+        for (ch = 1; ch <= s->nfchans; ch++)
+            s->chinspxatten[ch]=0;
+    }
+    /* Block start information */
+    if (s->numblkscod && get_bits1(gbc)) {
+        /* nblkstrtbits determined from frmsiz (see Section E2.3.2.27) */
+        // nblkstrtbits = (numblks - 1) * (4 + ceiling (log2 (words_per_frame)))
+        // where numblks is derived from the numblkscod in Table E2.9
+        // words_per_frame = frmsiz + 1
+        int nblkstrtbits = (ff_eac3_blocks[s->numblkscod]-1) * (4 + (av_log2(s->frmsiz-1)+1) );
+        av_log(s->avctx, AV_LOG_INFO, "nblkstrtbits = %i\n", nblkstrtbits);
+        s->blkstrtinfo = get_bits(gbc, nblkstrtbits);
+    }
+    /* Syntax state initialization */
+    for (ch = 1; ch <= s->nfchans; ch++) {
+        s->firstspxcos[ch] = 1;
+        s->firstcplcos[ch] = 1;
+    }
+    s->firstcplleak = 1;
+
+    return 0;
+} /* end of audfrm */
+
+static int parse_audblk(GetBitContext *gbc, EAC3Context *s, const int blk){
+    //int grp, sbnd, n, bin;
+    int seg, bnd, ch, i, chbwcod, grpsize;
+    int got_cplchan;
+    mant_groups m;
+
+    m.b1ptr = m.b2ptr = m.b4ptr = 3;
+
+    /* Block switch and dither flags */
+    if (s->blkswe) {
+        for (ch = 1; ch <= s->nfchans; ch++) {
+            s->blksw[ch] = get_bits1(gbc);
+        }
+    }
+    if (s->dithflage) {
+        for (ch = 1; ch <= s->nfchans; ch++) {
+            s->dithflag[ch] = get_bits1(gbc);
+        }
+    }
+
+    /* Dynamic range control */
+    for (i = 0; i < (s->acmod ? 1 : 2); i++) {
+        if (get_bits1(gbc)) {
+            s->dynrng[i] = ff_ac3_dynrng_tbl[get_bits(gbc, 8)];
+        } else {
+            if (!blk) {
+                s->dynrng[i] = 1.0f;
+            }
+        }
+    }
+    /* Spectral extension strategy information */
+    if ((!blk) || get_bits1(gbc)) {
+        s->spxinu = get_bits1(gbc);
+        if (s->spxinu) {
+            log_missing_feature(s->avctx, "Spectral extension");
+            return -1;
+#if 0
+            if (s->acmod == AC3_ACMOD_MONO) {
+                s->chinspx[1] = 1;
+            } else {
+                for (ch = 1; ch <= s->nfchans; ch++) {
+                    s->chinspx[ch] = get_bits1(gbc);
+                }
+            }
+#if 0
+            {
+                int nspx=0;
+                for (ch = 1; ch <= s->nfchans; ch++) {
+                    nspx+=s->chinspx[ch];
+                }
+                if (!nspx)
+                    av_log(s->avctx, AV_LOG_INFO, "No channels in spectral extension\n");
+            }
+#endif
+            s->spxstrtf = get_bits(gbc, 2);
+            s->spxbegf = get_bits(gbc, 3);
+            s->spxendf = get_bits(gbc, 3);
+            if (s->spxbegf < 6) {
+                s->spxbegf += 2;
+            } else {
+                s->spxbegf = s->spxbegf * 2 - 3;
+            }
+            if (s->spxendf < 3) {
+                s->spxendf += 5;
+            } else {
+                s->spxendf = s->spxendf * 2 + 3;
+            }
+            for (ch = 1; ch <= s->nfchans; ch++) {
+                if (s->chinspx[ch])
+                    s->endmant[ch] = 25 + 12 * s->spxbegf;
+            }
+            if (get_bits1(gbc)) {
+                for (bnd = s->spxbegf + 1; bnd < s->spxendf; bnd++) {
+                    s->spxbndstrc[bnd] = get_bits1(gbc);
+                }
+            } else {
+                if (!blk) {
+                    for (bnd = 0; bnd < 17; bnd++)
+                        s->spxbndstrc[bnd] = ff_eac3_defspxbndstrc[bnd];
+                }
+            }
+            // calculate number of spectral extension bands
+            s->nspxbnds = 1;
+            s->spxbndsztab[0] = 12;
+            for (bnd = s->spxbegf+1; bnd < s->spxendf; bnd ++){
+                if (!s->spxbndstrc[bnd]) {
+                    s->spxbndsztab[s->nspxbnds] = 12;
+                    s->nspxbnds++;
+                } else {
+                    s->spxbndsztab[s->nspxbnds - 1] += 12;
+                }
+            }
+#endif
+        } else {
+            /* !spxinu */
+            for (ch = 1; ch <= s->nfchans; ch++) {
+                s->chinspx[ch] = 0;
+                s->firstspxcos[ch] = 1;
+            }
+        }
+    }
+
+    /* Spectral extension coordinates */
+    if (s->spxinu) {
+        for (ch = 1; ch <= s->nfchans; ch++) {
+            if (s->chinspx[ch]) {
+                if (s->firstspxcos[ch]) {
+                    s->spxcoe[ch] = 1;
+                    s->firstspxcos[ch] = 0;
+                } else {
+                    /* !firstspxcos[ch] */
+                    s->spxcoe[ch] = get_bits1(gbc);
+                }
+                if (!blk && !s->spxcoe[ch]) {
+                    av_log(s->avctx, AV_LOG_ERROR, "no spectral extension coordinates in first block\n");
+                    return -1;
+                }
+
+                if (s->spxcoe[ch]) {
+                    int spxcoexp, spxcomant, mstrspxco;
+                    s->spxblnd[ch] = get_bits(gbc, 5);
+                    mstrspxco = get_bits(gbc, 2);
+                    mstrspxco*=3;
+                    /* nspxbnds determined from spxbegf, spxendf, and spxbndstrc[ ] */
+                    for (bnd = 0; bnd < s->nspxbnds; bnd++) {
+                        spxcoexp = get_bits(gbc, 4);
+                        spxcomant = get_bits(gbc, 2);
+                        if (spxcoexp == 15)
+                            s->spxco[ch][bnd] = spxcomant / 4.0f;
+                        else
+                            s->spxco[ch][bnd] = (spxcomant+4) / 8.0f;
+                        s->spxco[ch][bnd] *= ff_ac3_scale_factors[spxcoexp + mstrspxco];
+                    }
+                }
+            } else {
+                /* !chinspx[ch] */
+                s->firstspxcos[ch] = 1;
+            }
+        }
+    }
+    /* Coupling strategy and enhanced coupling strategy information */
+    if (s->cplstre[blk]) {
+        if (s->cplinu[blk]) {
+            s->ecplinu = get_bits1(gbc);
+            if (s->acmod == AC3_ACMOD_STEREO) {
+                s->chincpl[1] = 1;
+                s->chincpl[2] = 1;
+            } else {
+                for (ch = 1; ch <= s->nfchans; ch++) {
+                    s->chincpl[ch] = get_bits1(gbc);
+                }
+            }
+            if (!s->ecplinu) {
+                /* standard coupling in use */
+                if (s->acmod == AC3_ACMOD_STEREO) { /* if in 2/0 mode */
+                    s->phsflginu = get_bits1(gbc);
+                }
+                s->cplbegf = get_bits(gbc, 4);
+                if (!s->spxinu) {
+                    /* if SPX not in use */
+                    s->cplendf = get_bits(gbc, 4);
+                    s->cplendf += 3;
+                } else {
+                    /* SPX in use */
+                    s->cplendf = s->spxbegf - 1;
+                }
+
+                s->strtmant[CPL_CH] = 37 + (12 * s->cplbegf);
+                s->endmant[CPL_CH] = 37 + (12 * s->cplendf);
+                if (s->strtmant[CPL_CH] > s->endmant[CPL_CH]) {
+                    av_log(s->avctx, AV_LOG_ERROR, "cplstrtmant > cplendmant [blk=%i]\n", blk);
+                    return -1;
+                }
+                for (ch = 1; ch <= s->nfchans; ch++) {
+                    if (s->chincpl[ch])
+                        s->endmant[ch] = s->strtmant[CPL_CH];
+                }
+                if (get_bits1(gbc)) {
+                    for (bnd = s->cplbegf + 1; bnd < s->cplendf; bnd++) {
+                        s->cplbndstrc[bnd] = get_bits1(gbc);
+                    }
+                } else {
+                    if (!blk) {
+                        for (bnd = 0; bnd < 18; bnd++)
+                            s->cplbndstrc[bnd] = ff_eac3_defcplbndstrc[bnd];
+                    }
+                }
+                s->ncplsubnd =  s->cplendf - s->cplbegf;
+                s->ncplbnd = s->ncplsubnd;
+                for (bnd = s->cplbegf + 1; bnd < s->cplendf; bnd++) {
+                    s->ncplbnd -= s->cplbndstrc[bnd];
+                }
+            } else {
+                /* enhanced coupling in use */
+                log_missing_feature(s->avctx, "Enhanced coupling");
+                return -1;
+#if 0
+                s->ecplbegf = get_bits(gbc, 4);
+                if (s->ecplbegf < 3) {
+                    s->ecpl_start_subbnd = s->ecplbegf * 2;
+                } else {
+                    if (s->ecplbegf < 13) {
+                        s->ecpl_start_subbnd = s->ecplbegf + 2;
+                    } else {
+                        s->ecpl_start_subbnd = s->ecplbegf * 2 - 10;
+                    }
+                }
+                if (!s->spxinu) {
+                    /* if SPX not in use */
+                    s->ecplendf = get_bits(gbc, 4);
+                    s->ecpl_end_subbnd = s->ecplendf + 7;
+                } else {
+                    /* SPX in use */
+                    if (s->spxbegf < 6) {
+                        s->ecpl_end_subbnd = s->spxbegf + 5;
+                    } else {
+                        s->ecpl_end_subbnd = s->spxbegf * 2;
+                    }
+                }
+                if (get_bits1(gbc)) {
+                    for (sbnd = FFMAX(9, s->ecpl_start_subbnd + 1);
+                            sbnd < s->ecpl_end_subbnd; sbnd++){
+                        s->ecplbndstrc[sbnd] = get_bits1(gbc);
+                    }
+                } else {
+                    if (!blk) {
+                        for (sbnd = 0; sbnd < 22; sbnd++)
+                            s->ecplbndstrc[sbnd] = ff_eac3_defecplbndstrc[sbnd];
+                    }
+                }
+                //necplbnd = ecpl_end_subbnd - ecpl_start_subbnd;
+                //necplbnd -= ecplbndstrc[ecpl_start_subbnd] + ... + ecplbndstrc[ecpl_end_subbnd -1]
+                s->necplbnd = s->ecpl_end_subbnd - s->ecpl_start_subbnd;
+                for (bnd = s->ecpl_start_subbnd; bnd < s->ecpl_end_subbnd; bnd++) {
+                    s->necplbnd -= s->ecplbndstrc[bnd];
+                }
+#endif
+            } /* ecplinu[blk] */
+        } else {
+            /* !cplinu[blk] */
+            for (ch = 1; ch <= s->nfchans; ch++) {
+                s->chincpl[ch] = 0;
+                s->firstcplcos[ch] = 1;
+            }
+            s->firstcplleak = 1;
+            s->phsflginu = 0;
+            s->ecplinu = 0;
+        }
+    } /* cplstre[blk] */
+    /* Coupling coordinates */
+    if (s->cplinu[blk]) {
+        if (!s->ecplinu) {
+            /* standard coupling in use */
+            for (ch = 1; ch <= s->nfchans; ch++) {
+                if (s->chincpl[ch]) {
+                    if (s->firstcplcos[ch]) {
+                        s->cplcoe[ch] = 1;
+                        s->firstcplcos[ch] = 0;
+                    } else {
+                        /* !firstcplcos[ch] */
+                        s->cplcoe[ch] = get_bits1(gbc);
+                    }
+                    if (s->cplcoe[ch]) {
+                        int cplcoexp, cplcomant, mstrcplco;
+                        mstrcplco = get_bits(gbc, 2);
+                        mstrcplco = 3 * mstrcplco;
+                        /* ncplbnd derived from cplbegf, cplendf, and cplbndstrc */
+                        for (bnd = 0; bnd < s->ncplbnd; bnd++) {
+                            cplcoexp = get_bits(gbc, 4);
+                            cplcomant = get_bits(gbc, 4);
+                            if (cplcoexp == 15)
+                                s->cplco[ch][bnd] = cplcomant / 16.0f;
+                            else
+                                s->cplco[ch][bnd] = (cplcomant + 16.0f) / 32.0f;
+                            s->cplco[ch][bnd] *=  ff_ac3_scale_factors[cplcoexp + mstrcplco];
+                        }
+                    } /* cplcoe[ch] */
+                    else {
+                        if (!blk) {
+                            av_log(s->avctx, AV_LOG_ERROR,  "no coupling coordinates in first block\n");
+                            return -1;
+                        }
+                    }
+                } else {
+                    /* ! chincpl[ch] */
+                    s->firstcplcos[ch] = 1;
+                }
+            } /* ch */
+            if ((s->acmod == AC3_ACMOD_STEREO) && s->phsflginu
+                    && (s->cplcoe[1] || s->cplcoe[2])) {
+                for (bnd = 0; bnd < s->ncplbnd; bnd++) {
+                    s->phsflg[bnd] = get_bits1(gbc);
+                }
+            }
+            s->nchgrps[CPL_CH] = (s->endmant[CPL_CH] - s->strtmant[CPL_CH]) /
+                (3 << (s->chexpstr[blk][CPL_CH] - 1));
+        } else {
+            /* enhanced coupling in use */
+            //TODO calc nchgrps[CPL_CH]
+#if 0
+            s->firstchincpl = -1;
+            s->ecplangleintrp = get_bits1(gbc);
+            for (ch = 1; ch <= s->nfchans; ch++) {
+                if (s->chincpl[ch]) {
+                    if (s->firstchincpl == -1) {
+                        s->firstchincpl = ch;
+                    }
+                    if (s->firstcplcos[ch]) {
+                        s->ecplparam1e[ch] = 1;
+                        if (ch > s->firstchincpl) {
+                            s->ecplparam2e[ch] = 1;
+                        } else {
+                            s->ecplparam2e[ch] = 0;
+                        }
+                        s->firstcplcos[ch] = 0;
+                    } else {
+                        /* !firstcplcos[ch] */
+                        s->ecplparam1e[ch] = get_bits1(gbc);
+                        if (ch > s->firstchincpl) {
+                            s->ecplparam2e[ch] = get_bits1(gbc);
+                        } else {
+                            s->ecplparam2e[ch] = 0;
+                        }
+                    }
+                    if (s->ecplparam1e[ch]) {
+                        /* necplbnd derived from ecpl_start_subbnd, ecpl_end_subbnd, and ecplbndstrc */
+                        for (bnd = 0; bnd < s->necplbnd; bnd++) {
+                            s->ecplamp[ch][bnd] = get_bits(gbc, 5);
+                        }
+                    }
+                    if (s->ecplparam2e[ch]) {
+                        /* necplbnd derived from ecpl_start_subbnd, ecpl_end_subbnd, and ecplbndstrc */
+                        for (bnd = 0; bnd < s->necplbnd; bnd++) {
+                            s->ecplangle[ch][bnd] = get_bits(gbc, 6);
+                            s->ecplchaos[ch][bnd] = get_bits(gbc, 3);
+                        }
+                    }
+                    if (ch > s->firstchincpl) {
+                        s->ecpltrans[ch] = get_bits1(gbc);
+                    }
+                } else {
+                    /* !chincpl[ch] */
+                    s->firstcplcos[ch] = 1;
+                }
+            } /* ch */
+#endif
+        } /* ecplinu[blk] */
+    } /* cplinu[blk] */
+    /* Rematrixing operation in the 2/0 mode */
+    if (s->acmod == AC3_ACMOD_STEREO) { /* if in 2/0 mode */
+        if (!blk || get_bits1(gbc)) {
+            /* nrematbnds determined from cplinu, ecplinu, spxinu, cplbegf, ecplbegf and spxbegf */
+            // TODO spx in one channel
+            int end = (s->cplinu[blk] || s->spxinu) ?
+                FFMIN(s->endmant[1], s->endmant[2]) : (ff_ac3_rematrix_band_tbl[4]-1);
+            for (bnd = 0; ff_ac3_rematrix_band_tbl[bnd] <= end; bnd++) {
+                s->rematflg[bnd] = get_bits1(gbc);
+            }
+            s->nrematbnds = bnd;
+        }
+    }
+    /* Channel bandwidth code */
+    for (ch = 1; ch <= s->nfchans; ch++) {
+        if (!blk && s->chexpstr[blk][ch] == EXP_REUSE) {
+            av_log(s->avctx, AV_LOG_ERROR,  "no channel exponent strategy in first block\n");
+            return -1;
+        }
+        if (s->chexpstr[blk][ch] != EXP_REUSE) {
+            grpsize = 3 << (s->chexpstr[blk][ch] - 1);
+            s->strtmant[ch] = 0;
+            if ((!s->chincpl[ch]) && (!s->chinspx[ch])) {
+                chbwcod = get_bits(gbc, 6);
+                if (chbwcod > 60) {
+                    av_log(s->avctx, AV_LOG_ERROR, "chbwcod > 60\n");
+                    return -1;
+                }
+                s->endmant[ch] = ((chbwcod + 12) * 3) + 37; /* (ch is not coupled) */
+            }
+            grpsize = 3 << (s->chexpstr[blk][ch] - 1);
+            s->nchgrps[ch] = (s->endmant[ch] + grpsize - 4) / grpsize;
+        }
+    }
+    /* Exponents */
+    for (ch = !s->cplinu[blk]; ch <= s->num_channels; ch++) {
+        if (s->chexpstr[blk][ch] != EXP_REUSE) {
+            s->dexps[ch][0] = get_bits(gbc, 4) << !ch;
+            ff_ac3_decode_exponents(gbc, s->chexpstr[blk][ch], s->nchgrps[ch],
+                    s->dexps[ch][0], s->dexps[ch]+s->strtmant[ch]+!!ch);
+            if (ch != CPL_CH && ch != s->lfe_channel)
+                skip_bits(gbc, 2); /* skip gainrng */
+        }
+    }
+
+    /* Bit-allocation parametric information */
+    if (s->bamode) {
+        if (get_bits1(gbc)) {
+            s->bit_alloc_params.sdecay = ff_sdecaytab[get_bits(gbc, 2)];   /* Table 7.6 */
+            s->bit_alloc_params.fdecay = ff_fdecaytab[get_bits(gbc, 2)];   /* Table 7.7 */
+            s->bit_alloc_params.sgain  = ff_sgaintab [get_bits(gbc, 2)];   /* Table 7.8 */
+            s->bit_alloc_params.dbknee = ff_dbkneetab[get_bits(gbc, 2)];   /* Table 7.9 */
+            s->bit_alloc_params.floor  = ff_floortab [get_bits(gbc, 3)];   /* Table 7.10 */
+        } else {
+            if (!blk) {
+                av_log(s->avctx, AV_LOG_ERROR, "no bit allocation information in first block\n");
+                return -1;
+            }
+        }
+    } else {
+        s->bit_alloc_params.sdecay = ff_sdecaytab[2];   /* Table 7.6 */
+        s->bit_alloc_params.fdecay = ff_fdecaytab[1];   /* Table 7.7 */
+        s->bit_alloc_params.sgain  = ff_sgaintab[1];    /* Table 7.8 */
+        s->bit_alloc_params.dbknee = ff_dbkneetab[2];   /* Table 7.9 */
+        s->bit_alloc_params.floor  = ff_floortab[7];    /* Table 7.10 */
+    }
+
+    if (s->snroffststr) {
+        av_log(s->avctx, AV_LOG_INFO, "NOT TESTED\n");
+        if (!blk || get_bits1(gbc)) {
+            int csnroffst = (get_bits(gbc, 6) - 15) << 4;
+            if (s->snroffststr == 1) {
+                int snroffst = (csnroffst + get_bits(gbc, 4)) << 2;
+                for (ch = !s->cplinu[blk]; ch <= s->num_channels; ch++)
+                    s->snroffst[ch] = snroffst;
+            } else {
+                if (s->snroffststr == 2) {
+                    for (ch = !s->cplinu[blk]; ch <= s->num_channels; ch++)
+                        s->snroffst[ch] = (csnroffst + get_bits(gbc, 4)) << 2;
+                }
+            }
+        }
+    }
+
+    if (s->frmfgaincode && get_bits1(gbc)) {
+        for (ch = !s->cplinu[blk]; ch <= s->num_channels; ch++)
+            s->fgain[ch] = ff_fgaintab[get_bits(gbc, 3)];
+    } else {
+        if (!blk) {
+            for (ch = !s->cplinu[blk]; ch <= s->num_channels; ch++)
+                s->fgain[ch] = ff_fgaintab[4];
+        }
+    }
+    if (!s->strmtyp) {
+        if (get_bits1(gbc)) {
+            skip_bits(gbc, 10); //Converter SNR offset
+        }
+    }
+    if (s->cplinu[blk]) {
+        if (s->firstcplleak) {
+            s->cplleake = 1;
+            s->firstcplleak = 0;
+        } else {
+            /* !firstcplleak */
+            s->cplleake = get_bits1(gbc);
+        }
+        if (s->cplleake) {
+            s->bit_alloc_params.cplfleak = get_bits(gbc, 3);
+            s->bit_alloc_params.cplsleak = get_bits(gbc, 3);
+        }
+    }
+    /* Delta bit allocation information */
+    if (s->dbaflde && get_bits1(gbc)) {
+        for (ch = !s->cplinu[blk]; ch <= s->nfchans; ch++) {
+            s->deltbae[ch] = get_bits(gbc, 2);
+        }
+        for (ch = !s->cplinu[blk]; ch <= s->nfchans; ch++) {
+            if (s->deltbae[ch] == DBA_NEW) {
+                s->deltnseg[ch] = get_bits(gbc, 3);
+                for (seg = 0; seg <= s->deltnseg[ch]; seg++) {
+                    s->deltoffst[ch][seg] = get_bits(gbc, 5);
+                    s->deltlen[ch][seg] = get_bits(gbc, 4);
+                    s->deltba[ch][seg] = get_bits(gbc, 3);
+                }
+            }
+        }
+    } else {
+        if (!blk) {
+            for (ch = 0; ch <= s->num_channels; ch++) {
+                s->deltbae[ch] = DBA_NONE;
+            }
+        }
+    }
+
+    /* Inclusion of unused dummy data */
+    if (s->skipflde) {
+        if (get_bits1(gbc)) {
+            int skipl = get_bits(gbc, 9);
+            while(skipl--) skip_bits(gbc, 8);
+        }
+    }
+
+    /* run bit allocation */
+    for (ch = !s->cplinu[blk]; ch <= s->num_channels; ch++) {
+        int start=0, end=0;
+        start = s->strtmant[ch];
+        end = s->endmant[ch];
+
+        ff_ac3_bit_alloc_calc_psd((int8_t *)s->dexps[ch], start, end,
+                s->psd[ch], s->bndpsd[ch]);
+
+        s->bit_alloc_params.fscod = s->fscod;
+        s->bit_alloc_params.halfratecod = 0;
+
+        ff_ac3_bit_alloc_calc_mask(&s->bit_alloc_params,
+                s->bndpsd[ch], start, end, s->fgain[ch],
+                (ch == s->lfe_channel),
+                s->deltbae[ch], s->deltnseg[ch],
+                s->deltoffst[ch], s->deltlen[ch],
+                s->deltba[ch], s->mask[ch]);
+
+        if (s->chahtinu[ch] == 0)
+            ff_ac3_bit_alloc_calc_bap(s->mask[ch], s->psd[ch], start, end,
+                    s->snroffst[ch], s->bit_alloc_params.floor, ff_ac3_baptab,
+                    s->bap[ch]);
+        else
+            if (s->chahtinu[ch] == 1)
+                ff_ac3_bit_alloc_calc_bap(s->mask[ch], s->psd[ch], start, end,
+                        s->snroffst[ch], s->bit_alloc_params.floor, ff_ac3_hebaptab,
+                        s->hebap[ch]);
+    }
+
+    got_cplchan = 0;
+
+    // TODO only for debug
+    for (ch = 0; ch <= s->num_channels; ch++)
+        memset(s->transform_coeffs[ch], 0, 256*sizeof(float));
+
+    /* Quantized mantissa values */
+    for (ch = 1; ch <= s->num_channels; ch++) {
+        get_eac3_transform_coeffs_ch(gbc, s, blk, ch, &m);
+        if (s->cplinu[blk] && s->chincpl[ch] && !got_cplchan) {
+            get_eac3_transform_coeffs_ch(gbc, s, blk, CPL_CH, &m);
+            got_cplchan = 1;
+        }
+    }
+
+    if (s->cplinu[blk])
+        uncouple_channels(s);
+
+    //apply spectral extension
+    if (s->spxinu)
+        spectral_extension(s);
+
+    return 0;
+}
+
+/**
+ * Performs Inverse MDCT transform
+ */
+static void do_imdct(EAC3Context *ctx)
+{
+    int ch;
+
+    for (ch = 1; ch <= ctx->nfchans + ctx->lfeon; ch++) {
+        if (ctx->blksw[ch]) {
+            /* 256-point IMDCT */
+            ff_ac3_do_imdct_256(ctx->tmp_output, ctx->transform_coeffs[ch],
+                    &ctx->imdct_256, ctx->tmp_imdct);
+        } else {
+            /* 512-point IMDCT */
+            ctx->imdct_512.fft.imdct_calc(&ctx->imdct_512, ctx->tmp_output,
+                    ctx->transform_coeffs[ch],
+                    ctx->tmp_imdct);
+        }
+        /* apply window function, overlap/add output, save delay */
+        ctx->dsp.vector_fmul_add_add(ctx->output[ch-1], ctx->tmp_output,
+                ctx->window, ctx->delay[ch-1], 0,
+                AC3_BLOCK_SIZE, 1);
+        ctx->dsp.vector_fmul_reverse(ctx->delay[ch-1], ctx->tmp_output+256,
+                ctx->window, AC3_BLOCK_SIZE);
+    }
+}
+
+static int eac3_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
+        uint8_t *buf, int buf_size){
+    int16_t *out_samples = (int16_t *)data;
+    EAC3Context *c = (EAC3Context *)avctx->priv_data;
+    int k, i, blk, ch;
+    GetBitContext gbc;
+
+    *data_size = 0;
+    c->gbc = &gbc;
+    c->syncword = 0;
+    init_get_bits(&gbc, buf, buf_size*8);
+    c->syncword = get_bits(&gbc, 16);
+
+    if (c->syncword != 0x0B77)
+        return -1;
+
+    if (parse_bsi(&gbc, c) || parse_audfrm(&gbc, c))
+        return -1;
+
+    if (c->fscod == 3) {
+        avctx->sample_rate = ff_ac3_freqs[c->fscod2] / 2;
+    } else {
+        avctx->sample_rate = ff_ac3_freqs[c->fscod];
+    }
+
+    avctx->bit_rate = (c->frmsiz * (avctx->sample_rate) * 16 / ( ff_eac3_blocks[c->numblkscod] * 256)) / 1000;
+
+    /* channel config */
+    if (!avctx->request_channels) {
+        if (!avctx->channels)
+            avctx->channels = c->num_channels;
+    } else {
+        if (c->num_channels < avctx->request_channels) {
+            av_log(avctx, AV_LOG_ERROR, "Cannot upmix EAC3 from %d to %d channels.\n",
+                    c->num_channels, avctx->request_channels);
+            return -1;
+        } else {
+            if (avctx->request_channels > 2
+                    && avctx->request_channels != c->num_channels) {
+                av_log(avctx, AV_LOG_ERROR, "Cannot downmix EAC3 from %d to %d channels.\n",
+                        c->num_channels, avctx->request_channels);
+                return -1;
+            }
+            avctx->channels = avctx->request_channels;
+        }
+    }
+
+    for (blk = 0; blk < ff_eac3_blocks[c->numblkscod]; blk++) {
+        if (parse_audblk(&gbc, c, blk)) {
+            av_log(c->avctx, AV_LOG_ERROR, "Error in parse_audblk\n");
+            return -1;
+        }
+
+        /* recover coefficients if rematrixing is in use */
+        if (c->acmod == AC3_ACMOD_STEREO)
+            ff_ac3_do_rematrixing(c->transform_coeffs,
+                    FFMIN(c->endmant[1], c->endmant[2]),
+                    c->nrematbnds, c->rematflg);
+
+        /* apply scaling to coefficients (dialnorm, dynrng) */
+        for (ch = 1; ch <= c->nfchans + c->lfeon; ch++) {
+            float gain=2.0f;
+            for (i = 0; i < c->endmant[ch]; i++) {
+                c->transform_coeffs[ch][i] *= gain;
+            }
+        }
+
+        do_imdct(c);
+
+        if (avctx->channels != c->num_channels) {
+            ff_ac3_downmix(c->output, c->nfchans, avctx->channels, c->downmix_coeffs);
+        }
+
+        // convert float to 16-bit integer
+        for (ch = 0; ch < avctx->channels; ch++) {
+            for (i = 0; i < AC3_BLOCK_SIZE; i++) {
+                c->output[ch][i] = c->output[ch][i] * c->mul_bias +
+                    c->add_bias;
+            }
+            c->dsp.float_to_int16(c->int_output[ch], c->output[ch],
+                    AC3_BLOCK_SIZE);
+        }
+        for (k = 0; k < AC3_BLOCK_SIZE; k++) {
+            if (c->lfeon) {
+           switch(avctx->channels){
+               case 6:
+                   *(out_samples++) = c->int_output[0][k];   // FL
+                   *(out_samples++) = c->int_output[2][k];   // FR
+                   *(out_samples++) = c->int_output[1][k];   // FC
+                   *(out_samples++) = c->int_output[5][k];   // LFE
+                   *(out_samples++) = c->int_output[3][k];   // BL
+                   *(out_samples++) = c->int_output[4][k];   // BC
+                   break;
+               case 5:
+                   if (c->acmod == 5) {
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[2][k];    // FR
+                       *(out_samples++) = c->int_output[1][k];    // FC
+                       *(out_samples++) = c->int_output[4][k];    // LFE
+                       *(out_samples++) = c->int_output[3][k];    // BC
+                   } else {                                    // acmod 6
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[1][k];    // FR
+                       *(out_samples++) = c->int_output[4][k];    // LFE
+                       *(out_samples++) = c->int_output[2][k];    // BL
+                       *(out_samples++) = c->int_output[3][k];    // BR
+                   }
+                   break;
+               case 4:
+                   if (c->acmod == 3) {
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[2][k];    // FR
+                       *(out_samples++) = c->int_output[1][k];    // FC
+                       *(out_samples++) = c->int_output[3][k];    // LFE
+                   } else {                                    // acmod 4
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[1][k];    // FR
+                       *(out_samples++) = c->int_output[3][k];    // LFE
+                       *(out_samples++) = c->int_output[2][k];    // BC
+                   }
+                   break;
+               default:
+                   for (i = 0; i < avctx->channels; i++)
+                       *(out_samples++) = c->int_output[i][k];
+           }
+       } else {
+           switch(avctx->channels){
+               case 5:
+                   *(out_samples++) = c->int_output[0][k];   // FL
+                   *(out_samples++) = c->int_output[2][k];   // FR
+                   *(out_samples++) = c->int_output[1][k];   // FC
+                   *(out_samples++) = c->int_output[3][k];   // BL
+                   *(out_samples++) = c->int_output[4][k];   // BC
+                   break;
+               case 4:
+                   if (c->acmod == 5) {
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[2][k];    // FR
+                       *(out_samples++) = c->int_output[1][k];    // FC
+                       *(out_samples++) = c->int_output[3][k];    // BC
+                   } else {                                     // acmod 6
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[1][k];    // FR
+                       *(out_samples++) = c->int_output[2][k];    // BL
+                       *(out_samples++) = c->int_output[3][k];    // BR
+                   }
+                   break;
+               case 3:
+                   if (c->acmod == 3) {
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[2][k];    // FR
+                       *(out_samples++) = c->int_output[1][k];    // FC
+                   } else {                                    // acmod 4
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[1][k];    // FR
+                       *(out_samples++) = c->int_output[2][k];    // BC
+                   }
+                   break;
+               default:
+                   for (i = 0; i < avctx->channels; i++)
+                       *(out_samples++) = c->int_output[i][k];
+           }
+       }
+        }
+    }
+
+    *data_size = ff_eac3_blocks[c->numblkscod] * 256 * avctx->channels * sizeof (int16_t); // TODO is ok?
+
+    return (c->frmsiz+1)*2;
+}
+
+static int eac3_decode_init(AVCodecContext *avctx){
+    EAC3Context *ctx = avctx->priv_data;
+
+    ctx->avctx = avctx;
+    ac3_common_init();
+    ff_ac3_tables_init();
+    av_init_random(0, &ctx->dith_state);
+    ff_mdct_init(&ctx->imdct_256, 8, 1);
+    ff_mdct_init(&ctx->imdct_512, 9, 1);
+    dsputil_init(&ctx->dsp, avctx);
+    if (ctx->dsp.float_to_int16 == ff_float_to_int16_c) {
+        ctx->add_bias = 385.0f;
+        ctx->mul_bias = 1.0f;
+    } else {
+        ctx->add_bias = 0.0f;
+        ctx->mul_bias = 32767.0f;
+    }
+    ff_ac3_window_init(ctx->window);
+    return 0;
+}
+
+static int eac3_decode_end(AVCodecContext *avctx){
+    EAC3Context *ctx = avctx->priv_data;
+    ff_mdct_end(&ctx->imdct_512);
+    ff_mdct_end(&ctx->imdct_256);
+
+    return 0;
+}
+
+AVCodec eac3_decoder = {
+    .name = "E-AC3",
+    .type = CODEC_TYPE_AUDIO,
+    .id = CODEC_ID_EAC3,
+    .priv_data_size = sizeof (EAC3Context),
+    .init = eac3_decode_init,
+    .close = eac3_decode_end,
+    .decode = eac3_decode_frame,
+
+};
diff -ruN mplayer.orig/libavcodec/eac3.h mplayer.eac3/libavcodec/eac3.h
--- mplayer.orig/libavcodec/eac3.h	1970-01-01 03:00:00.000000000 +0300
+++ mplayer.eac3/libavcodec/eac3.h	2007-10-19 14:13:32.000000000 +0300
@@ -0,0 +1,208 @@
+/*
+ * E-AC3 parser
+ * Copyright (c) 2007 Bartlomiej Wolowiec <bartek.wolowiec@gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#ifndef EAC3_H
+#define EAC3_H
+
+#include "dsputil.h"
+#include "avcodec.h"
+#include "ac3.h"
+#include "random.h"
+#include "bitstream.h"
+
+/* override ac3.h to include coupling channel */
+#undef AC3_MAX_CHANNELS
+#define AC3_MAX_CHANNELS 7
+
+#define AC3_MAX_COEFS   256
+
+#define AC3_BLOCK_SIZE  256
+#define MAX_BLOCKS 6
+#define MAX_SPX_CODES 18
+
+typedef struct EAC3Context{
+    AVCodecContext *avctx;           ///< Parent context
+    int syncword;
+///@name Bit stream information
+///@{
+    int strmtyp;                     ///< Stream type
+    int substreamid;                 ///< Substream identification
+    int frmsiz;                      ///< Frame size
+    int fscod;                       ///< Sample rate code
+    int fscod2;                      ///< Sample rate code 2
+    int numblkscod;                  ///< Number of audio blocks
+    int acmod;                       ///< Audio coding mode
+    int lfeon;                       ///< Low frequency effect channel on
+    int bsid;                        ///< Bit stream identification
+    float dialnorm[2];               ///< Dialogue normalization
+    int chanmap;                     ///< Custom channel map
+    int mixmdate;                    ///< Mixing meta-data exists
+    int dmixmod;                     ///< Preferred stereo downmix mode
+    int lfemixlevcode;               ///< lfe mix level code exists
+    int lfemixlevcod;                ///< lfe mix level code
+    int pgmscl[2];                   ///< Program scale factor
+    int extpgmscl;                   ///< External program scale factor
+    int mixdef;                      ///< Mix control type
+    int mixdeflen;                   ///< Length of mixing parameter data field
+    int paninfo[2];                  ///< Pan information
+    int frmmixcfginfoe;              ///< Frame mixing configuration information exists
+    int blkmixcfginfo[6];            ///< Block mixing configuration information
+    int infomdate;                   ///< Informational meta-data exists
+///@}
+///@name Audio Frame
+///@{
+    int expstre;                     ///< Exponent strategy syntax enabled
+    int ahte;                        ///< Adaptive hybrid transform enabled
+    int snroffststr;                 ///< SNR offset strategy
+    int snroffst[AC3_MAX_CHANNELS];  ///< SNR offset
+    int transproce;                  ///< Transient pre-noise processing enabled
+    int blkswe;                      ///< Block switch syntax enabled
+    int dithflage;                   ///< Dither flag syntax enabled
+    int bamode;                      ///< Bit allocation model syntax enabled
+    int frmfgaincode;                ///< Fast gain codes enabled
+    int dbaflde;                     ///< Delta bit allocation syntax enabled
+    int skipflde;                    ///< Skip Filed syntax enabled
+    int spxattene;                   ///< Spectral extension attenuation enabled
+    int cplinu[MAX_BLOCKS];          ///< Coupling in use
+    int cplstre[MAX_BLOCKS];         ///< Coupling strategy exists
+    int chexpstr[MAX_BLOCKS][AC3_MAX_CHANNELS];  ///< Channel exponent strategy
+    int chahtinu[AC3_MAX_CHANNELS];      ///< Channel AHT in use
+    int chintransproc[AC3_MAX_CHANNELS]; ///< Channel in transient pre-noise processing
+    int transprocloc[AC3_MAX_CHANNELS];  ///< Transient location relative to start of frame
+    int transproclen[AC3_MAX_CHANNELS];  ///< Transient processing length
+    int chinspxatten[AC3_MAX_CHANNELS];  ///< Channel in spectral extension attenuation process
+    int spxattencod[AC3_MAX_CHANNELS];   ///< spectral extension attenuation code
+    uint32_t blkstrtinfo;            ///< Block start information
+    int ncplblks;
+///@}
+///@name Audio block
+///@{
+    int blksw[AC3_MAX_CHANNELS];     ///< Block switch flag
+    int dithflag[AC3_MAX_CHANNELS];  ///< Dither flag
+    float dynrng[2];                 ///< Dynamic range gain word
+    float downmix_coeffs[AC3_MAX_CHANNELS][2];  ///< stereo downmix coefficients
+    int spxinu;                      ///< spectral extension in use
+    int chinspx[AC3_MAX_CHANNELS];   ///< Channel in spectral extension
+    int spxstrtf;                    ///< Spectral extension start copy frequency code
+    int spxbegf;                     ///< Spectral extension begin frequency code
+    int spxendf;                     ///< Spectral extension end frequency code
+    int spxbndstrc[MAX_SPX_CODES];   ///< Spectral extension band structure
+    int spxcoe[AC3_MAX_CHANNELS];    ///< Spectral extension coordinates exists
+    int spxblnd[AC3_MAX_CHANNELS];   ///< Spectral extension blend
+    int ecplinu;                     ///< Enhanced coupling in use
+    int chincpl[AC3_MAX_CHANNELS];   ///< Channel in coupling
+    int phsflginu;                   ///< Phase flag in use
+    int cplbegf;                     ///< Coupling begin frequency code
+    int cplendf;                     ///< Coupling end frequency code
+    int cplbndstrc[19];              ///< Coupling band structure
+    int ecplbegf;                    ///< Enhanced coupling begin frequency code
+    int ecplendf;                    ///< Enhanced coupling end frequency code
+    int ecplbndstrc[23];             ///< Enhanced coupling band structure
+    int cplcoe[AC3_MAX_CHANNELS];    ///< Coupling coordinates exists
+    int phsflg[18];                  ///< Phase flag
+    int ecplangleintrp;              ///< Enhanced coupling angle interpolation flag
+    int ecplparam1e[AC3_MAX_CHANNELS];   ///< Enhanced coupling parameters 1 exists
+    int ecplparam2e[AC3_MAX_CHANNELS];   ///< Enhanced coupling parameters 2 exists
+    int ecplamp[AC3_MAX_CHANNELS][23];   ///< Enhanced coupling amplitude scaling
+    int ecplangle[AC3_MAX_CHANNELS][23]; ///< Enhanced coupling angle
+    int ecplchaos[AC3_MAX_CHANNELS][23]; ///< Enhanced coupling chaos
+    int ecpltrans[AC3_MAX_CHANNELS];     ///< Enhanced coupling transient present
+    int rematflg[4];                 ///< Rematrixing flag
+    int cplabsexp;                   ///< Coupling absolute exponent
+
+    int fgain[AC3_MAX_CHANNELS];     ///< Channel fast gain
+    int cplleake;                    ///< Coupling leak initialization exists
+    uint8_t deltbae[AC3_MAX_CHANNELS];   ///< Delta bit allocation exists
+    uint8_t deltnseg[AC3_MAX_CHANNELS];  ///< Channel delta bit allocation number of segments
+    uint8_t deltoffst[AC3_MAX_CHANNELS][9]; ///< Channel delta bit allocation offset
+    uint8_t deltlen[AC3_MAX_CHANNELS][9];   ///< Channel delta bit allocation length
+    uint8_t deltba[AC3_MAX_CHANNELS][9];    ///< Channel delta bit allocation
+
+    int got_cplchan;
+    int chgaqgain[256];                             ///< Channel gain adaptive quantization gain
+    float pre_chmant[6][AC3_MAX_CHANNELS][256];     ///< Pre channel mantissas
+
+    int firstspxcos[AC3_MAX_CHANNELS];              ///< First spectral extension coordinates states
+    int firstcplcos[AC3_MAX_CHANNELS];              ///< First coupling coordinates states
+    int firstcplleak;                               ///< First coupling leak state
+///@}
+
+    int nrematbnds;                    ///< Number of rematrixing bands
+    int ncplsubnd;                     ///< Number of coupling sub-bands
+    int ncplbnd;                       ///< Number of structured coupled bands
+
+    int nchgrps[AC3_MAX_CHANNELS];                  ///< Number of fbw channel exponent groups
+    uint8_t dexps[AC3_MAX_CHANNELS][AC3_MAX_COEFS]; ///< Differential exponents
+
+    int strtmant[AC3_MAX_CHANNELS];    ///< Start frequency bin
+    int endmant[AC3_MAX_CHANNELS];     ///< End frequency bin
+    int firstchincpl;
+    int ecpl_start_subbnd;             ///< Enhanced coupling begin frequency
+    int ecpl_end_subbnd;               ///< Enhanced coupling end frequency
+
+    int necplbnd;                      ///< Number of structured enhanced coupling bands
+    int nspxbnds;                      ///< Number of structured spectral extension bands
+    int spxbndsztab[MAX_SPX_CODES];    ///< Sizes of spectral extension bands
+    int nfchans;                       ///< Number of fbw channels
+
+    uint8_t bap[AC3_MAX_CHANNELS][AC3_MAX_COEFS];   ///< bit allocation pointers
+    uint8_t hebap[AC3_MAX_CHANNELS][AC3_MAX_COEFS]; ///< high-efficiency bit allocation pointers for AHT
+    int16_t psd[AC3_MAX_CHANNELS][AC3_MAX_COEFS];   ///< scaled exponents
+    int16_t bndpsd[AC3_MAX_CHANNELS][50];           ///< interpolated exponents
+    int16_t mask[AC3_MAX_CHANNELS][50];             ///< masking values
+
+    float   cplco[AC3_MAX_CHANNELS][18];            ///< coupling coordinates
+    float   spxco[AC3_MAX_CHANNELS][18];            ///< Spectral extension coordinates
+
+    AC3BitAllocParameters bit_alloc_params;         ///< Bit allocation parameters
+
+    AVRandomState dith_state;        ///< for dither generation
+
+    int num_channels;                ///< Total of all channels
+    int lfe_channel;                 ///< Index of LFE channel
+
+    GetBitContext *gbc;              ///< Bitstream reader
+
+    MDCTContext imdct_512;           ///< for 512 sample imdct transform
+    MDCTContext imdct_256;           ///< for 256 sample imdct transform
+    DSPContext  dsp;                 ///< for optimization
+
+    DECLARE_ALIGNED_16(float, transform_coeffs[AC3_MAX_CHANNELS][AC3_MAX_COEFS]);
+    DECLARE_ALIGNED_16(float, delay[AC3_MAX_CHANNELS][AC3_BLOCK_SIZE]);  ///< delay - added to the next block
+    DECLARE_ALIGNED_16(float, window[AC3_BLOCK_SIZE]);               ///< window coefficients
+    DECLARE_ALIGNED_16(float, tmp_output[AC3_BLOCK_SIZE * 24]);      ///< temp storage for output before windowing
+    DECLARE_ALIGNED_16(float, tmp_imdct[AC3_BLOCK_SIZE * 24]);       ///< temp storage for imdct transform
+    DECLARE_ALIGNED_16(float, output[AC3_MAX_CHANNELS][AC3_BLOCK_SIZE]); ///< output after imdct transform and windowing
+    DECLARE_ALIGNED_16(int16_t, int_output[AC3_MAX_CHANNELS][AC3_BLOCK_SIZE]);///< final 16-bit integer output
+
+
+    float add_bias;                  ///< offset for float_to_int16 conversion
+    float mul_bias;                  ///< scaling for float_to_int16 conversion
+}EAC3Context;
+
+/** Channel gain adaptive quantization mode */
+typedef enum {
+    EAC3_GAQ_NO =0,
+    EAC3_GAQ_12,
+    EAC3_GAQ_14,
+    EAC3_GAQ_124
+} EAC3GaqMode;
+
+#endif
diff -ruN mplayer.orig/libavcodec/Makefile mplayer.eac3/libavcodec/Makefile
--- mplayer.orig/libavcodec/Makefile	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavcodec/Makefile	2007-10-19 14:13:32.000000000 +0300
@@ -66,6 +66,7 @@
 OBJS-$(CONFIG_DVVIDEO_DECODER)         += dv.o
 OBJS-$(CONFIG_DVVIDEO_ENCODER)         += dv.o
 OBJS-$(CONFIG_DXA_DECODER)             += dxa.o
+OBJS-$(CONFIG_EAC3_DECODER)            += eac3dec.o ac3dec.o
 OBJS-$(CONFIG_EIGHTBPS_DECODER)        += 8bps.o
 OBJS-$(CONFIG_FFV1_DECODER)            += ffv1.o rangecoder.o golomb.o
 OBJS-$(CONFIG_FFV1_ENCODER)            += ffv1.o rangecoder.o
diff -ruN mplayer.orig/libavcodec/Makefile.orig mplayer.eac3/libavcodec/Makefile.orig
--- mplayer.orig/libavcodec/Makefile.orig	1970-01-01 03:00:00.000000000 +0300
+++ mplayer.eac3/libavcodec/Makefile.orig	2007-10-19 14:13:18.000000000 +0300
@@ -0,0 +1,482 @@
+#
+# libavcodec Makefile
+# (c) 2000-2005 Fabrice Bellard
+#
+include ../config.mak
+
+CFLAGS += -I$(SRC_PATH)/libswscale -I$(SRC_PATH)/libavcodec
+
+OBJS = allcodecs.o \
+       audioconvert.o \
+       bitstream.o \
+       bitstream_filter.o \
+       dsputil.o \
+       error_resilience.o \
+       eval.o \
+       faandct.o \
+       imgconvert.o \
+       jrevdct.o \
+       jfdctfst.o \
+       jfdctint.o\
+       mpeg12.o mpeg12data.o \
+       mpegvideo.o \
+       opt.o \
+       parser.o \
+       raw.o \
+       resample.o \
+       resample2.o \
+       simple_idct.o \
+       utils.o \
+
+
+HEADERS = avcodec.h opt.h
+
+OBJS-$(CONFIG_AASC_DECODER)            += aasc.o
+OBJS-$(CONFIG_AC3_DECODER)             += ac3dec.o ac3tab.o ac3.o mdct.o fft.o
+OBJS-$(CONFIG_AC3_ENCODER)             += ac3enc.o ac3tab.o ac3.o
+OBJS-$(CONFIG_ALAC_DECODER)            += alac.o
+OBJS-$(CONFIG_AMV_DECODER)             += sp5xdec.o mjpegdec.o mjpeg.o
+OBJS-$(CONFIG_APE_DECODER)             += apedec.o
+OBJS-$(CONFIG_ASV1_DECODER)            += asv1.o
+OBJS-$(CONFIG_ASV1_ENCODER)            += asv1.o
+OBJS-$(CONFIG_ASV2_DECODER)            += asv1.o
+OBJS-$(CONFIG_ASV2_ENCODER)            += asv1.o
+OBJS-$(CONFIG_ATRAC3_DECODER)          += atrac3.o mdct.o fft.o
+OBJS-$(CONFIG_AVS_DECODER)             += avs.o
+OBJS-$(CONFIG_BETHSOFTVID_DECODER)     += bethsoftvideo.o
+OBJS-$(CONFIG_BMP_DECODER)             += bmp.o
+OBJS-$(CONFIG_BMP_ENCODER)             += bmpenc.o
+OBJS-$(CONFIG_C93_DECODER)             += c93.o
+OBJS-$(CONFIG_CAVS_DECODER)            += cavs.o cavsdec.o cavsdsp.o golomb.o
+OBJS-$(CONFIG_CINEPAK_DECODER)         += cinepak.o
+OBJS-$(CONFIG_CLJR_DECODER)            += cljr.o
+OBJS-$(CONFIG_CLJR_ENCODER)            += cljr.o
+OBJS-$(CONFIG_COOK_DECODER)            += cook.o mdct.o fft.o
+OBJS-$(CONFIG_CSCD_DECODER)            += cscd.o
+OBJS-$(CONFIG_CYUV_DECODER)            += cyuv.o
+OBJS-$(CONFIG_DCA_DECODER)             += dca.o
+OBJS-$(CONFIG_DNXHD_DECODER)           += dnxhddec.o dnxhddata.o
+OBJS-$(CONFIG_DNXHD_ENCODER)           += dnxhdenc.o dnxhddata.o mpegvideo_enc.o motion_est.o ratecontrol.o
+OBJS-$(CONFIG_DSICINVIDEO_DECODER)     += dsicinav.o
+OBJS-$(CONFIG_DSICINAUDIO_DECODER)     += dsicinav.o
+OBJS-$(CONFIG_DVBSUB_DECODER)          += dvbsubdec.o
+OBJS-$(CONFIG_DVBSUB_ENCODER)          += dvbsub.o
+OBJS-$(CONFIG_DVDSUB_DECODER)          += dvdsubdec.o
+OBJS-$(CONFIG_DVDSUB_ENCODER)          += dvdsubenc.o
+OBJS-$(CONFIG_DVVIDEO_DECODER)         += dv.o
+OBJS-$(CONFIG_DVVIDEO_ENCODER)         += dv.o
+OBJS-$(CONFIG_DXA_DECODER)             += dxa.o
+OBJS-$(CONFIG_EIGHTBPS_DECODER)        += 8bps.o
+OBJS-$(CONFIG_FFV1_DECODER)            += ffv1.o rangecoder.o golomb.o
+OBJS-$(CONFIG_FFV1_ENCODER)            += ffv1.o rangecoder.o
+OBJS-$(CONFIG_FFVHUFF_DECODER)         += huffyuv.o
+OBJS-$(CONFIG_FFVHUFF_ENCODER)         += huffyuv.o
+OBJS-$(CONFIG_FLAC_DECODER)            += flac.o golomb.o
+OBJS-$(CONFIG_FLAC_ENCODER)            += flacenc.o golomb.o
+OBJS-$(CONFIG_FLASHSV_DECODER)         += flashsv.o
+OBJS-$(CONFIG_FLASHSV_ENCODER)         += flashsvenc.o
+OBJS-$(CONFIG_FLIC_DECODER)            += flicvideo.o
+OBJS-$(CONFIG_FLV_DECODER)             += h263dec.o h263.o
+OBJS-$(CONFIG_FLV_ENCODER)             += mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
+OBJS-$(CONFIG_FOURXM_DECODER)          += 4xm.o
+OBJS-$(CONFIG_FRAPS_DECODER)           += fraps.o huffman.o
+OBJS-$(CONFIG_GIF_DECODER)             += gifdec.o lzw.o
+OBJS-$(CONFIG_GIF_ENCODER)             += gif.o
+OBJS-$(CONFIG_H261_DECODER)            += h261dec.o h261.o
+OBJS-$(CONFIG_H261_ENCODER)            += h261enc.o h261.o mpegvideo_enc.o motion_est.o ratecontrol.o
+OBJS-$(CONFIG_H263_DECODER)            += h263dec.o h263.o
+OBJS-$(CONFIG_H263I_DECODER)           += h263dec.o h263.o
+OBJS-$(CONFIG_H263_ENCODER)            += mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
+OBJS-$(CONFIG_H263P_ENCODER)           += mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
+OBJS-$(CONFIG_H264_DECODER)            += h264.o h264idct.o h264pred.o cabac.o golomb.o
+OBJS-$(CONFIG_H264_ENCODER)            += h264enc.o h264dspenc.o
+OBJS-$(CONFIG_HUFFYUV_DECODER)         += huffyuv.o
+OBJS-$(CONFIG_HUFFYUV_ENCODER)         += huffyuv.o
+OBJS-$(CONFIG_IDCIN_DECODER)           += idcinvideo.o
+OBJS-$(CONFIG_IMC_DECODER)             += imc.o mdct.o fft.o
+OBJS-$(CONFIG_INDEO2_DECODER)          += indeo2.o
+OBJS-$(CONFIG_INDEO3_DECODER)          += indeo3.o
+OBJS-$(CONFIG_INTERPLAY_VIDEO_DECODER) += interplayvideo.o
+OBJS-$(CONFIG_INTERPLAY_DPCM_DECODER)  += dpcm.o
+OBJS-$(CONFIG_JPEGLS_DECODER)          += jpeglsdec.o jpegls.o mjpegdec.o mjpeg.o golomb.o
+OBJS-$(CONFIG_JPEGLS_ENCODER)          += jpeglsenc.o jpegls.o golomb.o
+OBJS-$(CONFIG_KMVC_DECODER)            += kmvc.o
+OBJS-$(CONFIG_LJPEG_ENCODER)           += ljpegenc.o mjpegenc.o mjpeg.o mpegvideo_enc.o motion_est.o ratecontrol.o
+OBJS-$(CONFIG_LOCO_DECODER)            += loco.o golomb.o
+OBJS-$(CONFIG_MACE3_DECODER)           += mace.o
+OBJS-$(CONFIG_MACE6_DECODER)           += mace.o
+OBJS-$(CONFIG_MJPEG_DECODER)           += mjpegdec.o mjpeg.o
+OBJS-$(CONFIG_MJPEG_ENCODER)           += mjpegenc.o mjpeg.o mpegvideo_enc.o motion_est.o ratecontrol.o
+OBJS-$(CONFIG_MJPEGB_DECODER)          += mjpegbdec.o mjpegdec.o mjpeg.o
+OBJS-$(CONFIG_MMVIDEO_DECODER)         += mmvideo.o
+OBJS-$(CONFIG_MP2_DECODER)             += mpegaudiodec.o mpegaudiodecheader.o mpegaudio.o mpegaudiodata.o
+OBJS-$(CONFIG_MP2_ENCODER)             += mpegaudioenc.o mpegaudio.o mpegaudiodata.o
+OBJS-$(CONFIG_MP3_DECODER)             += mpegaudiodec.o mpegaudiodecheader.o mpegaudio.o mpegaudiodata.o
+OBJS-$(CONFIG_MP3ADU_DECODER)          += mpegaudiodec.o mpegaudiodecheader.o mpegaudio.o mpegaudiodata.o
+OBJS-$(CONFIG_MP3ON4_DECODER)          += mpegaudiodec.o mpegaudiodecheader.o mpegaudio.o mpegaudiodata.o
+OBJS-$(CONFIG_MPC7_DECODER)            += mpc.o mpegaudiodec.o mpegaudiodecheader.o mpegaudio.o mpegaudiodata.o
+OBJS-$(CONFIG_MPEG1VIDEO_ENCODER)      += mpeg12enc.o mpeg12data.o mpegvideo_enc.o motion_est.o ratecontrol.o
+OBJS-$(CONFIG_MPEG2VIDEO_ENCODER)      += mpeg12enc.o mpeg12data.o mpegvideo_enc.o motion_est.o ratecontrol.o
+OBJS-$(CONFIG_MPEG4_DECODER)           += h263dec.o h263.o
+OBJS-$(CONFIG_MPEG4_ENCODER)           += mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
+OBJS-$(CONFIG_MSMPEG4V1_DECODER)       += msmpeg4.o msmpeg4data.o h263dec.o h263.o
+OBJS-$(CONFIG_MSMPEG4V1_ENCODER)       += msmpeg4.o msmpeg4data.o mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
+OBJS-$(CONFIG_MSMPEG4V2_DECODER)       += msmpeg4.o msmpeg4data.o h263dec.o h263.o
+OBJS-$(CONFIG_MSMPEG4V2_ENCODER)       += msmpeg4.o msmpeg4data.o mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
+OBJS-$(CONFIG_MSMPEG4V3_DECODER)       += msmpeg4.o msmpeg4data.o h263dec.o h263.o
+OBJS-$(CONFIG_MSMPEG4V3_ENCODER)       += msmpeg4.o msmpeg4data.o mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
+OBJS-$(CONFIG_MSRLE_DECODER)           += msrle.o
+OBJS-$(CONFIG_MSVIDEO1_DECODER)        += msvideo1.o
+OBJS-$(CONFIG_MSZH_DECODER)            += lcldec.o
+OBJS-$(CONFIG_NELLYMOSER_DECODER)      += nellymoserdec.o
+OBJS-$(CONFIG_NUV_DECODER)             += nuv.o rtjpeg.o
+OBJS-$(CONFIG_PAM_ENCODER)             += pnmenc.o pnm.o
+OBJS-$(CONFIG_PBM_ENCODER)             += pnmenc.o pnm.o
+OBJS-$(CONFIG_PGM_ENCODER)             += pnmenc.o pnm.o
+OBJS-$(CONFIG_PGMYUV_ENCODER)          += pnmenc.o pnm.o
+OBJS-$(CONFIG_PNG_DECODER)             += png.o pngdec.o
+OBJS-$(CONFIG_PNG_ENCODER)             += png.o pngenc.o
+OBJS-$(CONFIG_PPM_ENCODER)             += pnmenc.o pnm.o
+OBJS-$(CONFIG_PTX_DECODER)             += ptx.o
+OBJS-$(CONFIG_QDM2_DECODER)            += qdm2.o mdct.o fft.o mpegaudiodec.o mpegaudiodecheader.o mpegaudio.o mpegaudiodata.o
+OBJS-$(CONFIG_QDRAW_DECODER)           += qdrw.o
+OBJS-$(CONFIG_QPEG_DECODER)            += qpeg.o
+OBJS-$(CONFIG_QTRLE_DECODER)           += qtrle.o
+OBJS-$(CONFIG_QTRLE_ENCODER)           += qtrleenc.o
+OBJS-$(CONFIG_RA_144_DECODER)          += ra144.o
+OBJS-$(CONFIG_RA_288_DECODER)          += ra288.o
+OBJS-$(CONFIG_RAWVIDEO_DECODER)        += rawdec.o
+OBJS-$(CONFIG_RAWVIDEO_ENCODER)        += rawenc.o
+OBJS-$(CONFIG_ROQ_DECODER)             += roqvideodec.o roqvideo.o
+OBJS-$(CONFIG_ROQ_ENCODER)             += roqvideoenc.o roqvideo.o elbg.o
+OBJS-$(CONFIG_ROQ_DPCM_DECODER)        += dpcm.o
+OBJS-$(CONFIG_ROQ_DPCM_ENCODER)        += roqaudioenc.o
+OBJS-$(CONFIG_RPZA_DECODER)            += rpza.o
+OBJS-$(CONFIG_RV10_DECODER)            += rv10.o h263.o
+OBJS-$(CONFIG_RV10_ENCODER)            += rv10.o mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
+OBJS-$(CONFIG_RV20_DECODER)            += rv10.o h263.o
+OBJS-$(CONFIG_RV20_ENCODER)            += rv10.o mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
+OBJS-$(CONFIG_SGI_DECODER)             += sgidec.o
+OBJS-$(CONFIG_SGI_ENCODER)             += sgienc.o rle.o
+OBJS-$(CONFIG_SHORTEN_DECODER)         += shorten.o golomb.o
+OBJS-$(CONFIG_SMACKAUD_DECODER)        += smacker.o
+OBJS-$(CONFIG_SMACKER_DECODER)         += smacker.o
+OBJS-$(CONFIG_SMC_DECODER)             += smc.o
+OBJS-$(CONFIG_SNOW_DECODER)            += snow.o rangecoder.o
+OBJS-$(CONFIG_SNOW_ENCODER)            += snow.o rangecoder.o motion_est.o ratecontrol.o h263.o
+OBJS-$(CONFIG_SOL_DPCM_DECODER)        += dpcm.o
+OBJS-$(CONFIG_SONIC_DECODER)           += sonic.o golomb.o
+OBJS-$(CONFIG_SONIC_ENCODER)           += sonic.o golomb.o
+OBJS-$(CONFIG_SONIC_LS_ENCODER)        += sonic.o golomb.o
+OBJS-$(CONFIG_SP5X_DECODER)            += sp5xdec.o mjpegdec.o mjpeg.o
+OBJS-$(CONFIG_SVQ1_DECODER)            += svq1dec.o svq1.o h263.o
+OBJS-$(CONFIG_SVQ1_ENCODER)            += svq1enc.o svq1.o motion_est.o h263.o
+OBJS-$(CONFIG_SVQ3_DECODER)            += h264.o h264idct.o h264pred.o cabac.o golomb.o
+OBJS-$(CONFIG_TARGA_DECODER)           += targa.o
+OBJS-$(CONFIG_TARGA_ENCODER)           += targaenc.o rle.o
+OBJS-$(CONFIG_THEORA_DECODER)          += vp3.o xiph.o vp3dsp.o
+OBJS-$(CONFIG_THP_DECODER)             += mjpegdec.o mjpeg.o
+OBJS-$(CONFIG_TIERTEXSEQVIDEO_DECODER) += tiertexseqv.o
+OBJS-$(CONFIG_TIFF_DECODER)            += tiff.o lzw.o
+OBJS-$(CONFIG_TIFF_ENCODER)            += tiffenc.o rle.o lzwenc.o
+OBJS-$(CONFIG_TRUEMOTION1_DECODER)     += truemotion1.o
+OBJS-$(CONFIG_TRUEMOTION2_DECODER)     += truemotion2.o
+OBJS-$(CONFIG_TRUESPEECH_DECODER)      += truespeech.o
+OBJS-$(CONFIG_TSCC_DECODER)            += tscc.o
+OBJS-$(CONFIG_TTA_DECODER)             += tta.o
+OBJS-$(CONFIG_TXD_DECODER)             += txd.o s3tc.o
+OBJS-$(CONFIG_ULTI_DECODER)            += ulti.o
+OBJS-$(CONFIG_VC1_DECODER)             += vc1.o vc1data.o vc1dsp.o msmpeg4data.o
+OBJS-$(CONFIG_VCR1_DECODER)            += vcr1.o
+OBJS-$(CONFIG_VCR1_ENCODER)            += vcr1.o
+OBJS-$(CONFIG_VMDAUDIO_DECODER)        += vmdav.o
+OBJS-$(CONFIG_VMDVIDEO_DECODER)        += vmdav.o
+OBJS-$(CONFIG_VMNC_DECODER)            += vmnc.o
+OBJS-$(CONFIG_VORBIS_DECODER)          += vorbis_dec.o vorbis.o vorbis_data.o xiph.o mdct.o fft.o
+OBJS-$(CONFIG_VORBIS_ENCODER)          += vorbis_enc.o vorbis.o vorbis_data.o mdct.o fft.o
+OBJS-$(CONFIG_VP3_DECODER)             += vp3.o vp3dsp.o
+OBJS-$(CONFIG_VP5_DECODER)             += vp5.o vp56.o vp56data.o vp3dsp.o
+OBJS-$(CONFIG_VP6_DECODER)             += vp6.o vp56.o vp56data.o vp3dsp.o huffman.o
+OBJS-$(CONFIG_VP6A_DECODER)            += vp6.o vp56.o vp56data.o vp3dsp.o huffman.o
+OBJS-$(CONFIG_VP6F_DECODER)            += vp6.o vp56.o vp56data.o vp3dsp.o huffman.o
+OBJS-$(CONFIG_VQA_DECODER)             += vqavideo.o
+OBJS-$(CONFIG_WAVPACK_DECODER)         += wavpack.o
+OBJS-$(CONFIG_WMAV1_DECODER)           += wmadec.o wma.o mdct.o fft.o
+OBJS-$(CONFIG_WMAV2_DECODER)           += wmadec.o wma.o mdct.o fft.o
+OBJS-$(CONFIG_WMAV1_ENCODER)           += wmaenc.o wma.o mdct.o fft.o
+OBJS-$(CONFIG_WMAV2_ENCODER)           += wmaenc.o wma.o mdct.o fft.o
+OBJS-$(CONFIG_WMV1_DECODER)            += h263dec.o h263.o
+OBJS-$(CONFIG_WMV1_ENCODER)            += mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
+OBJS-$(CONFIG_WMV2_DECODER)            += msmpeg4.o msmpeg4data.o h263dec.o h263.o
+OBJS-$(CONFIG_WMV2_ENCODER)            += msmpeg4.o msmpeg4data.o mpegvideo_enc.o motion_est.o ratecontrol.o h263.o
+OBJS-$(CONFIG_WMV3_DECODER)            += vc1.o vc1data.o vc1dsp.o
+OBJS-$(CONFIG_WNV1_DECODER)            += wnv1.o
+OBJS-$(CONFIG_WS_SND1_DECODER)         += ws-snd1.o
+OBJS-$(CONFIG_XAN_DPCM_DECODER)        += dpcm.o
+OBJS-$(CONFIG_XAN_WC3_DECODER)         += xan.o
+OBJS-$(CONFIG_XAN_WC4_DECODER)         += xan.o
+OBJS-$(CONFIG_XL_DECODER)              += xl.o
+OBJS-$(CONFIG_XSUB_DECODER)            += xsubdec.o
+OBJS-$(CONFIG_ZLIB_DECODER)            += lcldec.o
+OBJS-$(CONFIG_ZLIB_ENCODER)            += lclenc.o
+OBJS-$(CONFIG_ZMBV_DECODER)            += zmbv.o
+OBJS-$(CONFIG_ZMBV_ENCODER)            += zmbvenc.o
+
+OBJS-$(CONFIG_PCM_S32LE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S32LE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S32BE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S32BE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U32LE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U32LE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U32BE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U32BE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S24LE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S24LE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S24BE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S24BE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U24LE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U24LE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U24BE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U24BE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S24DAUD_DECODER)     += pcm.o
+OBJS-$(CONFIG_PCM_S24DAUD_ENCODER)     += pcm.o
+OBJS-$(CONFIG_PCM_S16LE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S16LE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S16BE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S16BE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U16LE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U16LE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U16BE_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_U16BE_ENCODER)       += pcm.o
+OBJS-$(CONFIG_PCM_S8_DECODER)          += pcm.o
+OBJS-$(CONFIG_PCM_S8_ENCODER)          += pcm.o
+OBJS-$(CONFIG_PCM_U8_DECODER)          += pcm.o
+OBJS-$(CONFIG_PCM_U8_ENCODER)          += pcm.o
+OBJS-$(CONFIG_PCM_ALAW_DECODER)        += pcm.o
+OBJS-$(CONFIG_PCM_ALAW_ENCODER)        += pcm.o
+OBJS-$(CONFIG_PCM_MULAW_DECODER)       += pcm.o
+OBJS-$(CONFIG_PCM_MULAW_ENCODER)       += pcm.o
+
+OBJS-$(CONFIG_ADPCM_4XM_DECODER)       += adpcm.o
+OBJS-$(CONFIG_ADPCM_4XM_ENCODER)       += adpcm.o
+OBJS-$(CONFIG_ADPCM_ADX_DECODER)       += adx.o
+OBJS-$(CONFIG_ADPCM_ADX_ENCODER)       += adx.o
+OBJS-$(CONFIG_ADPCM_CT_DECODER)        += adpcm.o
+OBJS-$(CONFIG_ADPCM_CT_ENCODER)        += adpcm.o
+OBJS-$(CONFIG_ADPCM_EA_DECODER)        += adpcm.o
+OBJS-$(CONFIG_ADPCM_EA_ENCODER)        += adpcm.o
+OBJS-$(CONFIG_ADPCM_G726_DECODER)      += g726.o
+OBJS-$(CONFIG_ADPCM_G726_ENCODER)      += g726.o
+OBJS-$(CONFIG_ADPCM_IMA_AMV_DECODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_DK3_DECODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_DK3_ENCODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_DK4_DECODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_DK4_ENCODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_QT_DECODER)    += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_QT_ENCODER)    += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_SMJPEG_DECODER) += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_SMJPEG_ENCODER) += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_WAV_DECODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_WAV_ENCODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_WS_DECODER)    += adpcm.o
+OBJS-$(CONFIG_ADPCM_IMA_WS_ENCODER)    += adpcm.o
+OBJS-$(CONFIG_ADPCM_MS_DECODER)        += adpcm.o
+OBJS-$(CONFIG_ADPCM_MS_ENCODER)        += adpcm.o
+OBJS-$(CONFIG_ADPCM_SBPRO_2_DECODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_SBPRO_2_ENCODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_SBPRO_3_DECODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_SBPRO_3_ENCODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_SBPRO_4_DECODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_SBPRO_4_ENCODER)   += adpcm.o
+OBJS-$(CONFIG_ADPCM_SWF_DECODER)       += adpcm.o
+OBJS-$(CONFIG_ADPCM_SWF_ENCODER)       += adpcm.o
+OBJS-$(CONFIG_ADPCM_THP_DECODER)       += adpcm.o
+OBJS-$(CONFIG_ADPCM_XA_DECODER)        += adpcm.o
+OBJS-$(CONFIG_ADPCM_XA_ENCODER)        += adpcm.o
+OBJS-$(CONFIG_ADPCM_YAMAHA_DECODER)    += adpcm.o
+OBJS-$(CONFIG_ADPCM_YAMAHA_ENCODER)    += adpcm.o
+
+# external codec libraries
+OBJS-$(CONFIG_LIBA52)                  += liba52.o
+OBJS-$(CONFIG_LIBAMR)                  += libamr.o
+OBJS-$(CONFIG_LIBFAAC)                 += libfaac.o
+OBJS-$(CONFIG_LIBFAAD)                 += libfaad.o
+OBJS-$(CONFIG_LIBGSM)                  += libgsm.o
+OBJS-$(CONFIG_LIBMP3LAME)              += libmp3lame.o
+OBJS-$(CONFIG_LIBTHEORA)               += libtheoraenc.o
+OBJS-$(CONFIG_LIBVORBIS)               += libvorbis.o
+OBJS-$(CONFIG_LIBX264)                 += libx264.o
+OBJS-$(CONFIG_LIBXVID)                 += libxvidff.o libxvid_rc.o
+
+
+OBJS-$(CONFIG_AAC_PARSER)              += aac_parser.o aac_ac3_parser.o
+OBJS-$(CONFIG_AC3_PARSER)              += ac3_parser.o ac3tab.o aac_ac3_parser.o
+OBJS-$(CONFIG_CAVSVIDEO_PARSER)        += cavs_parser.o
+OBJS-$(CONFIG_DCA_PARSER)              += dca_parser.o
+OBJS-$(CONFIG_DVBSUB_PARSER)           += dvbsub_parser.o
+OBJS-$(CONFIG_DVDSUB_PARSER)           += dvdsub_parser.o
+OBJS-$(CONFIG_H261_PARSER)             += h261_parser.o
+OBJS-$(CONFIG_H263_PARSER)             += h263_parser.o
+OBJS-$(CONFIG_H264_PARSER)             += h264_parser.o
+OBJS-$(CONFIG_MJPEG_PARSER)            += mjpeg_parser.o
+OBJS-$(CONFIG_MPEG4VIDEO_PARSER)       += mpeg4video_parser.o h263.o
+OBJS-$(CONFIG_MPEGAUDIO_PARSER)        += mpegaudio_parser.o mpegaudiodecheader.o mpegaudiodata.o
+OBJS-$(CONFIG_MPEGVIDEO_PARSER)        += mpegvideo_parser.o
+OBJS-$(CONFIG_PNM_PARSER)              += pnm_parser.o pnm.o
+OBJS-$(CONFIG_VC1_PARSER)              += vc1_parser.o
+
+OBJS-$(CONFIG_DUMP_EXTRADATA_BSF)      += dump_extradata_bsf.o
+OBJS-$(CONFIG_H264_MP4TOANNEXB_BSF)    += h264_mp4toannexb_bsf.o
+OBJS-$(CONFIG_IMX_DUMP_HEADER_BSF)     += imx_dump_header_bsf.o
+OBJS-$(CONFIG_MJPEGA_DUMP_HEADER_BSF)  += mjpega_dump_header_bsf.o
+OBJS-$(CONFIG_MP3_HEADER_COMPRESS_BSF) += mp3_header_compress_bsf.o
+OBJS-$(CONFIG_MP3_HEADER_DECOMPRESS_BSF) += mp3_header_decompress_bsf.o mpegaudiodata.o
+OBJS-$(CONFIG_NOISE_BSF)               += noise_bsf.o
+OBJS-$(CONFIG_REMOVE_EXTRADATA_BSF)    += remove_extradata_bsf.o
+
+OBJS-$(HAVE_BEOSTHREADS)               += beosthread.o
+OBJS-$(HAVE_OS2THREADS)                += os2thread.o
+OBJS-$(HAVE_PTHREADS)                  += pthread.o
+OBJS-$(HAVE_W32THREADS)                += w32thread.o
+
+OBJS-$(HAVE_XVMC_ACCEL)                += xvmcvideo.o
+
+ifneq ($(CONFIG_SWSCALER),yes)
+OBJS += imgresample.o
+endif
+
+# processor-specific code
+ifeq ($(HAVE_MMX),yes)
+OBJS += i386/fdct_mmx.o \
+        i386/cputest.o \
+        i386/dsputil_mmx.o \
+        i386/mpegvideo_mmx.o \
+        i386/motion_est_mmx.o \
+        i386/simple_idct_mmx.o \
+        i386/idct_mmx_xvid.o \
+        i386/fft_sse.o \
+        i386/fft_3dn.o \
+        i386/fft_3dn2.o \
+
+OBJS-$(CONFIG_GPL)                     += i386/idct_mmx.o
+
+OBJS-$(CONFIG_CAVS_DECODER)            += i386/cavsdsp_mmx.o
+OBJS-$(CONFIG_SNOW_DECODER)            += i386/snowdsp_mmx.o
+OBJS-$(CONFIG_VP3_DECODER)             += i386/vp3dsp_mmx.o i386/vp3dsp_sse2.o
+OBJS-$(CONFIG_VP5_DECODER)             += i386/vp3dsp_mmx.o i386/vp3dsp_sse2.o
+OBJS-$(CONFIG_VP6_DECODER)             += i386/vp3dsp_mmx.o i386/vp3dsp_sse2.o
+OBJS-$(CONFIG_VP6A_DECODER)            += i386/vp3dsp_mmx.o i386/vp3dsp_sse2.o
+OBJS-$(CONFIG_VP6F_DECODER)            += i386/vp3dsp_mmx.o i386/vp3dsp_sse2.o
+endif
+
+ASM_OBJS-$(ARCH_ARMV4L)                += armv4l/jrevdct_arm.o     \
+                                          armv4l/simple_idct_arm.o \
+                                          armv4l/dsputil_arm_s.o   \
+
+OBJS-$(ARCH_ARMV4L)                    += armv4l/dsputil_arm.o   \
+                                          armv4l/mpegvideo_arm.o \
+
+OBJS-$(HAVE_IWMMXT)                    += armv4l/dsputil_iwmmxt.o   \
+                                          armv4l/mpegvideo_iwmmxt.o \
+
+ASM_OBJS-$(HAVE_ARMV5TE)               += armv4l/simple_idct_armv5te.o \
+                                          armv4l/mpegvideo_armv5te.o \
+
+ASM_OBJS-$(HAVE_ARMV6)                 += armv4l/simple_idct_armv6.o \
+
+OBJS-$(HAVE_VIS)                       += sparc/dsputil_vis.o \
+                                          sparc/simple_idct_vis.o \
+
+OBJS-$(HAVE_MLIB)                      += mlib/dsputil_mlib.o \
+
+OBJS-$(ARCH_ALPHA)                     += alpha/dsputil_alpha.o     \
+                                          alpha/motion_est_alpha.o  \
+                                          alpha/mpegvideo_alpha.o   \
+                                          alpha/simple_idct_alpha.o \
+
+ASM_OBJS-$(ARCH_ALPHA)                 += alpha/dsputil_alpha_asm.o  \
+                                          alpha/motion_est_mvi_asm.o \
+
+OBJS-$(ARCH_POWERPC)                   += ppc/dsputil_ppc.o   \
+
+OBJS-$(HAVE_MMI)                       += ps2/dsputil_mmi.o   \
+                                          ps2/idct_mmi.o      \
+                                          ps2/mpegvideo_mmi.o \
+
+OBJS-$(ARCH_SH4)                       += sh4/idct_sh4.o      \
+                                          sh4/dsputil_align.o \
+                                          sh4/dsputil_sh4.o   \
+
+ALTIVEC-OBJS-yes                       += ppc/dsputil_altivec.o      \
+                                          ppc/fdct_altivec.o         \
+                                          ppc/fft_altivec.o          \
+                                          ppc/float_altivec.o        \
+                                          ppc/gmc_altivec.o          \
+                                          ppc/idct_altivec.o         \
+                                          ppc/int_altivec.o          \
+                                          ppc/mpegvideo_altivec.o    \
+
+ALTIVEC-OBJS-$(CONFIG_H264_DECODER)    += ppc/h264_altivec.o
+ALTIVEC-OBJS-$(CONFIG_SNOW_DECODER)    += ppc/snow_altivec.o
+ALTIVEC-OBJS-$(CONFIG_VC1_DECODER)     += ppc/vc1dsp_altivec.o
+ALTIVEC-OBJS-$(CONFIG_WMV3_DECODER)    += ppc/vc1dsp_altivec.o
+
+# -maltivec is needed in order to build AltiVec code.
+$(ALTIVEC-OBJS-yes): CFLAGS += -maltivec -mabi=altivec
+
+# check_altivec must be built without -maltivec
+OBJS-$(HAVE_ALTIVEC)                   += $(ALTIVEC-OBJS-yes)       \
+                                          ppc/check_altivec.o
+
+OBJS-$(ARCH_BFIN)                      += bfin/dsputil_bfin.o \
+                                          bfin/mpegvideo_bfin.o \
+                                          bfin/vp3_bfin.o \
+
+ASM_OBJS-$(ARCH_BFIN)                  += bfin/pixels_bfin.o \
+                                          bfin/fdct_bfin.o   \
+                                          bfin/idct_bfin.o   \
+                                          bfin/vp3_idct_bfin.o   \
+
+EXTRALIBS := -L$(BUILD_ROOT)/libavutil -lavutil$(BUILDSUF) $(EXTRALIBS)
+
+NAME=avcodec
+LIBVERSION=$(LAVCVERSION)
+LIBMAJOR=$(LAVCMAJOR)
+
+include ../common.mak
+
+clean::
+	rm -f \
+	   alpha/*.o alpha/*~ \
+	   armv4l/*.o armv4l/*~ \
+	   bfin/*.o bfin/*~ \
+	   i386/*.o i386/*~ \
+	   mlib/*.o mlib/*~ \
+	   ppc/*.o ppc/*~ \
+	   ps2/*.o ps2/*~ \
+	   sh4/*.o sh4/*~ \
+	   sparc/*.o sparc/*~ \
+	   apiexample $(TESTS)
+
+TESTS= imgresample-test fft-test dct-test
+ifeq ($(ARCH_X86),yes)
+TESTS+= cpuid-test motion-test
+endif
+
+tests: apiexample $(TESTS)
+
+apiexample: apiexample.o $(LIB)
+
+cpuid-test: i386/cputest.c
+	$(CC) $(CFLAGS) -DTEST -o $@ $<
+
+dct-test: dct-test.o fdctref.o $(LIB)
+
+fft-test: fft-test.o $(LIB)
+
+imgresample-test: imgresample.c $(LIB)
+	$(CC) $(CFLAGS) -DTEST -o $@ $^ $(EXTRALIBS)
+
+motion-test: motion-test.o $(LIB)
+
+.PHONY: tests
diff -ruN mplayer.orig/libavformat/wav.c mplayer.eac3/libavformat/wav.c
--- mplayer.orig/libavformat/wav.c	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/libavformat/wav.c	2007-10-19 14:13:32.000000000 +0300
@@ -38,7 +38,7 @@
     offset_t fmt, fact;
 
     put_tag(pb, "RIFF");
-    put_le32(pb, 0); /* file length */
+    put_le32(pb, 36); // by the moment header length send
     put_tag(pb, "WAVE");
 
     /* format header */
diff -ruN mplayer.orig/etc/codecs.conf mplayer.eac3/etc/codecs.conf
--- mplayer.orig/etc/codecs.conf	2007-10-16 14:31:19.000000000 +0300
+++ mplayer.eac3/etc/codecs.conf	2007-10-19 16:49:24.000000000 +0300
@@ -2747,6 +2747,13 @@
   driver ffmpeg
   dll "ape"
 
+audiocodec ffeac3
+    info "FFmpeg EAC3"
+    status working
+    format 0x0
+    driver ffmpeg
+    dll "E-AC3"
+
 audiocodec pcm
   info "Uncompressed PCM"
   status working
