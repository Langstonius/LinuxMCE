#! /bin/sh /usr/share/dpatch/dpatch-run
## 19_serial_support.dpatch by Mario Limonciello <superm1@ubuntu.com>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad lirc-0.8.2~/drivers/lirc_serial/lirc_serial.c lirc-0.8.2/drivers/lirc_serial/lirc_serial.c
--- lirc-0.8.2~/drivers/lirc_serial/lirc_serial.c	2007-09-05 11:34:28.000000000 -0500
+++ lirc-0.8.2/drivers/lirc_serial/lirc_serial.c	2007-09-05 11:34:46.000000000 -0500
@@ -1,4 +1,4 @@
-/*      $Id: lirc_serial.c,v 5.80 2007/05/11 16:40:24 lirc Exp $      */
+/*      $Id: lirc_serial.c,v 5.83 2007/08/30 19:35:42 lirc Exp $      */
 
 /****************************************************************************
  ** lirc_serial.c ***********************************************************
@@ -63,6 +63,15 @@
 
 #include <linux/autoconf.h>
 
+#if defined(CONFIG_SERIAL) || defined(CONFIG_SERIAL_8250)
+#warning "******************************************"
+#warning " Your serial port driver is compiled into "
+#warning " the kernel. You will have to release the "
+#warning " port you want to use for LIRC with:      "
+#warning "    setserial /dev/ttySx uart none        "
+#warning "******************************************"
+#endif
+
 #include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/signal.h>
@@ -96,6 +105,10 @@
 /* ftp://download.intel.com/design/network/manuals/25248005.pdf */
 #define UART_IE_IXP42X_UUE   0x40 /* IXP42X UART Unit enable */
 #define UART_IE_IXP42X_RTOIE 0x10 /* IXP42X Receiver Data Timeout int.enable */
+#ifndef NSLU2_LED_GRN_GPIO
+/* added in 2.6.22 */
+#define NSLU2_LED_GRN_GPIO NSLU2_LED_GRN
+#endif
 #endif
 
 #include "drivers/lirc.h"
@@ -411,7 +424,7 @@
 	   status LED and ground */
 	if(type == LIRC_NSLU2)
 	{
-		gpio_line_set(NSLU2_LED_GRN, IXP4XX_GPIO_LOW);
+		gpio_line_set(NSLU2_LED_GRN_GPIO, IXP4XX_GPIO_LOW);
 		return;
 	}
 #endif
@@ -430,7 +443,7 @@
 #if defined(LIRC_SERIAL_NSLU2)
 	if(type == LIRC_NSLU2)
 	{
-		gpio_line_set(NSLU2_LED_GRN, IXP4XX_GPIO_HIGH);
+		gpio_line_set(NSLU2_LED_GRN_GPIO, IXP4XX_GPIO_HIGH);
 		return;
 	}
 #endif
@@ -751,6 +764,7 @@
 	int status,counter,dcd;
 	long deltv;
 	lirc_t data;
+	static int last_dcd = -1;
 	
 	if((sinp(UART_IIR) & UART_IIR_NO_INT))
 	{
@@ -798,6 +812,16 @@
 			   microseconds */
 			dcd=(status & hardware[type].signal_pin) ? 1:0;
 			
+			if(dcd == last_dcd) 
+			{
+				printk(KERN_WARNING LIRC_DRIVER_NAME
+				       ": ignoring spike: %d %d %lx %lx %lx %lx\n",
+				       dcd,sense,
+				       tv.tv_sec,lasttv.tv_sec,
+				       tv.tv_usec,lasttv.tv_usec);
+				continue;
+			}
+				
 			deltv=tv.tv_sec-lasttv.tv_sec;
 			if(tv.tv_sec<lasttv.tv_sec ||
 			   (tv.tv_sec==lasttv.tv_sec &&
@@ -819,7 +843,7 @@
 				if(!(dcd^sense)) /* sanity check */
 				{
 					printk(KERN_WARNING LIRC_DRIVER_NAME
-					       "AIEEEE: %d %d %lx %lx %lx %lx\n",
+					       ": AIEEEE: %d %d %lx %lx %lx %lx\n",
 					       dcd,sense,
 					       tv.tv_sec,lasttv.tv_sec,
 					       tv.tv_usec,lasttv.tv_usec);
@@ -836,6 +860,7 @@
 			}
 			frbwrite(dcd^sense ? data : (data|PULSE_BIT));
 			lasttv=tv;
+			last_dcd = dcd;
 			wake_up_interruptible(&rbuf.wait_poll);
 		}
 	} while(!(sinp(UART_IIR) & UART_IIR_NO_INT)); /* still pending ? */
@@ -1228,22 +1253,36 @@
 {
 	int result;
 
-	lirc_serial_dev = platform_device_alloc("lirc_serial", 0);
-	if (!lirc_serial_dev)
-		return -ENOMEM;
-	result = platform_device_add(lirc_serial_dev);
-	if (result) {
-		platform_device_put(lirc_serial_dev);
-		return result;
-	}
 	result = platform_driver_register(&lirc_serial_driver);
 	if (result) {
 		printk("lirc register returned %d\n", result);
-		platform_device_del(lirc_serial_dev);
-		platform_device_put(lirc_serial_dev);
 		return result;
 	}
+
+	lirc_serial_dev = platform_device_alloc("lirc_serial", 0);
+	if (!lirc_serial_dev) {
+		result = -ENOMEM;
+		goto exit_driver_unregister;
+	}
+
+	result = platform_device_add(lirc_serial_dev);
+	if (result) {
+		goto exit_device_put;
+	}
+
 	return 0;
+
+exit_device_put:
+	platform_device_put(lirc_serial_dev);
+exit_driver_unregister:
+	platform_driver_unregister(&lirc_serial_driver);
+	return result;
+}
+
+static void __exit lirc_serial_exit(void)
+{
+	platform_device_unregister(lirc_serial_dev);
+	platform_driver_unregister(&lirc_serial_driver);
 }
 #endif
 
@@ -1253,7 +1292,9 @@
 	
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
 	result = lirc_serial_init();
-	if(result) return result;
+	if(result) {
+		return result;
+	}
 #endif
 	switch(type)
 	{
@@ -1267,7 +1308,8 @@
 #endif
 		break;
 	default:
-		return -EINVAL;
+		result = -EINVAL;
+		goto exit_serial_exit;
 	}
 	if(!softcarrier)
 	{
@@ -1284,27 +1326,25 @@
 	}
 	if((result = init_port()) < 0)
 	{
-		return result;
+		goto exit_serial_exit;
 	}
 	plugin.features = hardware[type].features;
 	if ((plugin.minor = lirc_register_plugin(&plugin)) < 0) {
 		printk(KERN_ERR  LIRC_DRIVER_NAME  
 		       ": register_chrdev failed!\n");
-		release_region(io, 8);
-		return -EIO;
+		result = -EIO;
+		goto exit_release;
 	}
 	return 0;
-}
 
+exit_release:
+	release_region(io, 8);
+exit_serial_exit:
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
-static void __exit lirc_serial_exit(void)
-{
-	struct platform_device *pdev = lirc_serial_dev;
-	lirc_serial_dev = NULL;
-	platform_driver_unregister(&lirc_serial_driver);
-	platform_device_unregister(pdev);
-}
+	lirc_serial_exit();
 #endif
+	return result;
+}
 
 void __exit cleanup_module(void)
 {
