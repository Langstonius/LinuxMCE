#! /usr/bin/perl -w

#   Written by Diego Iastrubni <diego.iastrubni@xorcom.com>
#   Copyright (C) 2005, 2007 Xorcom
#  
#   All rights reserved.
#  
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#  
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#  
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  

# read /etc/zaptel.conf and for each FXS channel found
# generate AMP configuration, by writing directly to
# mysql, and writing to asterisk DB
#
# the basis of the configurtaion will be taken from a template
# which will be applied to each FXS channel found.
#
# Digital NT spans will be consideted some sort of "phones". They
# will be assumed to be ISDN PRI/BRI and configured accordingly.

use strict;
use DBI;
	
my @zapinfo;
my @zap_template;
my $zaptel_conf = "/etc/zaptel.conf";
my $zap_template_name = "/usr/share/freepbx-common/zap.template";
my $amportal_conf = "/etc/amportal.conf";
my $ampconf;

# database connection, lazy code
my $dbh;
my $sql_statement;
my $result;

# start counting zap-extentions from 400, just like in good old Rapid...
# may be modified from amportal.conf
my $extension_num = 401;
# the following two are used to follow hints from genzaptelconf in zaptel.conf
# that require context-awareness.
my $termtype = '';
my $astbanktype = '';

# we detect on runtime which freepbx to support
my $freepbx_version;


my $debug = 0;


#####################
# functions

# sub print_db_errors
# -------------------
#
# in case of a dbi error, this sub will print all needed information to the user
#
sub print_db_errors
{
	print "dbh->selectall_arrayref($sql_statement) failed!\n";
	print "DBI::err=[$DBI::err]\n";
	print "DBI::errstr=[$DBI::errstr]\n";
}

# sub clear_zaptel_from_sql
# -------------------------
# read the available zap channels on mysql, and then
# delete them and the corresponding extension
sub clear_zaptel_from_sql
{
 	$sql_statement = "SELECT id FROM `zap` WHERE keyword = 'account'";
 	$result = $dbh->selectall_arrayref($sql_statement);
 	unless ($result) 
 	{
 		print_db_errors();
 		die("Could not connect to database");
 	}
	
	foreach my $row ( @{ $result } ) 
	{
		my $id = @{ $row }[0];
		if ($debug==1) { print "Deleting ZAPATA channel $id\n"; }
		
		$sql_statement = "DELETE FROM `extensions` WHERE `extension` = '$id'";
		unless ($dbh->do( $sql_statement ) )
		{
			print_db_errors();
			exit(-1);
		}
		
		if ($debug==1) { printf( "$sql_statement\n" ); }
		
		$sql_statement = "DELETE FROM `zap` WHERE `id` = '$id'";
		unless ($dbh->do( $sql_statement ) )
		{
			print_db_errors();
			exit(-1);
		}
		
		$sql_statement = "DELETE FROM `users` WHERE `extension` = '$id'";
		if ($debug==1) { printf( "$sql_statement\n" ); }
		$dbh->do( $sql_statement );
		unless ($dbh->do( $sql_statement ) )
		{
			print_db_errors();
			exit(-1);
		}
	
		$sql_statement = "DELETE FROM `devices` WHERE `id` = '$id' and `tech` = 'zap'";
		if ($debug==1) { printf( "$sql_statement\n" ); }
		$dbh->do( $sql_statement );
		unless ($dbh->do( $sql_statement ) )
		{
			print_db_errors();
			exit(-1);
		}
	}
}	

# sub reg_channel
# ---------------
# stores values into tables "zap", "extensions", "users" and "devices"
# TODO: 
# split this huge function into 5 functions, one for each database. and last
# for astdb.
# if possible move the function up (currently needs the $dbh connection
sub reg_channel($$) 
{
	my ($channel, $data) = @_;
	my $extension =  $extension_num;
	
	$sql_statement = "SELECT * FROM `devices` where dial='ZAP/$channel'";
	$result = @{ $dbh->selectall_arrayref($sql_statement) };
	
	if (  $result != 0 )
	{
		# channel already registered
		return;
	} 
	
	my $name = "ZAP channel $channel";
	$data->{EXTENSION} = $extension;
	$data->{CHANNEL} = $channel;
	$data->{GROUP} = 5;
	$data->{IMMEDIATE} = 'no';
	$data->{CONTEXT} = 'from-internal';
	if ($astbanktype ne '' ){
		$data->{CONTEXT} = $astbanktype;
		if ($astbanktype eq 'input') {
			$data->{IMMEDIATE} = 'yes';
		}
	}
	$data->{NAME}    = $name;

	my @extra_lines = ();
	if (exists $data->{SWITCHTYPE}) {
		push @extra_lines,("switchtype\t__SWITCHTYPE__");
	}

	# sql table - zap
	foreach my $line (@extra_lines,@zap_template)
	{
		$_ = $line;
		chomp;
		next if /^#/;
		next unless /\S/;
		
		s/__([A-Z]*)__/$data->{$1}/g;
		
		# the keyword is the first word before the TAB,
		# the data, is everything
		my ($sql_keyword, $sql_data) = split(/\s+/, $_, 2);
		if ($sql_keyword && $sql_data)
		{
			$sql_statement = "INSERT INTO zap VALUES ('$extension_num','$sql_keyword','$sql_data',0)";
			if ($debug==1) { printf( "$sql_statement\n" ); }
			unless ($dbh->do( $sql_statement ) )
			{
				print_db_errors();
				exit(-1);
			}
		}
	}

	# sql table - extensions
	my $context = "ext-local";
	my $priority = "1";
	my $application = "Macro";
	my $args = "exten-vm\\,novm\\,$extension_num";
	my $descr = "NULL";
	my $flags = "0";

	$sql_statement = "INSERT INTO extensions VALUES ('$context','$extension','$priority','$application','$args',$descr,'$flags')\n";
	if ($debug==1) { printf( "$sql_statement\n" ); }
	unless ($dbh->do( $sql_statement ) )
	{
		print_db_errors();
		exit(-1);
	}


# CREATE TABLE `users` (
#   `extension` varchar(20) NOT NULL default '',
#   `password` varchar(20) default NULL,
#   `name` varchar(50) default NULL,
#   `voicemail` varchar(50) default NULL,
#   `ringtimer` int(3) default NULL,
#   `noanswer` varchar(100) default NULL,
#   `recording` varchar(50) default NULL,
#   `outboundcid` varchar(50) default NULL,
#   `directdid` varchar(50) default NULL,
#   `didalert` varchar(50) default NULL,
#   `faxexten` varchar(20) default NULL,
#   `faxemail` varchar(50) default NULL,
#   `answer` tinyint(1) default NULL,
#   `wait` int(2) default NULL,
#   `privacyman` tinyint(1) default NULL
# ) ;

	# sql table - users
	$extension	= $extension_num;
	my $password	= "";	# no password is set for zaptel devices
	my $voicemail	= "";	# give mo voicemail by default
	my $ringtimer	= "0"; 
	my $noanswer	= "";
	my $recording	= "out=Adhoc|in=Adhoc" ;
	my $outboundcid	= "";
	my $directdid	= "";
	my $didalert	= "";
	my $faxexten	= "";
	my $faxemail	= "";
	my $answer	= "";
	my $wait	= "";
	my $privacyman	= "";

	if ($freepbx_version eq "2.1") {
		$sql_statement = "INSERT INTO users VALUES ( '$extension', '$password', '$name', '$voicemail', '$ringtimer', '$noanswer', '$recording', '$outboundcid', '$directdid', '$didalert' )\n";
	}
	elsif ($freepbx_version eq "2.2") {
		$sql_statement = "INSERT INTO users VALUES ( '$extension', '$password', '$name', '$voicemail', '$ringtimer', '$noanswer', '$recording', '$outboundcid', '$directdid', '$didalert', '$faxexten', '$faxemail', '$answer', '$wait', '$privacyman' )\n";
	}
	
	if ($debug==1) { printf( "$sql_statement\n" ); }
	unless ($dbh->do( $sql_statement ) )
	{
		print_db_errors();
		exit(-1);
	}
	if ($debug==1) { printf ( "Extension: $name - $extension_num \n" ); }

	# sql table - devices
	my $dial = "ZAP/$channel";
	$sql_statement = "INSERT INTO devices VALUES ('$extension_num','zap','$dial','fixed', '$extension_num','$name','')";
	if ($debug==1) { printf( "$sql_statement\n" ); }
	unless ($dbh->do( $sql_statement ) )
	{
		print_db_errors();
		exit(-1);
	}

	$extension_num++;
} #sub reg_channel end


sub parse_amportal_conf
{
        my $filename = $_[0];
        my %ampconf;

        open(AMPCONF, $filename) || die "Cannot open $filename";

        while (<AMPCONF>)
        {
                if ($_ =~ /^\s*([a-zA-Z0-9_]+)\s*=\s*(.*)\s*([;#].*)?/)
                {
                        $ampconf{$1} = $2;
                }
        }
        close(AMPCONF);

        return \%ampconf;
}

#####################
# main

# fist parse amportal.conf to get the correct information
# about the username and password for mysql
$ampconf = parse_amportal_conf( "/etc/amportal.conf" );

my $database  = "asterisk";
my $hostname  = $$ampconf{"AMPDBHOST"}; 
my $username  = $$ampconf{"AMPDBUSER"};
my $password  = $$ampconf{"AMPDBPASS"};
my $db_engine = "mysql";
if (exists($ampconf->{"AMPDBENGINE"})) {
	$db_engine = $ampconf->{"AMPDBENGINE"};
}

# connect to the DB
if ( $db_engine eq "mysql" ) {
	$dbh = DBI->connect("dbi:mysql:dbname=$database;host=$hostname", "$username", "$password");
}
elsif ( $db_engine eq "pgsql" ) {
	$dbh = DBI->connect("dbi:pgsql:dbname=$database;host=$hostname", "$username", "$password");
}
elsif ( $db_engine eq "sqlite" ) {
	if (!exists($ampconf->{"AMPDBFILE"})) {
		print "No AMPDBFILE set in /etc/amportal.conf\n";
		exit;
	}
	
	my $db_file = $ampconf->{"AMPDBFILE"};
	$dbh = DBI->connect("dbi:SQLite2:dbname=$db_file","","");
}
elsif ( $db_engine eq "sqlite3" ) {
	if (!exists($ampconf->{"AMPDBFILE"})) {
		print "No AMPDBFILE set in /etc/amportal.conf\n";
		exit;
	}
	
	my $db_file = $ampconf->{"AMPDBFILE"};
	$dbh = DBI->connect("dbi:SQLite:dbname=$db_file","","");
}


# detect freepbx version, 2.1 or 2.2
# this script supports both 2.1 and 2.2 versions
$sql_statement = "SELECT value FROM admin WHERE variable = 'version'";
if ($debug==1) { printf( "$sql_statement\n" ); }
$result = $dbh->selectall_arrayref($sql_statement);
unless ($result) 
{
	print_db_errors();
	die("Could not connect to database");
}

foreach my $row ( @{ $result } ) 
{
	my $version = @{ $row }[0];
	if ( $version =~ /^2\.1/ ){
		if ($debug==1) { printf( "Using freePBX 2.1\n" ); }
		$freepbx_version = "2.1";
	}
	elsif ( $version =~ /^2\.2/ ){
		if ($debug==1) { printf( "Using freePBX 2.2\n" ); }
		$freepbx_version = "2.2";
	}
	else{
		die("Unsupported freePBX version : " . $version );
	}
}

##################
# supported version is only 2.2.X
#
# you are probablably wondering why this is written, specially
# since this code is will work with 2.1
# the reason is that fix_ast_db is harder to fix to work with both versions
# and the best is to fail the HW detection in this phase.
# if someone managed to make fix_ast_db to work with
# 2.1.3, I will uncomment the next few lines
#
# - diego
#if ($freepbx_version ne "2.2") {
#	die("Unsupported freePBX version : " . $freepbx_version );
#}

# try and get the first ZAP number configured in amportal.conf
# if none found, we still have the good old default
if ( ! $$ampconf{"ZAP_FIRST_CHANNEL"} eq "" )
{
	$extension_num = $$ampconf{"ZAP_FIRST_CHANNEL"};
}

# read the zaptel.conf file, and latter on parse it
open( PROC_ENTRY, $zaptel_conf ) or die( "Cannot read $zaptel_conf, aborting." );
@zapinfo = <PROC_ENTRY>;
close( PROC_ENTRY );

# read the template in advance
open( ZAP_TEMPLATE, $zap_template_name ) or die( "Cannot read $zap_template_name, aborting." );
@zap_template = <ZAP_TEMPLATE>;
close( ZAP_TEMPLATE );

# delete the old information found in the database
clear_zaptel_from_sql();

# for each zaptel channel found in $zaptel_conf, if it provides FXO signalling,
# then it's an FXS. Apply the template to that line, and generate
# SQL statements for adding the zap channel and then the new extension.
foreach my $line (@zapinfo)
{
	if ( $line =~ /\s*fxo([kl]s)\s*=\s*(\d*)/ )
	{
		reg_channel($2,{SIGNALLING=>"fxo_$1"});
		$astbanktype = '';
	}
	elsif ( $line =~ /^# termtype: ([a-z]*)/) 
	{
		$termtype = $1;
	}
	elsif ( $line =~ /^# astbanktype: ([a-z]*)/) 
	{
		$astbanktype = $1;
	}
	elsif ( ($line =~ /\s*bchan\s*=\s*([0-9]*)(-([0-9]*|))/) && 
	  ($termtype eq 'nt') ) 
	{
		my $chan = $1;
		my $chan_last = $chan;
		$termtype = '';

		if (defined $3) 
		{
			$chan_last = $3;
		}

		# FIXME: we guess the signalling from the span length
		# and not using what genzaptelconf used:
		my $signalling = 'pri_net';
		if ($chan_last - $chan == 1) {
			$signalling = 'bri_net_ptmp';
		}
		for my $i ($chan .. $chan_last) 
		{
			reg_channel($i,{
				SIGNALLING=>$signalling, 
				SWITCHTYPE=>'euroisdn'
			});
		}
	}
} # end - foreach my $line (@zapinfo)

# need reload:
# - this will ensure that the user at least reloads asterisk,
#   he will usually need to restart asterisk, 
# - on TS1 it will force the user to save the configuration
$sql_statement = "UPDATE admin SET value = 'true' WHERE variable = 'need_reload'";
unless ($dbh->do( $sql_statement ) )
{
	print_db_errors();
	exit(-1);
}

if ($debug==1) { print( "Done\n" ); }
