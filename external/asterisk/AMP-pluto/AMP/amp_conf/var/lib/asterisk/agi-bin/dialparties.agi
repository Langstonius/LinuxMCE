#!/usr/bin/perl -w
#
# Copyright (C) 2003 Zac Sprackett <zsprackett-asterisk@sprackett.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# Amended by Coalescent Systems Inc. Sept, 2004
# to include support for DND, Call Waiting, and CF to external trunk
# info@coalescentsystems.ca

use Asterisk::AGI;
use Net::Telnet ();

my $debug = 2;

my %ext;     # Hash that will contain our list of extensions to call
my $cidnum;  # Caller ID Number for this call
my $cidname; # Caller ID Name for this call
my $timer;   # Call timer for Dial command
my $dialopts;# options for dialing
my $rc;      # Catch return code
my $priority;# Next priority 

my $AGI = new Asterisk::AGI;
my %input = $AGI->ReadParse();
$AGI->setcallback(\&mycallback);

if ($debug >= 2) {
  foreach $key (keys %input) {
    debug("$key = " . $input{$key},3);
  }
}
$priority = $input{'priority'} + 1;

if ($input{'callerid'} =~  /^\"(.*)\"\s+\<(\d+)-?(\d*)\>\s*$/) {
  $cidname = $1;
  $cidnum  = $2.$3;
  debug("Caller ID name is '$cidname' number is '$cidnum'", 1);
} elsif ($input{'callerid'} =~  /^(\d+)*$/) {
  $cidname = $1;
  $cidnum  = $1;
  debug("Caller ID name and number are '$cidnum'", 1);
} else {
  $cidname = undef;
  $cidnum  = undef;
  debug("Caller ID is not set", 1);
}

$timer = $AGI->get_variable('ARG1') || 0;
$dialopts = $AGI->get_variable('ARG2') || '';

# Start with Arg Count set to 3 as two args are used
my $arg_cnt = 3;
while(my $arg = $AGI->get_variable('ARG' . $arg_cnt)) {
  if ($arg == 'noresponse') {  #not sure why, dialparties will get stuck in a loop if noresponse
  	debug("get_variable got a \"noresponse\"!  Exiting");
  	exit($arg_cnt);
  }
  @extarray=split(/-/,$arg);
  foreach my $k (@extarray) {
    $ext{$k} = $k;
    debug("Added extension $k to extension map", 3);
  }
  
  $arg_cnt++;
}

# Check for call forwarding first
# If call forward is enabled, we use chan_local
foreach my $k (keys %ext) {
  my $cf  = $AGI->database_get('CF',$k);
  if ($cf) {
    $ext{$k} = $cf.'#';  # append a hash sign so we can send out on chan_local below.
    debug("Extension $k has call forward set to $cf", 1);
  } else {
    debug("Extension $k cf is disabled", 3);
  }
}

# Now check for DND
foreach my $k (keys %ext) {
	if (($ext{$k} =~ /\#/)!=1) {   #no point in doing if cf is enabled
		my $dnd = $AGI->database_get('DND',$ext{$k});
		if ($dnd) {
			debug("Extension $ext{$k} has do not disturb enabled", 1);
			delete $ext{$k};
		} else {
			debug("Extension $ext{$k} do not disturb is disabled", 3);
		}
	}
}

# Now check for call waiting
# first let's see which channels are on a call

$schannels=&get_active_sip;	#get the active sip channels
@lines=split(/\n/,$schannels); #add each line of output into @lines array
shift(@lines); #shift first line off array, as it is useless

foreach $line(@lines){
	$line=~/.* ([0-9]+) .*/;  #expecting sip user to be surrounded by (1) spaces
	push(@sipusers,$1);  #push the sip user into @sipusers array
}

# Now let's cycle through all the extensions in sent to this agi
foreach my $k (keys %ext) {
	if (($ext{$k} =~ /#/)!=1) {   #no point in doing if cf is enabled
		
		my $cw = $AGI->database_get('CW',$ext{$k});  #check the database for CW-enable
		if ($cw) {
			debug("Extension $ext{$k} has call waiting enabled", 1); #leave it in the dial string no matter what
		} else {
			debug("Extension $ext{$k} has call waiting disabled", 1);
	
		$inuse=grep(/^$ext{$k}$/,@sipusers); #check to see if this channel is on a call
			
			if ($inuse > 0) {
				my $fwb = $AGI->database_get('CFB',$k);  # check for call-forward on busy.  Does not check to see if fwd-to exten is busy
				if ($fwb) {
						$ext{$k} = $fwb;
						}
				else {
					debug("Max calls of 1 exceeded - deleting from dial", 1);
					delete $ext{$k};  #this exten can't take another call, so delete it from dial string
				}
				if (%ext) {  # check if there any extensions left in the dial string
					debug("Dial still has extensions - continuing",1);
				} else { #there are no extensions left in the dial string
					debug("Dial string is empty - nothing to do",1);
				}
			}
		}
		
	}
}



# Update Caller ID for calltrace application
foreach my $k (keys %ext) {
	if (($ext{$k} =~ /#/)!=1) {   #no point in doing if cf is enabled
	  if ($cidnum) {
		$rc = $AGI->database_put('CALLTRACE', $ext{$k}, $cidnum);
		if ($rc == 1) {
			debug("DbSet CALLTRACE/$ext{$k} to $cidnum", 3);
		} else {
			debug("Failed to DbSet CALLTRACE/$ext{$k} to $cidnum ($rc)", 1);
		}
	  } else {
		# We don't care about retval, this key may not exist
		$AGI->database_del('CALLTRACE', $ext{$k});
		debug("DbDel CALLTRACE/$ext{$k} - Caller ID is not defined", 3);
	  }
  	}
}

my $ds = '';
foreach my $k (keys %ext) {
  if ($ext{$k} =~ s/#//) {                       # "#" used to identify external numbers in forwards and callgourps
		$ds .= 'Local/'.$ext{$k}.'@from-internal&';
  #} elsif (substr($ext{$k},0,1) == '3') {           # if ext starts with 3 it's a Zap interface
  #  $ds .= 'Zap/' . substr($ext{$k},-1) . '&';      # and Zap channel is the last digit of ext
  } else {
		$tech = $AGI->get_variable('E'.$ext{$k}) || 'SIP'; # grab the global var that defines extension technology.  Assume SIP if empty.
		if ($tech eq "ZAP") {
			$zapchannel = $AGI->get_variable('ZAPCHAN_'.$ext{$k});
			$ds .= $tech.'/' . $zapchannel . '&';
		} else {
			$ds .= $tech.'/' . $ext{$k} . '&'; 
		}
  }
}
chop $ds if length($ds);

if (!length($ds)) {
  $AGI->exec('NoOp');
} else {
  $ds .= '|';
  $ds .= $timer if ($timer);
  $ds .= '|' . $dialopts; # pound to transfer, provide ringing

  debug("Dial string is $ds", 1);
  $AGI->set_variable('ds',$ds);
  $AGI->set_priority(10); #dial command is at priority 10
}

exit 0;

sub debug
{
  my $string = shift;
  my $level = shift || 3;

  if ($debug) {
    $AGI->verbose($string, $level);
  }
  return(0);
}

sub mycallback
{
  my $rc = shift;
  debug("User hung up. (rc=" . $rc . ")", 1);
  exit ($rc)
}

sub get_active_sip{  #uses manager api to get output of sip show channels
	#asterisk server manager interface information
	$mgrUSERNAME='AMPMGRUSER';
	$mgrSECRET='AMPMGRPASS';
	$server_ip='127.0.0.1';
	
	$tn = new Net::Telnet (Port => 5038,
				Prompt => '/.*[\$%#>] $/',
				Output_record_separator => '',
				Errmode    => 'return'
				);
	
	#connect to manager and login			
	$tn->open("$server_ip");
	$tn->waitfor('/0\n$/');                  	
	$tn->print("Action: Login\nUsername: $mgrUSERNAME\nSecret: $mgrSECRET\n\n");
	$tn->waitfor('/Authentication accepted\n\n/');

	#issue command
	$tn->print("Action: command\nCommand: sip show channels\n\n\n");
	$tn->waitfor('/Response: Follows\n/');
	($schannels)=$tn->waitfor('/.*active SIP channel/') or die "Unable to get channels", $tn->lastline;    # wait for asterisk to process
	$tn->print("Action: Logoff\n\n");
	return $schannels;
}
