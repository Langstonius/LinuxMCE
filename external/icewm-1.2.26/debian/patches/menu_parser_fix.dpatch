#!/bin/sh -e
## versioned_session.dpatch by Eduard Bloch <blade@debian.org>
##
## DP: menu parser fix to process in shell-like manner

if [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi

[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
patch_opts="${patch_opts:--f --no-backup-if-mismatch}"

case "$1" in
       -patch) patch $patch_opts -p1 < $0;;
       -unpatch) patch $patch_opts -p1 -R < $0;;
        *)
                echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
                exit 1;;
esac

exit 0

@DPATCH@
Index: src/src/wmprog.cc
===================================================================
RCS file: /cvsroot/icewm/icewm-1.2/src/src/wmprog.cc,v
retrieving revision 1.12
diff -u -r1.12 wmprog.cc
--- src/src/wmprog.cc	15 Feb 2004 13:42:35 -0000	1.12
+++ src/src/wmprog.cc	13 Apr 2004 19:50:48 -0000
@@ -140,6 +140,7 @@
 			       const char *exe, YStringArray &args) {
     char *fullname(NULL);
 
+    MSG(("LOOKING FOR: %s\n", exe));
     if (exe && exe[0] &&  // updates command with full path
         NULL == (fullname = findPath(getenv("PATH"), X_OK, exe))) {
         MSG(("Program %s (%s) not found.", name, exe));
@@ -177,12 +178,14 @@
     while (*p) {
         char *argx;
 
+//push to the next word or line end to get the arg
         while (*p && (*p == ' ' || *p == '\t'))
             p++;
-
+//stop on EOL
         if (*p == '\n')
             break;
 
+        // parse the argument into argx and set the new position
         p = getArgument(&argx, p, false);
         if (p == 0) {
             msg(_("Bad argument %d"), args.getCount() + 1);
@@ -190,6 +193,7 @@
         }
 
         args.append(argx);
+        MSG(("ARG: %s\n", argx));
         delete[] argx;
     }
     args.append(0);
@@ -270,6 +274,15 @@
 		YStringArray args;
 
 		p = getCommandArgs(p, &command, args);
+#if 0                
+                {
+                   YStringArray a = args;
+                   while(*a != NULL) {
+                      MSG(("Zeig die Args: %s", *a));
+                      a++;
+                   }
+                }
+#endif
 		if (p == 0) {
 		    msg(_("Error at prog %s"), name); return p;
 		}
Index: src/src/yconfig.cc
===================================================================
RCS file: /cvsroot/icewm/icewm-1.2/src/src/yconfig.cc,v
retrieving revision 1.9
diff -u -r1.9 yconfig.cc
--- src/src/yconfig.cc	29 Feb 2004 08:16:56 -0000	1.9
+++ src/src/yconfig.cc	13 Apr 2004 19:50:49 -0000
@@ -86,70 +87,44 @@
 }
 
 char *getArgument(char **dest, char *p, bool comma) {
-    //    char *d;
     *dest = new char[1];
     if (*dest == 0) return 0;
     **dest = 0;
     int bufLen = 1;
     int len = 0;
-//    int buf = 0;
-    int in_str = 0;
-
-
+    int sq_open = 0;
+    int dq_open = 0;
+    
     while (*p && (*p == ' ' || *p == '\t'))
         p++;
 
-//    d = dest;
     len = 0;
-    while (*p && //len < maxLen - 1 &&
-           (in_str || (*p != ' ' && *p != '\t' && *p != '\n' && (!comma || *p != ','))))
+    while (*p && (sq_open || dq_open || (*p != ' ' && *p != '\t' && *p != '\n' && (!comma || *p != ','))))
     {
-        if (in_str && *p == '\\' && p[1]) {
-            p++; char c = *p++; // *++p++ doesn't work :(
-
-            switch (c) {
-            case 'a': appendStr(dest, bufLen, len, '\a'); break;
-            case 'b': appendStr(dest, bufLen, len, '\b'); break;
-            case 'e': appendStr(dest, bufLen, len, 27); break;
-            case 'f': appendStr(dest, bufLen, len, '\f'); break;
-            case 'n': appendStr(dest, bufLen, len, '\n'); break;
-            case 'r': appendStr(dest, bufLen, len, '\r'); break;
-            case 't': appendStr(dest, bufLen, len, '\t'); break;
-            case 'v': appendStr(dest, bufLen, len, '\v'); break;
-            case 'x':
-                if (p[0] && p[1]) { // only two digits taken
-                    int a = BinAscii::unhex(p[0]);
-                    int b = BinAscii::unhex(p[1]);
-
-                    int n = (a << 4) + b;
-
-                    p += 2;
-                    appendStr(dest, bufLen, len,
-                              (unsigned char)(n & 0xFF));
-//                    *d++ = (unsigned char)(n & 0xFF);
-
-                    a -= '0';
-                    if (a > '9')
-                        a = a + '0' - 'A';
-                    break;
-                }
-            default:
-                appendStr(dest, bufLen, len, c);
-//                *d++ = c;
-                break;
-            }
-            len++;
-        } else if (*p == '"') {
-            in_str = !in_str;
-            p++;
-        } else {
-            appendStr(dest, bufLen, len, *p);
-            p++;
-//            *d++ = *p++;
-//            len++;
-        }
+       char c = *p++; // get current char and push the pointer to the next
+       if(sq_open) // single quotes open, pass everything but '
+          if(c == '\'')
+             sq_open = !sq_open;
+          else
+             appendStr(dest, bufLen, len, c);
+       else if(dq_open) // double quotes open, pass everything but ". Extra care for \", unescape once.
+          if(c == '"')
+             dq_open = !dq_open;
+          else if (c == '\\' && *p == '"') {
+                appendStr(dest, bufLen, len, '"');
+                p++;
+          }
+          else
+             appendStr(dest, bufLen, len, c);
+       else {
+          if(c == '"')
+             dq_open = !dq_open;
+          else if(c == '\'')
+             sq_open = !sq_open;
+          else
+             appendStr(dest, bufLen, len, c);
+       }
     }
-//    *d = 0;
 
     return p;
 }
