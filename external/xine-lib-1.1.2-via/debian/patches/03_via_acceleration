diff -ruN xine-lib-1.1.2-via/configure.ac xine-lib-1.1.2-my-2/configure.ac
--- xine-lib-1.1.2-via/configure.ac	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/configure.ac	2006-10-18 21:43:55.000000000 +0300
@@ -26,6 +26,16 @@
   XINE_SUBPART=".$XINE_SUB"
 #fi
 
+dnl ==================================
+dnl SDK3.6 Horace Lan check mmacrovision support
+dnl ==================================
+AC_CHECK_FILE(/usr/X11R6/lib/libviamv.so, 
+	have_mv_lib=yes 
+	AC_DEFINE(HAVE_MV_LIB,1,[define this if you have macrovision]), 
+	have_mv_lib=no
+)
+AM_CONDITIONAL(HAVE_MV_LIB,[test x"$have_mv_lib" = "xyes"])
+
 dnl The libtool version numbers (XINE_LT_*); Don't even think about faking this!
 dnl 
 dnl immediately before every release do:
@@ -525,6 +535,55 @@
 AC_SUBST(ZLIB_CPPFLAGS)
 AC_SUBST(ZLIB_LIBS)
 
+dnl VeXP3.6, Jack Liu , add VeXP3.5 changes to xine-lib-1.0
+dnl VIA_MPEG
+dnl ---------------------------------------------
+dnl Checks for vmi mpeg2/mpeg4 propritary interface
+dnl ---------------------------------------------
+AC_PREREQ_LIBTOOL(1.4.0, vmi_lib="libddmpeg.so",)
+
+dnl VIA_MPEG
+dnl -----------------------------------------------------
+dnl Checking the vmi mpeg2/mpeg4 proppritary interface
+dnl -----------------------------------------------------
+#AC_ARG_WITH(vmi-path,[  --with-vmi-path=path    Where $vmi_lib is installed],
+#            vmi_path="$withval", vmi_path="/usr/X11R6/lib")
+
+if test x"$xine_cv_cc_64bit_output" = "xyes"; then
+    if test -f "/usr/X11R6/lib64/$vmi_lib"; then
+        vmi_path=/usr/X11R6/lib64
+    else
+        vmi_path=/usr/lib64
+    fi
+else
+    if test -f "/usr/X11R6/lib/$vmi_lib"; then
+        vmi_path=/usr/X11R6/lib
+    else
+        vmi_path=/usr/lib
+    fi
+fi
+
+AC_MSG_CHECKING(for $vmi_lib location)
+if test -f "$vmi_path/$vmi_lib"; then
+  AC_MSG_RESULT(found in $vmi_path)
+  VMI_LIB="-L$vmi_path -lddmpeg"
+  AC_DEFINE(HAVE_VMI,1,[Define this if you have libddmpeg installed])
+  HWVMI_CFLAGS="-DHW_VMI"                  
+  HWVMI_DEBUG_CFLAGS="-DHW_VMI -DVMI_DEBUG"                  
+  CFLAGS="$CFLAGS $HWVMI_CFLAGS"
+  DEBUG_CFLAGS="$DEBUG_CFLAGS $HWVMI_DEBUG_CFLAGS"
+  have_vmi="yes"
+else
+  AC_MSG_RESULT(not found in $vmi_path)
+  echo
+  echo "****************************************************************"
+  echo "* you don't have a libddmpeg.so on your system                 *"
+  echo "****************************************************************"
+  echo
+fi
+AM_CONDITIONAL(HAVE_VMI, test x"$have_vmi" = "xyes")
+AC_SUBST(VMI_LIB)
+
 
 dnl ---------------------------------------------
 dnl check posix timers
diff -ruN xine-lib-1.1.2-via/include/via_def.h xine-lib-1.1.2-my-2/include/via_def.h
--- xine-lib-1.1.2-via/include/via_def.h	1970-01-01 03:00:00.000000000 +0300
+++ xine-lib-1.1.2-my-2/include/via_def.h	2006-10-18 21:43:55.000000000 +0300
@@ -0,0 +1,202 @@
+/*
+ *    Copyright (c) 1998-2006 VIA Technologies, Inc.
+ *    Copyright (c) 2001-2006 S3 Graphics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTIES OR REPRESENTATIONS; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* via_def.h
+ * This is the header file containing common definations in
+ *   both xine and VIA Media SDK which is based on xine-lib.
+ * This file will be installed along with xine.h
+ * KGy
+ */
+
+
+#ifndef VIA_DEF
+#define VIA_DEF
+
+// xine developers: just FYI.
+  /* Concept here for visual:
+   * xine_visual is a structure defined by xine
+   *   used to pass GUI info between ui and lib.
+   * The original mechanism is that ui knows its
+   *   visual type and there is a constant as flag in
+   *   every vo_driver_plugin *.so file. UI will
+   *   fetch the constant and check if it can
+   *   accept ui's visual. When it opens a vo_port,
+   *   it create a xine_visual and pass the pointer
+   *   pointing to the visual to plugin_open as an
+   *   argument. The plugin assume ui will give it
+   *   correct type of xine_visual and get and put
+   *   sth. into it. There are two types of visual
+   *   currently.
+   * For most vo driver plugins that runs on only
+   *   one type of visual this is OK. But ui check
+   *   vo driver plugin's property is not very
+   *   clean  IMHO and this mechanism don't work
+   *   for vo driver that can run on different
+   *   visuals.
+   * The change: now there is only one visual_s
+   *   containing everything needed by every
+   *   visual type. vo driver will never do any
+   *   type conversion which is not very safe.
+   *   Driver will simply check the visual type
+   *   and fail if it's not acceptable. Then
+   *   with an acceptable visual the driver only
+   *   uses needed field. It's upto driver to
+   *   check visual validity, and it's upto 
+   *   driver and ui code to use fields correctly.
+   * Never the less, for the original two visuals'
+   *   definations, fb_visual is simply a
+   *   sub-structure of x22_visual. This makes
+   *   my modification more sensible.
+   */
+
+/*
+ * This is actually the combination of x11_visual_s and fb_visual_s.
+ * This will let CLE266 vo plugin work in both X11 and FB environment.
+ * Hope this will become the one visual_s in xine.
+ */
+
+typedef struct {
+  // KGy CLE266_VO
+  /* Add the visual type flag. Refer to definations above.  */
+  unsigned int      visual_type;
+
+  int			video_screen;//*video will be should primary or second screen uder SAMM*/ 
+  /* some information about the display */
+  void             *display; /* Display* */
+  int               screen;
+  
+  /* drawable to display the video in/on */
+  unsigned long     d; /* Drawable */
+
+  void             *user_data;
+
+  /*
+   * dest size callback
+   *
+   * this will be called by the video driver to find out
+   * how big the video output area size will be for a
+   * given video size. The ui should _not_ adjust it's
+   * video out area, just do some calculations and return
+   * the size. This will be called for every frame, ui
+   * implementation should be fast.
+   * dest_pixel_aspect should be set to the used display pixel aspect.
+   * NOTE: Semantics has changed: video_width and video_height
+   * are no longer pixel aspect corrected. Get the old semantics
+   * in the UI with
+   *   *dest_pixel_aspect = display_pixel_aspect;
+   *   if (video_pixel_aspect >= display_pixel_aspect)
+   *     video_width  = video_width * video_pixel_aspect / display_pixel_aspect + .5;
+   *   else
+   *     video_height = video_height * display_pixel_aspect / video_pixel_aspect + .5;
+   */
+  void (*dest_size_cb) (void *user_data,
+			int video_width, int video_height,
+			double video_pixel_aspect,
+			int *dest_width, int *dest_height,
+			double *dest_pixel_aspect);
+
+  /*
+   * frame output callback
+   *
+   * this will be called by the video driver for every frame
+   * it's about to draw. ui can adapt it's size if necessary
+   * here.
+   * note: the ui doesn't have to adjust itself to this
+   * size, this is just to be taken as a hint.
+   * ui must return the actual size of the video output
+   * area and the video output driver will do it's best
+   * to adjust the video frames to that size (while
+   * preserving aspect ratio and stuff).
+   *    dest_x, dest_y: offset inside window
+   *    dest_width, dest_height: available drawing space
+   *    dest_pixel_aspect: display pixel aspect
+   *    win_x, win_y: window absolute screen position
+   * NOTE: Semantics has changed: video_width and video_height
+   * are no longer pixel aspect corrected. Get the old semantics
+   * in the UI with
+   *   *dest_pixel_aspect = display_pixel_aspect;
+   *   if (video_pixel_aspect >= display_pixel_aspect)
+   *     video_width  = video_width * video_pixel_aspect / display_pixel_aspect + .5;
+   *   else
+   *     video_height = video_height * display_pixel_aspect / video_pixel_aspect + .5;
+   */
+  void (*frame_output_cb) (void *user_data,
+			   int video_width, int video_height,
+			   double video_pixel_aspect,
+			   int *dest_x, int *dest_y,
+			   int *dest_width, int *dest_height,
+			   double *dest_pixel_aspect,
+			   int *win_x, int *win_y,int *screen_num);
+
+} via_visual_t;  // Note the name changed! Original name: x11_visual_t.
+
+void  via_macrovision_process(int pf);
+
+// KGy CLE266_VO
+// Definitions for alpha_blending interface.
+// Please refer to the comment bofore generate_draw_bin_alpha().
+typedef enum {
+  IGNORE_ALHPA,
+  COUNT_IN_ALPHA,
+  RETRIEVE_ALPHA,
+  GEN_FROM_ALPHA
+} alpha_mode;
+
+// Picture format. This is borrowed from V4L2 header.
+//  Four-character-code (FOURCC)
+#define fourcc(a,b,c,d)\
+        (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+#define VIA_PIX_FMT_RGB555  fourcc('R','G','B','O') /* 16  RGB-5-5-5     */
+#define VIA_PIX_FMT_BGR555  fourcc('B','G','R','O') /* 16  BGR-5-5-5     */
+#define VIA_PIX_FMT_RGB565  fourcc('R','G','B','P') /* 16  RGB-5-6-5     */
+#define VIA_PIX_FMT_RGB555X fourcc('R','G','B','Q') /* 16  RGB-5-5-5 BE  */
+#define VIA_PIX_FMT_RGB565X fourcc('R','G','B','R') /* 16  RGB-5-6-5 BE  */
+#define VIA_PIX_FMT_BGR24   fourcc('B','G','R','3') /* 24  BGR-8-8-8     */
+#define VIA_PIX_FMT_RGB24   fourcc('R','G','B','3') /* 24  RGB-8-8-8     */
+#define VIA_PIX_FMT_BGR32   fourcc('B','G','R','4') /* 32  BGR-8-8-8-8   */
+#define VIA_PIX_FMT_RGB32   fourcc('R','G','B','4') /* 32  RGB-8-8-8-8   */
+// RGBAs and BGRTs are defined correspondingly, may be different from official ones.
+#define VIA_PIX_FMT_RGBT555  fourcc('R','G','B','T') /* 16  RGBT-5-5-5-1     */
+#define VIA_PIX_FMT_RGBT555X fourcc('R','G','B','X') /* 16  RGBT-5-5-5-1 BE  */
+#define VIA_PIX_FMT_BGRA32   fourcc('B','G','R','A') /* 32  BGRA-8-8-8-8   */
+#define VIA_PIX_FMT_RGBA32   fourcc('R','G','B','A') /* 32  RGBA-8-8-8-8   */
+
+// AL Zhang
+typedef struct {
+  unsigned char bfType[2];
+  unsigned char bfSize[4];
+  unsigned char bfResv1[4];
+  // short bfResv2;
+  unsigned char bfOffbits[4];
+} bmpfileheader_t,* pbmpfileheader_t;//bmp aligned by 4 bytes
+
+typedef struct {
+  unsigned biSize;
+  unsigned biWidth;
+  unsigned biHeight; 
+  short   biPlanes; 
+  short   biBitCount; 
+  unsigned  biCompression; 
+  unsigned  biSizeImage; 
+  unsigned  biXPelsPerMeter; 
+  unsigned  biYPelsPerMeter; 
+  unsigned  biClrUsed; 
+  unsigned  biClrImportant; 
+} bmpinfoheader_t,* pbmpinfoheader_t;//bmp aligned by 4 bytes
+
+#endif
diff -ruN xine-lib-1.1.2-via/include/xine.h.in xine-lib-1.1.2-my-2/include/xine.h.in
--- xine-lib-1.1.2-via/include/xine.h.in	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/include/xine.h.in	2006-10-18 21:43:55.000000000 +0300
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 1998-2006 VIA Technologies, Inc.
+ * Copyright (c) 2001-2006 S3 Graphics Co., Ltd.
  * Copyright (C) 2000-2004 the xine project
  *
  * This file is part of xine, a free video player.
@@ -62,6 +64,7 @@
 #include <xine/os_types.h>
 #endif
 
+#include "via_def.h"
 
 /* This enables some experimental features. These are not part of the
  * official libxine API, so use them only, if you absolutely need them.
@@ -162,17 +165,21 @@
 void xine_close_audio_driver (xine_t *self, xine_audio_port_t  *driver);
 void xine_close_video_driver (xine_t *self, xine_video_port_t  *driver);
 
+// KGy CLE266_VO
+/* Change this to bit flag to allow multi-visual support.
+ * CLE can run under at least X and FB.
+ */
 /* valid visual types */
-#define XINE_VISUAL_TYPE_NONE              0
-#define XINE_VISUAL_TYPE_X11               1
-#define XINE_VISUAL_TYPE_AA                2
-#define XINE_VISUAL_TYPE_FB                3
-#define XINE_VISUAL_TYPE_GTK               4
-#define XINE_VISUAL_TYPE_DFB               5
-#define XINE_VISUAL_TYPE_PM                6 /* used by the OS/2 port */
-#define XINE_VISUAL_TYPE_DIRECTX           7 /* used by the win32/msvc port */
-#define XINE_VISUAL_TYPE_CACA              8
-#define XINE_VISUAL_TYPE_MACOSX            9
+#define XINE_VISUAL_TYPE_NONE              0x00
+#define XINE_VISUAL_TYPE_X11               0x01
+#define XINE_VISUAL_TYPE_AA                0x02
+#define XINE_VISUAL_TYPE_FB                0x04
+#define XINE_VISUAL_TYPE_GTK               0x08
+#define XINE_VISUAL_TYPE_DFB               0x10
+#define XINE_VISUAL_TYPE_PM                0x20 /* used by the OS/2 port */
+#define XINE_VISUAL_TYPE_DIRECTX           0x40 /* used by the win32/msvc port */
+#define XINE_VISUAL_TYPE_CACA              0x80
+#define XINE_VISUAL_TYPE_MACOSX            0x100 /*should it OK? Jack 2005-1-14 11:55*/
 
 /*
  * free all resources, close all plugins, close engine.
@@ -180,6 +187,19 @@
  */
 void xine_exit (xine_t *self);
 
+// KGy This is created for alpha blending function but this is generic for any interface.
+
+typedef struct vo_special_interface_s {
+	char *id;
+	xine_video_port_t *vo_port;
+} vo_special_interface_t;  // This is the base structure of the special interface.
+
+// Return an array of strings which are interface id. The array is terminated by a NULL pointer.
+const char **xine_query_special_vo_driver_interface(xine_video_port_t *vo_port);
+// Return the pointer to the base of the interface, if success. If failed, return NULL.
+const vo_special_interface_t *xine_get_special_vo_driver_interface(xine_video_port_t *vo_port,
+                                                                   const char *id);
+
 
 /*********************************************************************
  * stream handling                                                   *
@@ -340,6 +360,8 @@
 #define XINE_PARAM_FINE_SPEED             30 /* 1.000.000 => normal speed   */ 
 #define XINE_PARAM_EARLY_FINISHED_EVENT   31 /* send event when demux finish*/
 #define XINE_PARAM_GAPLESS_SWITCH         32 /* next stream only gapless swi*/ 
+#define XINE_PARAM_AUDIO_CHANNEL_PHYSICAL 33 	  
+#define XINE_PARAM_HW_MPEG_CAPABILITY     34 /*zhaolin[2005.9.27]:add property to judge if had the ability of PIP*/
 
 /*
  * speed values for XINE_PARAM_SPEED parameter.
@@ -365,17 +387,30 @@
 #define XINE_PARAM_VO_SATURATION           0x01000003 /* 0..65535           */
 #define XINE_PARAM_VO_CONTRAST             0x01000004 /* 0..65535           */
 #define XINE_PARAM_VO_BRIGHTNESS           0x01000005 /* 0..65535           */
+#define XINE_PARAM_VO_COLORKEY             0x01000006 /* uint_32            */
 #define XINE_PARAM_VO_ZOOM_X               0x01000008 /* percent            */
 #define XINE_PARAM_VO_ZOOM_Y               0x0100000d /* percent            */
 #define XINE_PARAM_VO_PAN_SCAN             0x01000009 /* bool               */
 #define XINE_PARAM_VO_TVMODE               0x0100000a /* ???                */
 #define XINE_PARAM_VO_WINDOW_WIDTH         0x0100000f /* readonly           */
 #define XINE_PARAM_VO_WINDOW_HEIGHT        0x01000010 /* readonly           */
+
+#define XINE_PARAM_VO_MACROVISION_LEVEL    0x01000019 /* KGy uint 0-3 see vo.h */
+#define XINE_PARAM_VO_USECOLORKEY          0x0100001a /* bool               */
+#define XINE_PARAM_VO_OUTPUTENABLED        0x0100001b /* bool               */
+#define XINE_PARAM_VO_MACROVISION_CHECK    0x0100001c /* bool  get only     */
+#define XINE_PARAM_VO_TV_OUT               0x0100001d /* bool  set only     */
+#define XINE_PARAM_VO_TV_OVERLAY           0x01000027 /* bool  set only     */
+
+
 #define XINE_PARAM_VO_CROP_LEFT            0x01000020 /* crop frame pixels  */
 #define XINE_PARAM_VO_CROP_RIGHT           0x01000021 /* crop frame pixels  */
 #define XINE_PARAM_VO_CROP_TOP             0x01000022 /* crop frame pixels  */
 #define XINE_PARAM_VO_CROP_BOTTOM          0x01000023 /* crop frame pixels  */
 
+#define XINE_PARAM_VO_YUVBYPASS               0x01000024 /*  bool  */
+#define XINE_PARAM_VO_HQVFILTER                0x01000025 /*  uint 0-2   */
+
 
 #define XINE_VO_ZOOM_STEP                  100
 #define XINE_VO_ZOOM_MAX                   400
@@ -383,16 +418,25 @@
 
 /* possible ratios for XINE_PARAM_VO_ASPECT_RATIO */
 #define XINE_VO_ASPECT_AUTO                0
-#define XINE_VO_ASPECT_SQUARE              1 /* 1:1    */
-#define XINE_VO_ASPECT_4_3                 2 /* 4:3    */
-#define XINE_VO_ASPECT_ANAMORPHIC          3 /* 16:9   */
-#define XINE_VO_ASPECT_DVB                 4 /* 2.11:1 */
-#define XINE_VO_ASPECT_NUM_RATIOS          5
-#ifndef XINE_DISABLE_DEPRECATED_FEATURES
+#define XINE_VO_ASPECT_SQUARE              1   /* 1:1    */
+#define XINE_VO_ASPECT_4_3                 2   /* 4:3    */
+#define XINE_VO_ASPECT_ANAMORPHIC          3  /* 16:9   */
+#define XINE_VO_ASPECT_DVB                 4   /* 2.11:1 */
+#define XINE_VO_ASPECT_3_2                 5   /* 3:2    */
+#define XINE_VO_ASPECT_FULL_WINDOW  6  /* gui_width : gui_height  */
+#define XINE_VO_ASPECT_NUM_RATIOS          7
+#ifndef  XINE_DISABLE_DEPRECATED_FEATURES
 #define XINE_VO_ASPECT_PAN_SCAN            41
 #define XINE_VO_ASPECT_DONT_TOUCH          42
 #endif
 
+/* Macrovision levels. */
+#define MV_Off                       0
+#define MV_NoColorsrtipping          1
+#define MV_2LineColorstripping       2
+#define MV_4LineColorstripping       3
+
+
 /* stream format detection strategies */
 
 /* recognize stream type first by content then by extension. */
@@ -405,9 +449,15 @@
 #define XINE_DEMUX_EXTENSION_STRATEGY      3
 
 /* verbosity settings */
+/* KGy New verbosity system.
+ * NONE: absolutely silent.
+ * INFO: general status feed back and all error messages.
+ * LOG, DEBUG: as the unchanged one, just for less code change.
+ */ 
 #define XINE_VERBOSITY_NONE                0
-#define XINE_VERBOSITY_LOG                 1
-#define XINE_VERBOSITY_DEBUG               2
+#define XINE_VERBOSITY_INFO                1
+#define XINE_VERBOSITY_LOG                 2
+#define XINE_VERBOSITY_DEBUG   			   3
 
 /*
  * snapshot function
@@ -428,7 +478,9 @@
 #define XINE_IMGFMT_YUY2 (('2'<<24)|('Y'<<16)|('U'<<8)|'Y')
 #define XINE_IMGFMT_XVMC (('C'<<24)|('M'<<16)|('v'<<8)|'X')
 #define XINE_IMGFMT_XXMC (('C'<<24)|('M'<<16)|('x'<<8)|'X')
-
+#define XINE_IMGFMT_VIA  (('N'<<24)|('K'<<16)|('L'<<8)|'W')
+  //0x4E4B4C57 from ddmpeg2.h
+  
 /* get current xine's virtual presentation timestamp (1/90000 sec)
  * note: this is mostly internal data.
  * one can use vpts with xine_osd_show() and xine_osd_hide().
@@ -1139,6 +1191,7 @@
    *    dest_width, dest_height: available drawing space
    *    dest_pixel_aspect: display pixel aspect
    *    win_x, win_y: window absolute screen position
+   *    screen_num: the screen index where video is on.
    * NOTE: Semantics has changed: video_width and video_height
    * are no longer pixel aspect corrected. Get the old semantics
    * in the UI with
@@ -1154,7 +1207,7 @@
 			   int *dest_x, int *dest_y,
 			   int *dest_width, int *dest_height,
 			   double *dest_pixel_aspect,
-			   int *win_x, int *win_y);
+			   int *win_x, int *win_y, int *screen_num);
 
 } x11_visual_t;
 
@@ -1408,6 +1461,16 @@
 void xine_config_update_entry (xine_t *self,
 			       const xine_cfg_entry_t *entry);
 
+/* 
+ * author: xiangchen
+ * date:   01/13/2006
+ * add one configed entry,if no item exists, add new item, 
+ * otherwise update item, the key is name of configed item
+ * value can be any type (integer,string,enum,bool...)
+ * if successful,return 1 otherwise 0
+ */
+int xine_config_add_entry(xine_t *self, const char *key,void *value);
+
 /*
  * load/save config data from/to afile (e.g. $HOME/.xine/config)
  */
@@ -1485,6 +1548,11 @@
 #define XINE_EVENT_INPUT_NUMBER_9       129
 #define XINE_EVENT_INPUT_NUMBER_10_ADD  130
 
+
+/* VCD MENUS EVENTS */
+#define XINE_EVENT_VCD_CURSORCHANGED   777
+
+
 /* specific event types */
 #define XINE_EVENT_SET_V4L2             200
 #define XINE_EVENT_PVR_SAVE             201
@@ -1493,6 +1561,32 @@
 #define XINE_EVENT_PVR_PAUSE            204
 #define XINE_EVENT_SET_MPEG_DATA        205
 
+// KGy BKGND_REC
+#define XINE_EVENT_PVR_STOPTHREAD	206  // No data for this.
+
+// Jack Liu 
+#define XINE_EVENT_SET_MPEG_FORMAT	207
+#define XINE_EVENT_SET_MPEG_CTRL	208
+#define XINE_EVENT_SET_TV_FREQURNCY	209
+
+//Qiaowei Ren
+#define XINE_EVENT_PVR_DISKFULL         210
+
+// TomSang
+/*******begin to add for via media sdk lib**************/
+#define XINE_EVENT_INPUT_GOUP                 XINE_EVENT_SET_MPEG_DATA+10000
+#define XINE_EVENT_INPUT_TOPPG_SEARCH         XINE_EVENT_INPUT_GOUP+1
+#define XINE_EVENT_INPUT_PREVIOUSPG_SEARCH    XINE_EVENT_INPUT_GOUP+2
+#define XINE_EVENT_INPUT_NEXTPG_SEARCH        XINE_EVENT_INPUT_GOUP+3
+#define XINE_EVENT_INPUT_PTT_PLAY             XINE_EVENT_INPUT_GOUP+4
+#define XINE_EVENT_INPUT_PTT_SEARCH           XINE_EVENT_INPUT_GOUP+5
+#define XINE_EVENT_INPUT_BUTTON_SELECT        XINE_EVENT_INPUT_GOUP+6
+#define XINE_EVENT_INPUT_MACROVISION_CALLBACK XINE_EVENT_INPUT_GOUP+7
+#define XINE_EVENT_INPUT_BACKWARDSCAN         XINE_EVENT_INPUT_GOUP+8
+/******end adding ***********************************/
+
+
+
 /* VDR specific event types */
 #define XINE_EVENT_VDR_RED              300
 #define XINE_EVENT_VDR_GREEN            301
@@ -1764,6 +1858,15 @@
   int mode;
 } xine_pvr_pause_t;
 
+/*
+ * notify frame format change
+ */
+typedef struct {
+  int                 ctrl_id;
+  int                 ctrl_value;
+} xine_control_data_t;
+
+
 #endif
 
 /* event XINE_EVENT_DROPPED_FRAMES is generated if libxine detects a
@@ -1858,6 +1961,8 @@
 
 #define XINE_TEXT_PALETTE_SIZE 11
 
+
+
 #define XINE_OSD_TEXT1  (0 * XINE_TEXT_PALETTE_SIZE)
 #define XINE_OSD_TEXT2  (1 * XINE_TEXT_PALETTE_SIZE)
 #define XINE_OSD_TEXT3  (2 * XINE_TEXT_PALETTE_SIZE)
@@ -1866,8 +1971,8 @@
 #define XINE_OSD_TEXT6  (5 * XINE_TEXT_PALETTE_SIZE)
 #define XINE_OSD_TEXT7  (6 * XINE_TEXT_PALETTE_SIZE)
 #define XINE_OSD_TEXT8  (7 * XINE_TEXT_PALETTE_SIZE)
-#define XINE_OSD_TEXT9  (8 * XINE_TEXT_PALETTE_SIZE)
-#define XINE_OSD_TEXT10 (9 * XINE_TEXT_PALETTE_SIZE)
+//#define XINE_OSD_TEXT9  (8 * XINE_TEXT_PALETTE_SIZE)
+//#define XINE_OSD_TEXT10 (9 * XINE_TEXT_PALETTE_SIZE)
 
 /* white text, black border, transparent background  */
 #define XINE_TEXTPALETTE_WHITE_BLACK_TRANSPARENT    0
@@ -1951,6 +2056,246 @@
  */
 void        xine_osd_free          (xine_osd_t *self);
 
+// KGy CLE266_VO
+// Interface for alpha blending functions.
+typedef struct via_alphableding_interface_s via_alphablending_interface_t;
+
+/******************
+ * Note: definition of size and positions:
+ * height: number of lines in the picture.
+ * width:  number of pixels per line in the picture.
+ * position: top, left, bottom, right are all positions,
+ *   position starts from 0 with in each coordinate, and
+ *   when in range of x:[0,width-1], y:[0,height-1],
+ *   this position is in the picture.
+ ******************/
+
+struct via_alphableding_interface_s {
+  vo_special_interface_t base_interface;
+
+  /* This function will provide screen info and the fd of
+   *   the /dev/fb or /dev/fb1 etc. opened by vo_driver.
+   * ToDo: any other info?
+   * width and height: if this function failed, they will
+   *   be 0, if succeeded, they will show the screen size,
+   *   in both FB and XWin environment.
+   *   However this value is NOT guaranteed to be the correct
+   *   size of current DISPLAY MODE, since XServer may do some
+   *   panning.
+   * Return: valid FD if success and is in FB environment,
+   *    negative value if not in FB environment or failed.
+   */
+  int (*get_screen_info)(via_alphablending_interface_t *this,
+                         unsigned int *width,unsigned int *height);
+  /*
+   *Get alpha value of a subsurface from alpha surface;
+   *width, height, top, left define the size and position of that subsurface
+   *alpha_buf cantain alpha values
+   *Return: 0 if success, -1 if failed
+   */
+  int (*get_alpha)(via_alphablending_interface_t *this,
+                         unsigned int width,unsigned int height,unsigned int top,  unsigned int left,char *alpha_buf);
+  /* Do constant alpha blending. Video will be blended at alpha ratio
+   *   at anywhere except in alpha surface controlled  rectangle.
+   * alpha: 8 bit value, 256 level alpha.
+   *   output = (alpha/255)*video + ((255-alpha)/255)*graphics
+   *   For CLE266, which supports 16 level alpha, only upper 4 bit
+   *   is used.
+   * enable: turn on or turn off constant alpha blending.
+   * Return: 0 if success, -1 if failed.
+   */
+  int (*set_const_alpha)(via_alphablending_interface_t *this,
+			 unsigned char alpha, int enable);
+
+  /* Surface controlled alpha blending:
+   * This function allows you to control alpha value for every pixel
+   *   separatedly.
+   * The surface has a size of width*height pixels, where width and height
+   *   is the value returned by get_fb_info().
+   * The calling sequence shall be like:
+   *
+   * 1, Initialize status is alpha surface has 0 width and height,
+   *    surface controlled alpha is disabled.
+   * 2, To turn on a alpha window:
+   *    set_alpha_surf_size()
+   *    draw_alpha() or generate_draw_bin_alpha()
+   *    set_surf_controlled_alpha(enable)
+   *    // After this, you can draw anything into the alpha surface
+   *         as long as the alpha surface size is not changed, and it's
+   *         your responsibility to maintain surface content.
+   *    // You can also call set_surf_controlled_alpha() to move alpha
+   *         window to any position without needing to redraw any alpha
+   *         image as long as the alpha surface size is not changed.
+   * 3, To resize a alpha window:
+   *    It's recommended to turn off the alpha window
+   *    (call  set_surf_controlled_alpha(disable)) first
+   *    and turn on a new alpha window, so that garbage will not appear on
+   *    screen.
+   * 4, If you are disabling alpha window, no set_alpha_surf_size() needed,
+   *    and the alpha surface size will not change if set_alpha_surf_size()
+   *    is not called.
+   */
+
+  /* Set alpha window size.
+   * This will affect how the alpha image is drawn into alpha buffer
+   *   as well as the device setting. However when the size is changed,
+   *   a set_surf_controlled_alpha() must be called to update the
+   *   device setting.
+   * Return: 0 if success, -1 if failed.
+   */
+  int (*set_alpha_surf_size)(via_alphablending_interface_t *this,
+			      unsigned int width, unsigned int height);
+
+  /* Set control info for surface-controlled alpha blending.
+   * enable: turn on or turn off thr alpha blending.
+   * top,left: starting point of the alpha window. Any part of the
+   *   video overlay covering the alpha window will be blended.
+   * Return: 0 if success, -1 if failed.
+   */
+  int (*set_surf_controlled_alpha)(via_alphablending_interface_t *this,
+				   int enable,
+				   unsigned int top, unsigned int left);
+
+  /* Draw alpha picture into alpha surface in frame buffer.
+   * Input: One byte per pixel, for CLE266, only the upper 4 bits is used.
+   * A sub rectangle starting from (src_top,src_left) with the
+   *   size of width and height will be put into a sub rectangle
+   *   starting from(dst_top,dst_left) of the alpha surface,
+   *   i.e. alpha window, without any scalling.
+   * Subrectangles will be clipped so that they will not go out of bond.
+   * src_width,src_height: src buffer size. src buffer shall have
+   *  a pitch that is the same as width.
+   * Return: 0 if success, -1 if failed.
+   */
+  int (*draw_alpha)(via_alphablending_interface_t *this,
+		    char *src_buf,
+		    unsigned int src_width,  unsigned int src_height,
+		    unsigned int draw_width, unsigned int draw_height,
+		    unsigned int src_top,    unsigned int src_left,
+		    unsigned int dst_top,    unsigned int dst_left);
+
+  /* Draw constant-valued alpha picture into alpha surface in frame buffer.
+   * Input: 8 bit alpha value, for CLE266, only the upper 4 bits is used.
+   * A sub rectangle of the alpha surface, with the size of draw_width and draw_height,
+   *   starting from (dst_top,dst_left), i.e. alpha window, will be filled with the alpha value.
+   * Subrectangle will be clipped so that they will not go out of bond.
+   * Return: 0 if success, -1 if failed.
+   */
+  int (*draw_constant_alpha)(via_alphablending_interface_t *this,
+			     unsigned char alpha,
+			     unsigned int draw_width, unsigned int draw_height,
+			     unsigned int dst_top,    unsigned int dst_left);
+
+  /* Generate alpha picture for hollow picture or hollow text.
+   * Input picture's format is described by format, which is the FourCC code.
+   * Input picture buffer is described by starting address, pitch and width.
+   * One alpha value is generated for each pixel in input sub rectangle.
+   * Generated alpha picture is put into dst, which is a sub-rectangle of alpha window,
+   *   with out any scaling.
+   * Sub-rectangle validities, or index overflow, for both src and dst are checked.
+   * There are two alpha value to choose, so the generated alpha picture is called
+   *   "binary alpha". Pixel with color value that falls in hollow_high_color and
+   *   hollow_low_color will be given the hollow_alpha alpha value, others will
+   *   be given normal_alpha. Color values are compared by components. When
+   *   hollow_high_color == hollow_low_color, color values are compared by
+   *   simply testing if the color value equals to hollow_high_color or hollow_low_color,
+   *   which can be faster, and is recommended to use on text picture, which is drawn by
+   *   font processing library.
+   * Arguments:
+   *   format: FourCC code, can be RGB555, RGB565, RGB555X, RGB565X, RGB24, BGR24,
+   *     RGB32 and BGR32, which are all defined by V4L2 video image formats spec.
+   *     but formats with alpha are also supported, including BGRA32 and RGBA32,
+   *     whose unused byte of each pixel in the V4L2 definition are used for alpha,
+   *     and for RGBT555 and RGBT555X, whose unused bit in V4L2 definition are used
+   *     for transparency bit.
+   *   hollow_high_color, hollow_low_color:
+   *     Color are described with a 4 byte unsigned int value:
+   *     {
+   *       unsigned char A, R, G, B;
+   *       color = (A << 24) | (B << 16) | (G << 8) | R;
+   *     }
+   *     And color are compared component by component.
+   *     Every component of hollow_high_color must be larger than corresponding
+   *       component of hollow_low_color. The two arguments allow some tolerance
+   *       of the color which is used as color key for hollow alpha value.
+   *   normal_alpha, hollow_alpha: The two alphas can be set by function caller
+   *     so that the alpha value are not necessarily 0 or 255 but can be any desired
+   *     value. Alpha value meaning is:
+   *     displayed_color_component = (alpha/255)*video + ((255-alpha)/255)*graphics;
+   *     And here hollow means that THE RGB PICTURE WILL BE DISPLAYED HOLLOW,
+   *     so normally hollow_alpha will be greater than normal_alpha.
+   *     normal_alpha = 0 and hollow_alpha = 255 is the real hollow and real normal.
+   *   src_buf: Pointer to the buffer with src_pitch and height. All RGB formats
+   *     here are pixel wise packed, so only one pointer is enough.
+   *   mode: This is an enum argument.
+   *     This argument is specially provided for input formats with alpha or
+   *       transprency component. For plain RGB format this argument has no
+   *       effect.
+   *     Here is the meaning of different modes:
+   *     IGNORE_ALPHA:
+   *       Treate the input image as if it has no alpha or transparency component.
+   *     COUNT_IN_ALPHA:
+   *       In this mode, the A component of hollow_high_color and hollow_low_color
+   *         takes effect. The A component is also compared to generate binary alpha
+   *         value. This mode makes the compare complexed and I don't think this mode
+   *         is very useful.
+   *     RETRIEVE_ALPHA:
+   *       In this mode, the alpha value is retrieved to compose the alpha image, and
+   *         all RGB components are ignored. According to FourCC definition, alpha
+   *         components from the input image means, when the image is displayed on
+   *         an other image, the blended result is:
+   *         output = (alpha/255)*image + ((255-alpha)/255)*background;
+   *       For RGBA32 and BGRA32 input image, the normal_alpha and the hollow_alpha
+   *         argument are ignored. And the output alpha image is generated with this
+   *         equation:
+   *         output = 255 - src_alpha;
+   *       For RGBT555 and RGBT555X, the argument normal_alpha and hollow_alpha are used.
+   *         A pixel with transparent component == 1 will generate a pixel with hollow_alpha
+   *         in the alpha image, and transparent == 0 will result in a pixel with normal_alpha.
+   *     GEN_FROM_ALPHA:
+   *       In this mode, the A component of RGBA32 or BGRA32 input image will be compared against
+   *         hollow_high_color.A and hollow_low_color.A to generate alpha image,but R, G and B
+   *         component of the input image are ignored.
+   *       For RGBT555 and RGBT555X input image, hollow_low_color and hollow_hight_color are also
+   *         used. To the input image, transparent == 1 is equivalent to its alpha == 0
+   *         and transparent == 0 is equivalent to its alpha == 255. The two values are used
+   *         to compare with hollow_high_color.A and hollow_low_color.A.
+   *       Two special and useful case are:
+   *         hollow_high_color.A == hollow_low_color.A = 0;
+   *           Then the generated alpha image is the same as mode "RETRIEVE_ALPHA".
+   *         hollow_heigh_color.A == hollow_low_color.A = 255;
+   *           The generated alpha image is the reverse of the former case.
+   * Return: 0 if success, -1 if failed.
+   */
+  int (*generate_draw_bin_alpha)(via_alphablending_interface_t *this,
+				 unsigned int format,     char *src_buf,
+				 unsigned int src_pitch,  unsigned int src_height,
+				 unsigned int draw_width, unsigned int draw_height,
+				 unsigned int src_top,    unsigned int src_left,
+				 unsigned int dst_top,    unsigned int dst_left,
+				 unsigned int hollow_high_color,
+				 unsigned int hollow_low_color,
+				 unsigned char normal_alpha,
+				 unsigned char hollow_alpha,
+				 alpha_mode mode);
+
+  /* Generate alpha picture from a bitmap file.
+   * This function reads the file and generate and draw the alpha picture into alpha surface.
+   * Arguments have the same meaning with the function generate_draw_bin_alpha() above.
+   * You must know the size and wanted area of the bmp file, funny.
+   */
+  int (*generate_draw_bin_alpha_from_bmp)(via_alphablending_interface_t *this,
+					  const char *file,
+					  unsigned int draw_width,unsigned int draw_height,
+					  unsigned int src_top,unsigned int src_left,
+					  unsigned int dst_top,unsigned int dst_left,
+					  unsigned int hollow_high_color,
+					  unsigned int hollow_low_color,
+					  unsigned char normal_alpha,
+					  unsigned char hollow_alpha,
+					  alpha_mode mode);
+};
+
 
 #ifndef XINE_DISABLE_DEPRECATED_FEATURES
 
diff -ruN xine-lib-1.1.2-via/src/libmpeg2/decode.c xine-lib-1.1.2-my-2/src/libmpeg2/decode.c
--- xine-lib-1.1.2-via/src/libmpeg2/decode.c	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/libmpeg2/decode.c	2006-11-02 08:09:35.000000000 +0200
@@ -43,6 +43,7 @@
 #include "mpeg2_internal.h"
 #include "xineutils.h"
 #include "libmpeg2_accel.h"
+#include "slice_vmi.h"
 
 /*
 #define LOG_PAN_SCAN
@@ -51,14 +52,130 @@
 /* #define BUFFER_SIZE (224 * 1024) */
 #define BUFFER_SIZE (1194 * 1024) /* new buffer size for mpeg2dec 0.2.1 */
 
+//#define LOG_MPEG2_SOFT_DECODE  /*zhaolinwang[2006.02.20]: add this for debug info of mpeg2 soft decode*/
+//#define HW_MPEG2_MC_Debug
+
+#ifdef LOG_MPEG2_SOFT_DECODE   /*zhaolinwang:added for mpeg2 soft debug */
+#define  DEBUG_LEVEL                            2    /*you can set debug level at here, rang 0,1,2*/
+#define  DEBUG_ALL	                            0    /*level 0*/
+#define  DEBUG_ONE_PIC				1    /*level 1*/
+#define  DEBUG_ONE_SLICE                    2   /*level  2*/
+
+#define  DEBUG_PIC_NUM                       137                /*you can set DEBUG_PIC_NUM with the pic you want to debug*/
+#define  DEBUG_SLICE_CODE                  24                 /*you can set DEBUG_SLICE_CODE with the slice code you want to debug*/
+
+static int pic_num=-1;
+static int slice_code=0;
+
+static void print_debug_setting() /*print the setting of the debug*/
+{
+	int debug_level=DEBUG_LEVEL;
+	int pic=DEBUG_PIC_NUM;
+	int slice=DEBUG_SLICE_CODE;
+	switch(debug_level)
+	{
+	  case 0:
+	    fprintf(stderr, "\ndebug level:%d, debug all pic of the sequence.\n", debug_level);
+	    break;
+	  case 1:
+	    fprintf(stderr, "\ndebug level:%d, we only debug one pic.\n the pic number is:%d\n", debug_level, pic);
+	    break;
+	  case 2:
+	    fprintf(stderr, "\ndebug level:%d,we only debug one slice of the pic.\n the pic number:%d, slice_code:%d\n", debug_level, pic, slice);
+	    break;
+	  default:
+           fprintf(stderr, "\nthe setting of debug in wrong, debug_level should in the rang 0 to 2\n");
+	}
+		
+}
+
+static void print_pic_status(code, buffer)
+{
+	int debug_level=DEBUG_LEVEL;
+	slice_code=code;
+	if(code==0)
+		pic_num++;
+	if((debug_level==0)||(pic_num==DEBUG_PIC_NUM))
+      		mpeg2_stats (code, buffer);
+}
+
+int IsDebugOutput() /*judge if the current slice is the slice that we want to debug*/
+{
+	int debug_level=DEBUG_LEVEL;
+	if((debug_level==0)||((debug_level==1)&&(pic_num==DEBUG_PIC_NUM))||
+		((debug_level==2)&&(pic_num==DEBUG_PIC_NUM)&&(slice_code==DEBUG_SLICE_CODE)))
+	    return 1;
+	else 
+	    return 0;
+}
+
+#endif 
+
 static void process_userdata(mpeg2dec_t *mpeg2dec, uint8_t *buffer);
 
+/*zhaolin:[20060612]:add the following code for mpeg2 hw mc*/
+static inline void mpeg2_vmi_mc_begin_frame (mpeg2dec_accel_t * accel, picture_t * picture) 
+{
+    vmi_accel_t * p_vmi_accel=(vmi_accel_t *)picture->current_frame->accel_data;
+
+    picture->lpIDCTBuff_cur=picture->lpIDCTBuff;  /*reset lpIDCTBuff_cur*/
+
+    /* General info*/
+    p_vmi_accel->mpg_accel_param.dwDecoderMode  = USE_MC;
+    p_vmi_accel->mpg_accel_param.dwMpeg2        = !(picture->mpeg1);  // Actually we are not using HW to decode MPEG1.
+    p_vmi_accel->mpg_accel_param.dwMPEG4Decode  = 0;
+
+    p_vmi_accel->mpg_accel_param.dwPictureType      = picture->picture_coding_type;  // Same defination.
+    p_vmi_accel->mpg_accel_param.dwDecodePictStruct = picture->picture_structure;    // Same defination.
+
+    p_vmi_accel->mpg_accel_param.dwMBwidth      = picture->mb_frame_width;
+    p_vmi_accel->mpg_accel_param.dwTopFirst	 = picture->top_field_first;
+    p_vmi_accel->mpg_accel_param.dwMBAmax		 = picture->mb_frame_width * accel->mb_frame_height;
+    p_vmi_accel->mpg_accel_param.dwConcealMV	 = picture->concealment_motion_vectors;
+    p_vmi_accel->mpg_accel_param.dwSecondField	= picture->second_field;
+
+     /*calculate hardware surface id.*/
+  {
+	vmi_accel_t * p_vmi_accel_fr, *p_vmi_accel_br;
+	
+  	p_vmi_accel->mpg_accel_param.dwDecodeBuffIndex=p_vmi_accel->surf_id;
+	p_vmi_accel->mpg_accel_param.dwOldRefFrame=p_vmi_accel->mpg_accel_param.dwRefFrame=-1;
+
+	if((picture->forward_reference_frame)&&(picture->forward_reference_frame->accel_data)){
+		p_vmi_accel_fr=(vmi_accel_t *)picture->forward_reference_frame->accel_data;
+		p_vmi_accel->mpg_accel_param.dwOldRefFrame=p_vmi_accel_fr->surf_id;
+	}		
+
+       if((picture->backward_reference_frame)&&(picture->backward_reference_frame->accel_data)){
+		p_vmi_accel_br=(vmi_accel_t *)picture->backward_reference_frame->accel_data;
+		p_vmi_accel->mpg_accel_param.dwRefFrame=p_vmi_accel_br->surf_id;
+	}	
+		
+  }
+
+
+  p_vmi_accel->decoded_ok=1;
+  
+  /* ToDo: check sth.*/
+  p_vmi_accel->proc_begin_frame(picture->current_frame);
+}
+
+static inline void mpeg2_vmi_mc_reset (mpeg2dec_t * mpeg2dec)
+{
+	mpeg2dec->picture->lpIDCTBuff_cur=mpeg2dec->picture->lpIDCTBuff;
+}
+
+
 void mpeg2_init (mpeg2dec_t * mpeg2dec, 
 		 xine_video_port_t * output)
 {
   static int do_init = 1;
   uint32_t mm_accel;
 
+  #ifdef LOG_MPEG2_SOFT_DECODE
+      print_debug_setting();
+  #endif
+
     if (do_init) {
 	do_init = 0;
 	mm_accel = xine_mm_accel();
@@ -86,6 +203,10 @@
     mpeg2dec->chunk_ptr = mpeg2dec->chunk_buffer;
     mpeg2dec->code = 0xb4;
     mpeg2dec->seek_mode = 0;
+    mpeg2dec->accel.can_hw_decode = 0;
+    mpeg2dec->accel.can_hw_hdtv = 0;
+    mpeg2dec->accel.hw_capability=0;
+
 
     memset (mpeg2dec->picture, 0, sizeof (picture_t));
 
@@ -98,9 +219,34 @@
     } else if( output->get_capabilities(output) & VO_CAP_XVMC_MOCOMP) {
       printf("libmpeg2: output port has XvMC capability\n");
       mpeg2dec->frame_format = XINE_IMGFMT_XVMC;
-    } else {
+    } else if( output->get_capabilities(output) & VO_CAP_MPEG2_SLICE) {
+      printf("libmpeg2: output port has MPEG2 SLICE Accel  capability\n");
+      mpeg2dec->frame_format = XINE_IMGFMT_VIA;
+      mpeg2dec->accel.hw_capability=VD_HW_MPEG2_SLICE;
+      mpeg2_vmi_init(mpeg2dec);
+    }else if( output->get_capabilities(output) & VO_CAP_MPEG2_MC) {
+      fprintf(stderr, "libmpeg2: output port has MPEG2 MC Accel  capability\n");
+      int i=0;
+      mpeg2dec->frame_format = XINE_IMGFMT_VIA;
+      mpeg2dec->accel.hw_capability=VD_HW_MPEG2_MC;
+      mpeg2dec->picture->MB_accel_parm=xine_xmalloc_aligned (16, MAX_MB_NUM*sizeof (VIAMACROBLOCK),
+      	(void**)&mpeg2dec->picture->MB_accel_parm_base);
+
+			memset (mpeg2dec->picture->MB_accel_parm, 0, MAX_MB_NUM*sizeof (VIAMACROBLOCK));
+			mpeg2dec->picture->lpIDCTBuff=xine_xmalloc_aligned (16, MAX_MB_NUM*IDCT_BUF_SIZE,
+					(void**)&mpeg2dec->picture->lpIDCTBuff_base);
+			for(i=0; i<MAX_MB_NUM; i++)
+				(mpeg2dec->picture->MB_accel_parm+i)->lpIDCTBuff=mpeg2dec->picture->lpIDCTBuff+i*IDCT_BUF_SIZE;
+			memset (mpeg2dec->picture->lpIDCTBuff, 0, MAX_MB_NUM*IDCT_BUF_SIZE);
+			mpeg2dec->picture->lpIDCTBuff_cur=mpeg2dec->picture->lpIDCTBuff;
+    }
+      else{
       mpeg2dec->frame_format = XINE_IMGFMT_YV12;
     }
+
+   if( output->get_capabilities(output) & VO_CAP_HW_HDTV){
+   	mpeg2dec->accel.can_hw_hdtv = 1;
+   }
 }
 
 static inline void get_frame_duration (mpeg2dec_t * mpeg2dec, vo_frame_t *frame)
@@ -242,6 +388,9 @@
     int is_frame_done;
     double ratio;
     
+    static int pic_byte=0,last_slice_code=0;//zhaolin:add to calucate bitrate
+    static int pic_cnt=0,bitrate=0;
+
     /* wait for sequence_header_code */
     if (mpeg2dec->is_sequence_needed) {
       if (code != 0xb3) {
@@ -260,11 +409,15 @@
     mpeg2_stats (code, buffer);
 
     picture = mpeg2dec->picture;
+    
+//========================================================================
     is_frame_done = mpeg2dec->in_slice && ((!code) || (code >= 0xb0));
+//    fprintf(stderr,"cur mpeg2dec_code: %x\n", code);
 
-    if (is_frame_done)
+    if (is_frame_done)  {
 	mpeg2dec->in_slice = 0;
-    
+//	fprintf(stderr,"frame_done mpeg2dec_code: %x\n", code);
+    }
     if (is_frame_done && picture->current_frame != NULL) {
 
 	libmpeg2_accel_frame_completion(&mpeg2dec->accel, mpeg2dec->frame_format, 
@@ -295,15 +448,37 @@
 	  }
 	}
     }
+    //========================================================================
 
     switch (code) {
     case 0x00:	/* picture_start_code */
+	if(picture->mpeg1){
+	   mpeg2dec->frame_format = XINE_IMGFMT_YV12;	
+	   /*DaveLiu,7/28/2006,to some special DVD disc(such as DD012802.12), 
+	   preview tittle is MPEG2 but content is mpeg1. The wrose is there is 
+	   no sequence header or mpeg extention header between two tittle 
+	   to tell decoder such change in format. so we get format info from pack layer
+	   and judge every picture*/  
+           mpeg2dec->picture->can_hw_decode=0;
+        }
+        
+    	remember_metainfo (mpeg2dec);//zhaolin
 	if (mpeg2_header_picture (picture, buffer)) {
 	    fprintf (stderr, "bad picture header\n");
 	    abort();
 	}
 
-	mpeg2dec->is_frame_needed=0;
+      if(mpeg2dec->accel.can_hw_decode==VD_HW_MPEG2_MC) /*reset */
+	    mpeg2_vmi_mc_reset(mpeg2dec);
+
+      
+      mpeg2dec->is_frame_needed=0;
+
+	//Jack Liu, VeXP3.6, 2005-02-16
+	//Initialize slice data for every picture.
+       if(mpeg2dec->accel.can_hw_decode==VD_HW_MPEG2_SLICE)
+		slice_vmi_reset(&mpeg2dec->accel);
+	//Jack Liu add end.   
 
 	if (!picture->second_field) {
 	  /* find out if we want to skip this frame */
@@ -393,6 +568,17 @@
 	    /* abort(); */
 	    break;
 	}
+
+     /*zhaolin: the following info use for HW MC*/
+     picture->mb_frame_width= picture->coded_picture_width/16; 
+     picture->mb_frame_height = (!(picture->mpeg1) && (picture->progressive_sequence)) ?
+					2*((picture->display_height+31)/32) : (picture->display_height+15)/16; 
+     picture->mb_pic_height = (picture->picture_structure == FRAME_PICTURE ) ?
+					picture->mb_frame_height :   picture->mb_frame_height / 2;
+     picture->mb_pic_num=picture->mb_frame_width*picture->mb_pic_height;
+			
+	mpeg2dec->accel.can_hw_decode = 0; //set as 1 after mpeg2_header_extension if condition meeted. joyce added,
+
 	if (mpeg2dec->force_aspect) picture->aspect_ratio_information = mpeg2dec->force_aspect;
 
 	if (mpeg2dec->is_sequence_needed ) {
@@ -446,6 +632,18 @@
 	    fprintf (stderr, "bad extension\n");
 	    abort();
 	}
+
+	if((!picture->mpeg1)
+	&&(mpeg2dec->frame_format==XINE_IMGFMT_VIA)
+	&&(picture->display_height < 720 ||mpeg2dec->accel.can_hw_hdtv))
+	{
+		mpeg2dec->picture->can_hw_decode=
+		mpeg2dec->accel.can_hw_decode = mpeg2dec->accel.hw_capability; /*can use hw accel for decode*/
+		#ifdef HW_MPEG2_MC_Debug
+		fprintf(stderr, "decode.c: line 544  can hw decode:%d\n", mpeg2dec->picture->can_hw_decode);
+		#endif
+	}
+
 	break;
 
     case 0xb7:	/* sequence end code */
@@ -459,10 +657,19 @@
 	}
     default:
         if ((code >= 0xb9) && (code != 0xe4)) {
-	  printf("Not multiplexed? 0x%x\n",code);
+	  //fprintf (stderr,"libmpeg2: stream not demultiplexed? discard current frame \n");
+	  mpeg2dec->is_frame_needed = 1;
+	  return 0;
+	}
+	
+	if (mpeg2dec->is_frame_needed && code <= 0xAF && code >= 1 ) {
+		//fprintf(stderr,"return:mpeg2dec_code:%x \n ", code);
+		//return 0;
+	}
+	
+	if (code >= 0xb0) {
+	   break;
 	}
-	if (code >= 0xb0)
-	    break;
 
 	if (!(mpeg2dec->in_slice)) {
 	    mpeg2dec->in_slice = 1;
@@ -476,6 +683,12 @@
 	    } else {
 		int flags = picture->picture_structure;
 
+		//Jack Liu, VeXP3.6, 20050218
+		uint32_t get_frame_format=mpeg2dec->frame_format;
+		if((!mpeg2dec->accel.can_hw_decode)&&(get_frame_format==XINE_IMGFMT_VIA))
+			get_frame_format=XINE_IMGFMT_YV12;
+		//Jack Liu, VeXP3.6, 20050218
+
 		if (!picture->mpeg1) flags |= VO_INTERLACED_FLAG;
 		if (mpeg2dec->force_pan_scan) flags |= VO_PAN_SCAN_FLAG;
 		if (mpeg2dec->new_sequence) flags |= VO_NEW_SEQUENCE_FLAG;
@@ -492,7 +705,7 @@
 						     picture->coded_picture_width,
 						     picture->coded_picture_height,
 						     ratio,
-						     mpeg2dec->frame_format,
+						     get_frame_format,
 						     flags);
 		    libmpeg2_accel_new_frame( &mpeg2dec->accel, mpeg2dec->frame_format,
 					      picture, ratio, flags);
@@ -503,7 +716,7 @@
 						     picture->coded_picture_width,
 						     picture->coded_picture_height,
 						     ratio,
-						     mpeg2dec->frame_format,
+						     get_frame_format,
 						     flags);
 
 		    libmpeg2_accel_new_frame( &mpeg2dec->accel, mpeg2dec->frame_format,
@@ -517,6 +730,7 @@
 			picture->backward_reference_frame;
 		    picture->backward_reference_frame = picture->current_frame;
 		}
+	    }
 
 		if(mpeg2dec->new_sequence) 
 		    mpeg2dec->new_sequence = 
@@ -553,7 +767,32 @@
 		mpeg2dec->pts = 0;
 		/*printf("Starting to decode frame %d\n",picture->current_frame->id);*/
 	    }
-	}
+	    
+	    //zhaolin:to compute the bitrate
+	if((code==1)&&(code!=last_slice_code))
+	  {
+	    if(pic_cnt>=mpeg2dec->picture->frame_rate-1)
+	      {
+		pic_cnt=0;
+		bitrate+=pic_byte;
+		//mpeg2dec->picture->frame_rate_code=bitrate*8;
+                _x_stream_info_set(mpeg2dec->stream, XINE_STREAM_INFO_VIDEO_BITRATE,bitrate*8);
+		bitrate=0;
+	      }
+	    bitrate+=pic_byte;
+	    pic_byte=mpeg2dec->chunk_size;
+	    pic_cnt++;
+	    last_slice_code=code;
+	  }
+	else if((code==last_slice_code||code==last_slice_code+1)&&code<=mpeg2dec->accel.mb_pic_height)
+	  {
+	    pic_byte+=mpeg2dec->chunk_size;
+	    last_slice_code=code;
+	    // if(pic_cnt
+	  }
+       else
+	 ;
+       //end
 
 	if (!mpeg2dec->drop_frame && picture->current_frame != NULL) {
 #ifdef DEBUG_LOG
@@ -570,11 +809,51 @@
 	}
     }
 
+// //========================================================================
+//     is_frame_done = mpeg2dec->in_slice && ((!code) || (code >= 0xb0));
+//     fprintf(stderr,"cur mpeg2dec_code: %x\n", code);
+// 
+//     if (is_frame_done)  {
+// 	mpeg2dec->in_slice = 0;
+// 	fprintf(stderr,"frame_done mpeg2dec_code: %x\n", code);
+//     }
+//     if (is_frame_done && picture->current_frame != NULL) {
+// 
+// 	libmpeg2_accel_frame_completion(&mpeg2dec->accel, mpeg2dec->frame_format, 
+// 					picture, code);
+// 
+// 	if (((picture->picture_structure == FRAME_PICTURE) ||
+// 	     (picture->second_field)) ) {
+// 	  
+// 	  if (mpeg2dec->drop_frame)
+// 	    picture->current_frame->bad_frame = 1;
+//    
+// 	  if (picture->picture_coding_type == B_TYPE) {
+// 	    if( picture->current_frame && !picture->current_frame->drawn ) {
+// 
+// 	      /* hack against wrong mpeg1 pts */
+// 	      if (picture->mpeg1) 
+// 	        picture->current_frame->pts = 0;
+// 
+// 	      get_frame_duration(mpeg2dec, picture->current_frame);
+// 	      mpeg2dec->frames_to_drop = picture->current_frame->draw (picture->current_frame, mpeg2dec->stream);
+// 	      picture->current_frame->drawn = 1;
+// 	    }
+// 	  } else if (picture->forward_reference_frame && !picture->forward_reference_frame->drawn) {
+// 	    get_frame_duration(mpeg2dec, picture->forward_reference_frame);
+// 	    mpeg2dec->frames_to_drop = picture->forward_reference_frame->draw (picture->forward_reference_frame,
+// 									       mpeg2dec->stream);
+// 	    picture->forward_reference_frame->drawn = 1;
+// 	  }
+// 	}
+//     }
+//     //========================================================================
+
     /* printf ("libmpeg2: parse_chunk %d completed\n", code);  */
     return is_frame_done;
 }
 
-static inline uint8_t * copy_chunk (mpeg2dec_t * mpeg2dec,
+inline uint8_t * copy_chunk (mpeg2dec_t * mpeg2dec,
 				    uint8_t * current, uint8_t * end)
 {
     uint32_t shift;
@@ -685,7 +964,13 @@
     if (picture->backward_reference_frame)
       picture->backward_reference_frame->bad_frame=1;
 
-  } else {
+   //Jack Liu, VeXP3.6, 2005-02-17
+  /*if(mpeg2dec->frame_format==XINE_IMGFMT_VIA)
+  	vmi_reset(mpeg2dec);*/
+     if(mpeg2dec->accel.can_hw_decode==VD_HW_MPEG2_SLICE)
+  	vmi_reset(mpeg2dec);
+
+  } else if(mpeg2dec->accel.can_hw_decode==NO_HW_ACCEL){
     /* to free reference frames one also needs to fix slice.c to 
      * abort when they are NULL. unfortunately it seems to break
      * DVD menus.
@@ -750,7 +1035,18 @@
       dont remove any picture->*->free() below. doing so will cause buffer 
       leak, and we only have about 15 of them.
     */ 
- 
+    
+	if(picture->MB_accel_parm&&picture->MB_accel_parm->lpIDCTBuff)
+    {
+	  free(picture->lpIDCTBuff_base);
+	  picture->MB_accel_parm->lpIDCTBuff=NULL;
+    }
+    if(picture->MB_accel_parm)
+    {
+	free(picture->MB_accel_parm_base);
+	picture->MB_accel_parm_base=NULL;
+    }
+
     if ( picture->current_frame ) {
       if( !picture->current_frame->drawn ) {
         lprintf ("blasting out current frame on close\n");
@@ -800,6 +1096,11 @@
       mpeg2dec->cc_dec->dispose(mpeg2dec->cc_dec);
       mpeg2dec->cc_dec = NULL;
     }
+    //Jack Liu,  VeXP3.6, 2005-02-17
+  /*  if(mpeg2dec->frame_format==XINE_IMGFMT_VIA)
+    	mpeg2_vmi_close(mpeg2dec);*/
+    if(mpeg2dec->accel.can_hw_decode==VD_HW_MPEG2_SLICE)
+    	mpeg2_vmi_close(&mpeg2dec->accel);	
 }
 
 void mpeg2_find_sequence_header (mpeg2dec_t * mpeg2dec,
@@ -864,7 +1165,7 @@
 }
 
 /* Find the end of the userdata field in an MPEG-2 stream */
-static uint8_t *find_end(uint8_t *buffer)
+uint8_t *find_end(uint8_t *buffer)
 {
   uint8_t *current = buffer;
   while(1) {
@@ -875,10 +1176,24 @@
   return current;
 }
 
-static void process_userdata(mpeg2dec_t *mpeg2dec, uint8_t *buffer)
+//JulionLiang, 2006-4-23
+// add a backup buffer for Closed Caption data
+#define MAX_CC_DATA_LENGTH  257         // <=256 according to CEA-608
+typedef struct _cc_data_backup{
+    uint8_t cc_data[MAX_CC_DATA_LENGTH];
+    uint32_t cc_data_len;
+    uint64_t cc_data_pts;
+} cc_data_backup_t;
+static cc_data_backup_t cc_data_tmp = {{0,},0,0};
+
+void process_userdata(mpeg2dec_t *mpeg2dec, uint8_t *buffer)
 {
-  /* check if user data denotes closed captions */
-  if (buffer[0] == 'C' && buffer[1] == 'C') {
+    int pic_type = mpeg2dec->picture->picture_coding_type;
+    // printf("picture coding type=%s\n",pic_type==1?"I":(pic_type==2?"P":(pic_type==3?"B":(pic_type==4?"D":"unknow"))));
+
+    /* check if user data denotes closed captions */
+    // JulionLiang, 2006-4-23, changed condition according to CEA-608
+    if (buffer[0] == 0x47 && buffer[1] == 0x41 && buffer[2]==0x39 && buffer[3]==0x34 && buffer[4]==0x03) {
     
     if (!mpeg2dec->cc_dec) {
       xine_event_t event;
@@ -908,12 +1223,36 @@
       buf_element_t buf;
       
       buf.type = BUF_SPU_CC;
-      buf.content = &buffer[2];
+		//JulionLiang, 2006-4-23
+		//CC data begin from buffer[7] according to CEA-608
+      buf.content = &buffer[7];
       buf.pts = mpeg2dec->pts;
-      buf.size = find_end(buffer) - &buffer[2];
+      buf.size = find_end(buffer) - &buffer[7];
       buf.decoder_flags = 0;
       
-      mpeg2dec->cc_dec->decode_data(mpeg2dec->cc_dec, &buf);
+      //JulionLiang, 2006-4-23
+      // CC displaying order is not same to decoding order
+      // so using cc_data_tmp temporarily changing the order
+      // to make displaying CC correctly.
+      if(mpeg2dec->picture->picture_coding_type == 3)
+            mpeg2dec->cc_dec->decode_data(mpeg2dec->cc_dec, &buf);
+      else{
+          if(cc_data_tmp.cc_data_len != 0){
+              /* decode restore */
+              buf_element_t bbuf;
+              bbuf.type = BUF_SPU_CC;
+              bbuf.content = &cc_data_tmp.cc_data[0];
+              bbuf.pts = cc_data_tmp.cc_data_pts;
+              bbuf.size = cc_data_tmp.cc_data_len;
+              mpeg2dec->cc_dec->decode_data(mpeg2dec->cc_dec, &bbuf);
+          }
+          else{
+              /* backup */
+              memcpy(cc_data_tmp.cc_data, buf.content, buf.size);
+              cc_data_tmp.cc_data_len = buf.size;
+              cc_data_tmp.cc_data_pts = buf.pts;
+          }
+      }
     }
   }
   /* check Active Format Description ETSI TS 101 154 V1.5.1 */
@@ -921,6 +1260,5 @@
   {
     int afd = (buffer[4] & 0x40) ? (buffer[5] & 0x0f) : -1;
     _x_stream_info_set(mpeg2dec->stream, XINE_STREAM_INFO_VIDEO_AFD, afd);
-    
-  }
+  };
 }
diff -ruN xine-lib-1.1.2-via/src/libmpeg2/header.c xine-lib-1.1.2-my-2/src/libmpeg2/header.c
--- xine-lib-1.1.2-via/src/libmpeg2/header.c	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/libmpeg2/header.c	2006-10-18 21:43:55.000000000 +0300
@@ -65,6 +65,20 @@
     53,60,61,54,47,55,62,63
 };
 
+/*Jack Liu, VeXP, fix mpeg2 zigzag issue*/
+
+uint8_t mpeg2_scan_norm_vmi[64] ATTR_ALIGN(16) = {
+    /* Zig-Zag scan pattern, will not changed, VIA HW need it */
+      0, 1, 8,16, 9, 2, 3,10,
+    17,24,32,25,18,11, 4, 5,
+    12,19,26,33,40,48,41,34,
+    27,20,13, 6, 7,14,21,28,
+    35,42,49,56,57,50,43,36,
+    29,22,15,23,30,37,44,51,
+    58,59,52,45,38,31,39,46,
+    53,60,61,54,47,55,62,63
+};
+
 uint8_t mpeg2_scan_alt[64] ATTR_ALIGN(16) =
 {
     /* Alternate scan pattern */
@@ -104,6 +118,7 @@
 void mpeg2_header_state_init (picture_t * picture)
 {
     picture->scan = mpeg2_scan_norm;
+    picture->alternate_scan = 0;  // KGy CLE266_VO
     picture->load_intra_quantizer_matrix = 1;
     picture->load_non_intra_quantizer_matrix = 1;
 }
@@ -135,6 +150,29 @@
     picture->frame_rate_code = buffer[3] & 15;
     picture->bitrate = (buffer[4]<<10)|(buffer[5]<<2)|(buffer[6]>>6);
 
+    //zhaolin:get the frame rate of stream
+    switch(picture->frame_rate_code)
+      {
+        case 1:	
+        case 2:
+          picture->frame_rate=24;
+	  break;
+        case 3:
+          picture->frame_rate=25;
+	  break;
+        case 4:
+        case 5:
+          picture->frame_rate=30;
+	  break;
+        case 6:
+          picture->frame_rate=50;
+	  break;
+        case 7:
+        case 8:
+          picture->frame_rate=60;
+	  break;
+      }
+
     if (buffer[7] & 2) {
 	for (i = 0; i < 64; i++)
 	    picture->intra_quantizer_matrix[mpeg2_scan_norm[i]] =
@@ -160,7 +198,7 @@
     picture->frame_pred_frame_dct = 1;
     picture->q_scale_type = 0;
     picture->concealment_motion_vectors = 0;
-    /* picture->alternate_scan = 0; */
+    picture->alternate_scan = 0; 
     picture->picture_structure = FRAME_PICTURE;
     /* picture->second_field = 0; */
 
@@ -234,10 +272,13 @@
     picture->q_scale_type = (buffer[3] >> 4) & 1;
     picture->intra_vlc_format = (buffer[3] >> 3) & 1;
 
-    if (buffer[3] & 4)	/* alternate_scan */
-	picture->scan = mpeg2_scan_alt;
-    else
-	picture->scan = mpeg2_scan_norm;
+    if (buffer[3] & 4){	/* alternate_scan */
+		picture->scan = mpeg2_scan_alt;
+		picture->alternate_scan = 1;
+	}else{
+		picture->scan = mpeg2_scan_norm;
+		picture->alternate_scan = 0;
+	}	
 
     /* these are not used by the decoder */
     picture->top_field_first = buffer[3] >> 7;
diff -ruN xine-lib-1.1.2-via/src/libmpeg2/libmpeg2_accel.c xine-lib-1.1.2-my-2/src/libmpeg2/libmpeg2_accel.c
--- xine-lib-1.1.2-via/src/libmpeg2/libmpeg2_accel.c	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/libmpeg2/libmpeg2_accel.c	2006-11-02 08:09:35.000000000 +0200
@@ -24,6 +24,7 @@
 #include "mpeg2.h"
 #include "mpeg2_internal.h"
 #include "xvmc_vld.h"
+#include "slice_vmi.h"
 #include "libmpeg2_accel.h"
 
 
@@ -144,6 +145,24 @@
       }
     }
   }
+  else if (frame_format == XINE_IMGFMT_VIA && code !=0xFF) {
+//	fprintf(stderr, "decode one frame, draw\n" );
+	if((accel->can_hw_decode==VD_HW_MPEG2_SLICE)&&!picture->current_frame->bad_frame)
+   	    decode_vmi_frame(accel,picture);
+	
+	if((accel->can_hw_decode==VD_HW_MPEG2_MC)&&!picture->current_frame->bad_frame)
+	{	
+	    int i=0;
+	    vmi_accel_t * p_vmi_accel=(vmi_accel_t *)picture->current_frame->accel_data;
+	    VIAMACROBLOCK *lpmb=picture->MB_accel_parm;
+	    mpeg2_vmi_mc_begin_frame (accel,  picture) ;
+	    for(i=0; i<picture->mb_pic_num;i++)
+	    {
+	    	p_vmi_accel->proc_render_frame(picture->current_frame, (void *)lpmb);
+		lpmb++;
+	    }
+	}
+  }
 }
 
 
@@ -215,6 +234,48 @@
     mpeg2_xvmc_slice (accel, picture, code, buffer);
     break;
 
+		case XINE_IMGFMT_VIA: //Jack Liu, VeXP3.6, 2005-02-16 
+			if(accel->can_hw_decode==VD_HW_MPEG2_SLICE){
+						static int can_decode;
+
+			switch (picture->picture_coding_type){
+			case I_TYPE:
+					can_decode = 1;
+				break;
+			case P_TYPE:
+					if (picture->forward_reference_frame &&
+				picture->forward_reference_frame->format == picture->current_frame->format)
+							can_decode = 1;
+					else
+							can_decode = 0;
+					break;
+			case B_TYPE:
+					if (picture->forward_reference_frame &&
+					picture->backward_reference_frame &&
+					picture->forward_reference_frame->format  == picture->current_frame->format &&
+					picture->backward_reference_frame->format == picture->current_frame->format )
+							can_decode = 1;
+					else
+				can_decode = 0;
+				break;
+				default: 
+					can_decode = 0;
+			}
+		if(can_decode){
+						mpeg2_vmi_slice (accel,picture, code, buffer, chunk_size, chunk_buffer);
+		}
+				} //else mpeg1, falling down...		   
+			else if (accel->can_hw_decode==VD_HW_MPEG2_MC)
+			{
+				
+			
+						#ifdef HW_MPEG2_MC_Debug
+				fprintf(stderr, "decode.c: mpeg2 slice via HW MC");
+								#endif
+								mpeg2_slice (picture, code, buffer);
+			}
+	break;
+
   default:
     mpeg2_slice (picture, code, buffer);
     break;
diff -ruN xine-lib-1.1.2-via/src/libmpeg2/libmpeg2_accel.h xine-lib-1.1.2-my-2/src/libmpeg2/libmpeg2_accel.h
--- xine-lib-1.1.2-via/src/libmpeg2/libmpeg2_accel.h	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/libmpeg2/libmpeg2_accel.h	2006-10-18 21:43:55.000000000 +0300
@@ -34,6 +34,30 @@
   int slices_per_row;
   int row_slice_count;
   unsigned xxmc_mb_pic_height;
+
+   //
+   //VIA MPEG2 Slice Accel special parameters, Jack Liu, VeXP3.6, 2005-02-16
+   //
+   
+    /* slice buffer for slice_recieve_data */
+   uint8_t *slice_buffer_handle;  // start address before 16 byte aligning.
+   uint8_t *slice_buffer;  // 16 byte aligned.
+   
+     uint32_t slice_received_count;
+
+   /* Working pointer for slice data accumulation. */
+   uint8_t *current;
+   /* Last slice's code for error checking. */
+   uint8_t  last_slice_code;
+  
+   unsigned  mb_frame_width;
+   unsigned  mb_frame_height;
+   /* mb height for slice counting. */
+   unsigned  mb_pic_height;  // Maybe frame or field.
+   unsigned decoded;  // We won't decode the same picture's data twice.
+   uint8_t can_hw_decode; /* 0x01(slice), 0x02(IDCT/MC),0x04(MC):can hw decoding; 0: use sw decoding. joyce added.*/
+   uint8_t can_hw_hdtv;
+   uint8_t hw_capability; /*zhaolin:add for HW_MC*/
 } mpeg2dec_accel_t;
 
 extern int libmpeg2_accel_discontinuity(mpeg2dec_accel_t *accel, uint32_t frame_format, picture_t *picture);
diff -ruN xine-lib-1.1.2-via/src/libmpeg2/Makefile.am xine-lib-1.1.2-my-2/src/libmpeg2/Makefile.am
--- xine-lib-1.1.2-via/src/libmpeg2/Makefile.am	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/libmpeg2/Makefile.am	2006-10-18 21:43:55.000000000 +0300
@@ -22,6 +22,7 @@
 	slice.c \
 	slice_xvmc.c \
 	slice_xvmc_vld.c \
+	slice_vmi.c \
 	stats.c \
 	xine_decoder.c \
 	libmpeg2_accel.c
diff -ruN xine-lib-1.1.2-via/src/libmpeg2/mpeg2_internal.h xine-lib-1.1.2-my-2/src/libmpeg2/mpeg2_internal.h
--- xine-lib-1.1.2-via/src/libmpeg2/mpeg2_internal.h	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/libmpeg2/mpeg2_internal.h	2006-10-18 21:43:55.000000000 +0300
@@ -31,6 +31,13 @@
 #include <altivec.h>
 #endif
 
+#define MAX_MB_NUM      8160    /*1920x1088*/
+#define IDCT_BUF_SIZE   768      /*used for HW MC, six blocks. intra MB:64*8*6, inter MB: 64*16*6*/
+#define NO_HW_ACCEL                        0
+#define VD_HW_MPEG2_SLICE       0x01
+#define VD_HW_MPEG2_IDCT_MC  0x02
+#define VD_HW_MPEG2_MC            0x04
+
 /* macroblock modes */
 #define MACROBLOCK_INTRA            XINE_MACROBLOCK_INTRA
 #define MACROBLOCK_PATTERN          XINE_MACROBLOCK_PATTERN
@@ -156,7 +163,7 @@
 
     /* pointer to the zigzag scan we're supposed to be using */
     uint8_t * scan;
-
+    unsigned int alternate_scan;
     struct vo_frame_s * current_frame;
     struct vo_frame_s * forward_reference_frame;
     struct vo_frame_s * backward_reference_frame;
@@ -195,9 +202,23 @@
     uint32_t broken_link;
 
     int bitrate;
+    int frame_rate;//zhaolin
     int frame_rate_ext_n;
     int frame_rate_ext_d;
 
+   /*zhaolin[2006.06.09]: added for HW MC */
+   VIAMACROBLOCK *MB_accel_parm, * MB_accel_parm_base;  
+   uint8_t  *lpIDCTBuff_base;
+   uint8_t  *lpIDCTBuff;
+   uint8_t  *lpIDCTBuff_cur;
+   uint8_t   motion_direction;
+   uint8_t   can_hw_decode;
+   uint8_t   vmiMC_mv_field_sel[2][2];
+   uint16_t mb_frame_height;
+   uint16_t mb_frame_width;
+   uint32_t mb_pic_num;
+   uint16_t mb_pic_height;
+   uint16_t vmiMC_dmvvector[2][2];
 } picture_t;
 
 typedef struct cpu_state_s {
diff -ruN xine-lib-1.1.2-via/src/libmpeg2/slice.c xine-lib-1.1.2-my-2/src/libmpeg2/slice.c
--- xine-lib-1.1.2-via/src/libmpeg2/slice.c	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/libmpeg2/slice.c	2006-10-18 21:43:55.000000000 +0300
@@ -39,6 +39,369 @@
     56, 64, 72, 80, 88, 96, 104, 112
 };
 
+
+//#define LOG_MPEG2_SOFT_DECODE  /*zhaolinwang[2006.02.20]: add this for debug info of mpeg2 soft decode*/
+//#define HW_MPEG2_MC_Debug
+#define MASK_MV_HORIBITS    0x00001fff
+#define MASK_MV_VERTBITS    0x000003ff
+
+
+#ifdef LOG_MPEG2_SOFT_DECODE
+
+static int mb_cnt=0;
+int IsDebugOutput();
+
+static  void print_macroblock_modes(picture_t * picture, int macroblock_modes)
+{
+    if (!IsDebugOutput())
+		return;
+
+   char mb_mode[80]="\0";
+   char *frame_motion_type_string[4]={
+	"non-intra mb without forward mv in a P picture",
+	"field prediction",
+	"frame prediction",
+	"dual prime prediction"
+	};
+   char *field_motion_type_string[4]={
+	"non-intra mb without forward mv in a P picture",
+	"field prediction",
+	"16x8 prediction",
+	"dual prime prediction"
+	};
+   int motion_type=0;
+   
+   if(macroblock_modes&MACROBLOCK_INTRA)
+   	strcpy(mb_mode, "MB_INTRA ");
+   if(macroblock_modes&MACROBLOCK_PATTERN)
+   	strcat(mb_mode, "MB_PATTERN ");
+   if(macroblock_modes&MACROBLOCK_MOTION_FORWARD)
+   	strcat(mb_mode, "MB_MOTION_FORWARD ");
+    if(macroblock_modes&MACROBLOCK_MOTION_BACKWARD)
+   	strcat(mb_mode, "MB_MOTION_BACKWARD ");
+   if(macroblock_modes&MACROBLOCK_QUANT)
+   	strcat(mb_mode, "MB_MOTION_QUANT ");
+   if(macroblock_modes&DCT_TYPE_INTERLACED)
+   	strcat(mb_mode, "DCT_TYPE_INTERLACED");
+   fprintf(stderr, "(MB%d):mb mode:%s\n", mb_cnt, mb_mode);
+
+   if((macroblock_modes&MACROBLOCK_INTRA)==0)
+   {
+   	motion_type=(macroblock_modes & MOTION_TYPE_MASK)>>6;
+   	if (picture->picture_structure == FRAME_PICTURE)
+   		fprintf(stderr, "(MB%d):motion type:%s\n", mb_cnt, frame_motion_type_string[motion_type]);	
+  	else   /*field picture*/
+		fprintf(stderr, "(MB%d):motion type:%s\n", mb_cnt, field_motion_type_string[motion_type]);
+   }
+}
+
+static void print_macroblock_increment( int mba_inc)
+{
+	if (!IsDebugOutput())
+		return;
+	
+	int mba_inc_info=mba_inc;
+	        if (mba_inc_info)
+	        {
+	        	do{
+				mb_cnt++;
+				fprintf(stderr, "(MB%d):skip\n", mb_cnt);
+	        		}while (--mba_inc_info);
+	        }
+		 mb_cnt++;
+		 fprintf(stderr, "(MB%d):mb address increment:%d\n", mb_cnt, mba_inc);
+}
+
+static void print_macroblock_quantizer_scale (int quantizer_scale)
+{
+	if (!IsDebugOutput())
+		return;
+	
+	fprintf(stderr, "(MB%d):mb quantizer scale:%d\n", mb_cnt, quantizer_scale);
+}
+
+static void print_motion_fr_frame (int motion_x, int motion_y)
+{
+	if (!IsDebugOutput())
+		return;
+	
+	fprintf(stderr, "(MB%d):frame-frame pred, MV hor:%d, MV ver:%d\n", mb_cnt, motion_x,motion_y);
+}
+
+static void print_motion_fr_field (int ref_field, int motion_x, int motion_y)
+{
+	if (!IsDebugOutput())
+		return;
+	
+	if(!ref_field)
+		fprintf(stderr, "(MB%d): frame-field pred, ref-top field, MV hor:%d, MV ver:%d\n", mb_cnt, motion_x,motion_y);
+	else
+		fprintf(stderr, "(MB%d):frame-field pred, ref-bottom field, MV hor:%d, MV ver:%d\n", mb_cnt, motion_x,motion_y);
+}
+
+static void print_motion_fr_dmv (int field, int motion_x, int motion_y,int dmv_x, int dmv_y, int derived_motion_x, int derived_motion_y)
+{
+	if (!IsDebugOutput())
+		return;
+	
+	char *field_slec[2]={"top field", "bottom field"};
+	fprintf(stderr, "(MB%d): frame(%s)-dmv pred, MV hor:%d, MV ver%d, dmv hor:%d, dmv ver:%d, \
+		derived MV hor:%d, derived MV ver:%d\n", mb_cnt, field_slec[field], motion_x, motion_y,
+		dmv_x, dmv_y, derived_motion_x, derived_motion_y);
+}
+
+static void print_motion_fi_field (int field, int motion_x, int motion_y)
+{
+	if (!IsDebugOutput())
+		return;
+	
+	if(!field)
+		fprintf(stderr, "(MB%d): field-field pred, ref(top field), MV hor:%d, MV ver:%d\n", mb_cnt, motion_x,motion_y);
+	else
+		fprintf(stderr, "(MB%d): field-field pred, ref(bottom field), MV hor:%d, MV ver:%d\n", mb_cnt, motion_x,motion_y);
+}
+
+static void print_motion_fi_dmv (int motion_x, int motion_y, int dmv_x, int dmv_y, int derived_motion_x, int derived_motion_y)
+{
+	if (!IsDebugOutput())
+		return;
+	
+      fprintf(stderr, "(MB%d):field-dmv pred, MV hor:%d, MV ver%d, dmv hor:%d, dmv ver:%d, derived MV hor:%d, \
+	  	derived MV ver:%d\n", mb_cnt, motion_x,motion_y, dmv_x, dmv_y, derived_motion_x,
+	  	derived_motion_y);
+}
+
+static void print_motion_fi_16x8 (int ref_field, int ver, int motion_x, int motion_y)
+{
+	if (!IsDebugOutput())
+		return;
+	
+	char *reference[2]={"ref(top field)","ref(bottom field)"};
+	char *vertical[2]={"upper 16x8", "lower 16x8"};
+	  
+	fprintf(stderr, "(MB%d): field-16x8 pred, %s, %s, MV hor:%d, MV ver:%d\n", mb_cnt, 
+		  reference[ref_field], vertical[ver], motion_x,motion_y);
+}	
+
+
+static void print_coded_block_pattern (int cbp)
+{
+	if (!IsDebugOutput())
+		return;
+	
+	fprintf(stderr, "(MB%d) cbp: Y1:%d, Y2:%d, Y3:%d, Y4:%d, U1:%d, V1:%d\n", mb_cnt, 
+		 (cbp&0x20)>>5, (cbp&0x10)>>4, (cbp&0x08)>>3, (cbp&0x04)>>2, (cbp&0x02)>>1, cbp&0x01);
+}
+
+static void print_dct_coeff (picture_t * picture)
+{
+	if (!IsDebugOutput())
+		return;
+	
+	int i=0, j=0;
+	
+	fprintf(stderr, "(MB%d): DCT coeff\n", mb_cnt);
+	for(i=0; i<8; i++)
+	{
+		for(j=0; j<8; j++)
+			fprintf(stderr, "\t%d", picture->DCTblock[j+i*8]);
+		fprintf(stderr, "\n");
+	}
+}
+
+
+#endif    /*end of #ifdef LOG_MPEG2_SOFT_DECODE*/
+
+static void printIDC( short *DCTblock)
+{
+	int i=0, j=0;
+	fprintf(stderr, "IDCT coeff\n");
+	for(i=0; i<8; i++)
+	{
+		for(j=0; j<8; j++)
+			fprintf(stderr, "\t%d", DCTblock[j+i*8]);
+		fprintf(stderr, "\n");
+	}
+}
+
+/*zhaolin:added for HW MC*/
+ static inline void mpeg2_vmi_mc_render_MB(picture_t * picture, int macroblock_modes, int cbp, char skip_flag)
+{
+	int cur_mb_num=(picture->offset>>4)+(picture->v_offset>>4)*picture->mb_frame_width;
+	VIAMACROBLOCK *lpmb=picture->MB_accel_parm+cur_mb_num;
+	picture->lpIDCTBuff_cur=picture->lpIDCTBuff+(cur_mb_num+1)*IDCT_BUF_SIZE;
+	
+	lpmb->dwMBLKInfo=0;
+	if (macroblock_modes & DCT_TYPE_INTERLACED)
+		lpmb->dwMBLKInfo |=MBLK_DCT_FIELD;
+	lpmb->dwMBLKInfo |=cbp&0x3f;
+	lpmb->dwMBLKHOffset=picture->offset>>4;
+	lpmb->dwMBLKVOffset=picture->v_offset>>4;
+	lpmb->dwVMBNum=picture->mb_pic_height;
+	lpmb->dwHMBNum=picture->mb_frame_width;
+
+	if(macroblock_modes&MACROBLOCK_INTRA)
+      {
+           if(picture->concealment_motion_vectors)
+	   {
+	    /*conceal mode*/
+	    if(picture->picture_structure==FRAME_PICTURE)
+	       lpmb->dwMBLKInfo |= MBLK_PREDICY_FRAME;
+	    else
+	       lpmb->dwMBLKInfo |= MBLK_PREDICY_FIELD;
+           }
+       }  
+	else   /*inter MB*/
+      {  
+	    lpmb->dwMBLKInfo |= MBLK_TYPE_INTER;
+          if(picture->picture_structure==FRAME_PICTURE)
+	    switch(macroblock_modes&MOTION_TYPE_MASK)
+	    {
+	      case MC_FRAME:
+		 {
+	            lpmb->dwMBLKInfo |= MBLK_PREDICY_FRAME;
+		     if(macroblock_modes&MACROBLOCK_MOTION_FORWARD)
+		     {
+		     	   lpmb->dwMBLKInfo |= MBLK_PREDICY_FWD;
+		          lpmb->dwMV[0]=(picture->f_motion.pmv[0][0]&MASK_MV_HORIBITS)|MBLK_REF_BUFF_INDEX_1;
+			   lpmb->dwMV[1]=(picture->f_motion.pmv[0][1]&MASK_MV_VERTBITS);
+			   //fprintf(stderr, "frame pred: forward pred x:%d, pred y:%d,\n", picture->f_motion.pmv[0][0],picture->f_motion.pmv[0][1]);
+		     }
+		     if(macroblock_modes&MACROBLOCK_MOTION_BACKWARD)
+		     {
+		     	   lpmb->dwMBLKInfo |= MBLK_PREDICY_BWD;
+		          lpmb->dwMV[4]=(picture->b_motion.pmv[0][0]&MASK_MV_HORIBITS)|MBLK_REF_BUFF_INDEX_2;;
+			   lpmb->dwMV[5]=(picture->b_motion.pmv[0][1]&MASK_MV_VERTBITS);
+		     }
+		     break;
+	      	 }
+	      case MC_FIELD:
+		{
+		    lpmb->dwMBLKInfo |=MBLK_PREDICY_FIELD;
+		     if(macroblock_modes&MACROBLOCK_MOTION_FORWARD)
+		     {
+		     	   lpmb->dwMBLKInfo |= MBLK_PREDICY_FWD;
+		          lpmb->dwMV[0]=(picture->f_motion.pmv[0][0]&MASK_MV_HORIBITS)|(picture->vmiMC_mv_field_sel[0][0]<<15)|MBLK_REF_BUFF_INDEX_1;;
+			   lpmb->dwMV[1]=(picture->f_motion.pmv[0][1])&MASK_MV_VERTBITS ;
+			   lpmb->dwMV[2]=(picture->f_motion.pmv[1][0]&MASK_MV_HORIBITS )|(picture->vmiMC_mv_field_sel[0][1]<<15)|MBLK_REF_BUFF_INDEX_1;;
+			   lpmb->dwMV[3]=(picture->f_motion.pmv[1][1])&MASK_MV_VERTBITS;
+		     }
+		     if(macroblock_modes&MACROBLOCK_MOTION_BACKWARD)
+		     {
+		     	    lpmb->dwMBLKInfo |= MBLK_PREDICY_BWD;
+		           lpmb->dwMV[4]=(picture->b_motion.pmv[0][0]&MASK_MV_HORIBITS) |(picture->vmiMC_mv_field_sel[1][0]<<15)|MBLK_REF_BUFF_INDEX_2;;
+			   lpmb->dwMV[5]=(picture->b_motion.pmv[0][1])&MASK_MV_VERTBITS ;
+			   lpmb->dwMV[6]=(picture->b_motion.pmv[1][0]&MASK_MV_HORIBITS) |(picture->vmiMC_mv_field_sel[1][1]<<15)|MBLK_REF_BUFF_INDEX_2;;
+			   lpmb->dwMV[7]=(picture->b_motion.pmv[1][1])&MASK_MV_VERTBITS ;
+		     }
+		    break;
+		   
+	      	}
+	      case MC_DMV:
+		{
+			fprintf(stderr, "dual prime prediction\n");
+		     lpmb->dwMBLKInfo |= MBLK_PREDICY_DP;
+		     if(macroblock_modes&MACROBLOCK_MOTION_FORWARD)
+		     {
+		     	   lpmb->dwMBLKInfo |= MBLK_PREDICY_FWD;
+		          lpmb->dwMV[0]=picture->f_motion.pmv[0][0]&MASK_MV_HORIBITS ;
+			   lpmb->dwMV[1]=picture->f_motion.pmv[0][1]&MASK_MV_VERTBITS ;
+			   lpmb->dwMV[4]=picture->vmiMC_dmvvector[0][0]&MASK_MV_HORIBITS;
+			   lpmb->dwMV[5]=picture->vmiMC_dmvvector[0][1]&MASK_MV_VERTBITS ;
+
+			   lpmb->dwMV[2]=picture->f_motion.pmv[0][0]&MASK_MV_HORIBITS ;
+			   lpmb->dwMV[3]=picture->f_motion.pmv[0][1]&MASK_MV_VERTBITS ;
+			   lpmb->dwMV[6]=picture->vmiMC_dmvvector[1][0]&MASK_MV_HORIBITS ;
+			   lpmb->dwMV[7]=picture->vmiMC_dmvvector[1][1]&MASK_MV_VERTBITS ;
+		     }
+		     break;
+		     
+	      	 }
+		case 0:
+		{
+		     lpmb->dwMBLKInfo |= MBLK_PREDICY_FRAME;
+		     lpmb->dwMBLKInfo |= MBLK_PREDICY_FWD;
+		     lpmb->dwMV[0]=0|MBLK_REF_BUFF_INDEX_1;
+		     lpmb->dwMV[1]=0;   
+		     break;
+		}
+	      default:
+		break;
+	      }
+	     else   /*field picture*/
+	           switch(macroblock_modes&MOTION_TYPE_MASK)
+		{
+	           case MC_16X8:
+		     {
+		          lpmb->dwMBLKInfo |= MBLK_PREDICY_16X8;
+		          if(macroblock_modes&MACROBLOCK_MOTION_FORWARD)
+		          {
+		          	  lpmb->dwMBLKInfo |= MBLK_PREDICY_FWD;
+		         	  lpmb->dwMV[0]=picture->f_motion.pmv[0][0] &MASK_MV_HORIBITS|(picture->vmiMC_mv_field_sel[0][0]<<15)|MBLK_REF_BUFF_INDEX_1;;
+			   	  lpmb->dwMV[1]=picture->f_motion.pmv[0][1]&MASK_MV_VERTBITS ;
+			  	  lpmb->dwMV[2]=picture->f_motion.pmv[1][0]&MASK_MV_HORIBITS |(picture->vmiMC_mv_field_sel[0][1]<<15)|MBLK_REF_BUFF_INDEX_1;;
+			 	  lpmb->dwMV[3]=picture->f_motion.pmv[1][1]&MASK_MV_VERTBITS  ;
+		           }
+		         if(macroblock_modes&MACROBLOCK_MOTION_BACKWARD)
+		         {
+		         	lpmb->dwMBLKInfo |= MBLK_PREDICY_BWD;
+		              lpmb->dwMV[4]=picture->b_motion.pmv[0][0]&MASK_MV_HORIBITS |(picture->vmiMC_mv_field_sel[1][0]<<15)|0x4000;;
+			       lpmb->dwMV[5]=picture->b_motion.pmv[0][1]&MASK_MV_VERTBITS ;
+			       lpmb->dwMV[6]=picture->b_motion.pmv[1][0]&MASK_MV_HORIBITS |(picture->vmiMC_mv_field_sel[1][1]<<15)|0x4000;;
+			       lpmb->dwMV[7]=picture->b_motion.pmv[1][1]&MASK_MV_VERTBITS  ;
+		         }
+		         break;
+	      	     }
+	           case MC_FIELD:
+		        {
+			     fprintf(stderr, "field picture, field prediction\n");
+	                   lpmb->dwMBLKInfo |= MBLK_PREDICY_FIELD;
+		            if(macroblock_modes&MACROBLOCK_MOTION_FORWARD)
+		            {
+		            	  lpmb->dwMBLKInfo |= MBLK_PREDICY_FWD;
+		            	  if(!skip_flag)
+		                    lpmb->dwMV[0]=picture->f_motion.pmv[0][0]&MASK_MV_HORIBITS|(picture->vmiMC_mv_field_sel[0][0]<<15)|MBLK_REF_BUFF_INDEX_1;
+				 else
+				     lpmb->dwMV[0]=picture->f_motion.pmv[0][0]&MASK_MV_HORIBITS|((picture->picture_structure==TOP_FIELD? 0 : 1)<<15)|MBLK_REF_BUFF_INDEX_1;
+			         lpmb->dwMV[1]=picture->f_motion.pmv[0][1]&MASK_MV_VERTBITS;
+		             }
+		           if(macroblock_modes&MACROBLOCK_MOTION_BACKWARD)
+		           {
+		           	lpmb->dwMBLKInfo |= MBLK_PREDICY_BWD;
+		               if(!skip_flag)
+		                   lpmb->dwMV[4]=picture->b_motion.pmv[0][0]&MASK_MV_HORIBITS |(picture->vmiMC_mv_field_sel[1][0]<<15)|MBLK_REF_BUFF_INDEX_2;
+				else
+				     lpmb->dwMV[4]=picture->b_motion.pmv[0][0]&MASK_MV_HORIBITS|((picture->picture_structure==TOP_FIELD? 0 : 1)<<15)|MBLK_REF_BUFF_INDEX_2;
+			        lpmb->dwMV[5]=picture->b_motion.pmv[0][1]&MASK_MV_VERTBITS;
+		           }
+		          break;
+	      	       }
+	           case MC_DMV:
+	               lpmb->dwMBLKInfo |= MBLK_PREDICY_DP;
+		        if(macroblock_modes&MACROBLOCK_MOTION_FORWARD)
+		       {
+		          lpmb->dwMBLKInfo |= MBLK_PREDICY_FWD;
+		          lpmb->dwMV[0]=picture->f_motion.pmv[0][0]&MASK_MV_HORIBITS ;
+			   lpmb->dwMV[1]=picture->f_motion.pmv[0][1]&MASK_MV_VERTBITS ;
+			   lpmb->dwMV[4]=picture->vmiMC_dmvvector[0][0]&MASK_MV_HORIBITS;
+			   lpmb->dwMV[5]=picture->vmiMC_dmvvector[0][1]&MASK_MV_VERTBITS ;
+
+		         }
+		        break;
+		     case 0:
+		    {
+		         lpmb->dwMBLKInfo |= MBLK_PREDICY_FIELD;
+		         lpmb->dwMBLKInfo |= MBLK_PREDICY_FWD;
+		         lpmb->dwMV[0]=0|((picture->picture_structure==TOP_FIELD? 0 : 1)<<15)|MBLK_REF_BUFF_INDEX_1;
+		         lpmb->dwMV[1]=0;
+		        break;
+		    }
+	          default:
+		       break;
+	      }
+       }  
+}
+
 static inline int get_macroblock_modes (picture_t * picture)
 {
 #define bit_buf (picture->bitstream_buf)
@@ -968,7 +1331,19 @@
 	get_intra_block_B15 (picture);
     else
 	get_intra_block_B14 (picture);
+
+    #ifdef LOG_MPEG2_SOFT_DECODE
+	print_dct_coeff(picture);
+    #endif
+	
+    if(picture->can_hw_decode==NO_HW_ACCEL)
     mpeg2_idct_copy (picture->DCTblock, dest, stride);
+    else if(picture->can_hw_decode==VD_HW_MPEG2_MC)
+	{
+	    mpeg2_idct_copy (picture->DCTblock, picture->lpIDCTBuff_cur, 8);
+	    picture->lpIDCTBuff_cur+=64;
+	   //printIDC(picture->lpIDCTBuff_cur-64);
+    	}
 #undef bit_buf
 #undef bits
 #undef bit_ptr
@@ -981,7 +1356,23 @@
 	get_mpeg1_non_intra_block (picture);
     else
 	get_non_intra_block (picture);
-    mpeg2_idct_add (picture->DCTblock, dest, stride);
+
+    
+    if(picture->can_hw_decode==NO_HW_ACCEL)
+        mpeg2_idct_add (picture->DCTblock, dest, stride);
+    else if(picture->can_hw_decode==VD_HW_MPEG2_MC)
+	{
+	    mpeg2_idct(picture->DCTblock);
+    #ifdef LOG_MPEG2_SOFT_DECODE
+	print_dct_coeff(picture);
+    #endif
+	  xine_fast_memcpy((void *) picture->lpIDCTBuff_cur, (void *)picture->DCTblock, 128); 
+	/* int16_t  *lpIDCT= (int16_t *)picture->lpIDCTBuff_cur; int i=0;
+	 for(i=0;i<64; i++)
+	 *(lpIDCT++)=(picture->DCTblock[i])&0xffff;*/
+	    picture->lpIDCTBuff_cur+=128;
+	    mpeg2_zero_block(picture->DCTblock);
+	}
 }
 
 #define MOTION(table,ref,motion_x,motion_y,size,y)			      \
@@ -1097,7 +1488,14 @@
     motion_y = bound_motion_vector (motion_y, motion->f_code[1]);
     motion->pmv[1][1] = motion->pmv[0][1] = motion_y;
 
+    if(picture->can_hw_decode==NO_HW_ACCEL)
+    {
     MOTION (table, motion->ref[0], motion_x, motion_y, 16, 0);
+    }
+
+    #ifdef LOG_MPEG2_SOFT_DECODE
+	print_motion_fr_frame( motion_x, motion_y);
+    #endif
 #undef bit_buf
 #undef bits
 #undef bit_ptr
@@ -1116,6 +1514,7 @@
     field = UBITS (bit_buf, 1);
     DUMPBITS (bit_buf, bits, 1);
 
+    picture->vmiMC_mv_field_sel[picture->motion_direction][0]=field; /*the op of ref for top field*/
     motion_x = motion->pmv[0][0] + get_motion_delta (picture,
 						     motion->f_code[0]);
     motion_x = bound_motion_vector (motion_x, motion->f_code[0]);
@@ -1127,12 +1526,19 @@
     /* motion_y = bound_motion_vector (motion_y, motion->f_code[1]); */
     motion->pmv[0][1] = motion_y << 1;
 
+    if(picture->can_hw_decode==NO_HW_ACCEL)
+    {
     MOTION_FIELD (table, motion->ref[0], motion_x, motion_y, 0, & ~1, field);
+    }
+    #ifdef LOG_MPEG2_SOFT_DECODE
+    print_motion_fr_field(field, motion_x, motion_y);
+    #endif
 
     NEEDBITS (bit_buf, bits, bit_ptr);
     field = UBITS (bit_buf, 1);
     DUMPBITS (bit_buf, bits, 1);
 
+    picture->vmiMC_mv_field_sel[picture->motion_direction][1]=field; /*the op of ref for bot field*/
     motion_x = motion->pmv[1][0] + get_motion_delta (picture,
 						     motion->f_code[0]);
     motion_x = bound_motion_vector (motion_x, motion->f_code[0]);
@@ -1144,7 +1550,13 @@
     /* motion_y = bound_motion_vector (motion_y, motion->f_code[1]); */
     motion->pmv[1][1] = motion_y << 1;
 
+    if(picture->can_hw_decode==NO_HW_ACCEL)
+    {
     MOTION_FIELD (table, motion->ref[0], motion_x, motion_y, 1, & ~1, field);
+    }
+    #ifdef LOG_MPEG2_SOFT_DECODE
+    print_motion_fr_field(field, motion_x, motion_y);
+    #endif
 #undef bit_buf
 #undef bits
 #undef bit_ptr
@@ -1176,13 +1588,27 @@
     m = picture->top_field_first ? 1 : 3;
     other_x = ((motion_x * m + (motion_x > 0)) >> 1) + dmv_x;
     other_y = ((motion_y * m + (motion_y > 0)) >> 1) + dmv_y - 1;
+    if(picture->can_hw_decode==NO_HW_ACCEL)
+    {
     MOTION_FIELD (mpeg2_mc.put, motion->ref[0], other_x, other_y, 0, | 1, 0);
+    }
+    #ifdef LOG_MPEG2_SOFT_DECODE
+    print_motion_fr_dmv(0, motion_x>>1, motion_y>>1, dmv_x, dmv_y, other_x, other_y);
+    #endif
 
     m = picture->top_field_first ? 3 : 1;
     other_x = ((motion_x * m + (motion_x > 0)) >> 1) + dmv_x;
     other_y = ((motion_y * m + (motion_y > 0)) >> 1) + dmv_y + 1;
+    if(picture->can_hw_decode==NO_HW_ACCEL)
+    {
     MOTION_FIELD (mpeg2_mc.put, motion->ref[0], other_x, other_y, 1, & ~1, 0);
+    }
+    #ifdef LOG_MPEG2_SOFT_DECODE
+    print_motion_fr_dmv(1, motion_x>>1, motion_y>>1, dmv_x, dmv_y, other_x, other_y);
+    #endif
 
+  if(picture->can_hw_decode==NO_HW_ACCEL)
+{
     pos_x = 2 * picture->offset + motion_x;
     pos_y = picture->v_offset + motion_y;
     if(pos_x > picture->limit_x){
@@ -1224,6 +1650,8 @@
 	(picture->dest[2] + picture->pitches[2] + (picture->offset >> 1),
 	 motion->ref[0][2] + picture->pitches[2] + offset,
 	 2 * picture->pitches[2], 4);
+  }
+  
 #undef bit_buf
 #undef bits
 #undef bit_ptr
@@ -1238,12 +1666,18 @@
     motion_x = motion->pmv[0][0];
     motion_y = motion->pmv[0][1];
 
+    if(picture->can_hw_decode==NO_HW_ACCEL)
+    {
     MOTION (table, motion->ref[0], motion_x, motion_y, 16, 0);
 }
+}
 
 static void motion_zero (picture_t * picture, motion_t * motion,
 			 void (** table) (uint8_t *, uint8_t *, int, int))
 {
+    if(picture->can_hw_decode!=NO_HW_ACCEL)
+		return;
+
     table[0] (picture->dest[0] + picture->offset,
 	      (motion->ref[0][0] + picture->offset +
 	       picture->v_offset * picture->pitches[0]),
@@ -1294,11 +1728,14 @@
     int motion_x, motion_y;
     uint8_t ** ref_field;
     unsigned int pos_x, pos_y, xy_half;
+    uint8_t reference=0;
 
     NEEDBITS (bit_buf, bits, bit_ptr);
-    ref_field = motion->ref2[UBITS (bit_buf, 1)];
+    reference=UBITS (bit_buf, 1);
+    ref_field = motion->ref2[reference];
     DUMPBITS (bit_buf, bits, 1);
 
+    picture->vmiMC_mv_field_sel[picture->motion_direction][0]=reference;
     motion_x = motion->pmv[0][0] + get_motion_delta (picture,
 						     motion->f_code[0]);
     motion_x = bound_motion_vector (motion_x, motion->f_code[0]);
@@ -1310,7 +1747,14 @@
     motion_y = bound_motion_vector (motion_y, motion->f_code[1]);
     motion->pmv[1][1] = motion->pmv[0][1] = motion_y;
 
+    if(picture->can_hw_decode==NO_HW_ACCEL)
+    {
     MOTION (table, ref_field, motion_x, motion_y, 16, 0);
+    }
+	
+    #ifdef LOG_MPEG2_SOFT_DECODE
+    print_motion_fi_field(reference, motion_x, motion_y);
+    #endif
 #undef bit_buf
 #undef bits
 #undef bit_ptr
@@ -1325,11 +1769,14 @@
     int motion_x, motion_y;
     uint8_t ** ref_field;
     unsigned int pos_x, pos_y, xy_half;
+    uint8_t reference=0;
 
     NEEDBITS (bit_buf, bits, bit_ptr);
-    ref_field = motion->ref2[UBITS (bit_buf, 1)];
+    reference=UBITS (bit_buf, 1);
+    ref_field = motion->ref2[reference];
     DUMPBITS (bit_buf, bits, 1);
 
+    picture->vmiMC_mv_field_sel[picture->motion_direction][0]=reference;  /*the op of ref for upper field*/
     motion_x = motion->pmv[0][0] + get_motion_delta (picture,
 						     motion->f_code[0]);
     motion_x = bound_motion_vector (motion_x, motion->f_code[0]);
@@ -1341,12 +1788,20 @@
     motion_y = bound_motion_vector (motion_y, motion->f_code[1]);
     motion->pmv[0][1] = motion_y;
 
+    if(picture->can_hw_decode==NO_HW_ACCEL)
+    {
     MOTION (table, ref_field, motion_x, motion_y, 8, 0);
+    }
+    #ifdef LOG_MPEG2_SOFT_DECODE
+	print_motion_fi_16x8 (reference, 0, motion_x, motion_y);
+    #endif
 
     NEEDBITS (bit_buf, bits, bit_ptr);
-    ref_field = motion->ref2[UBITS (bit_buf, 1)];
+    reference=UBITS (bit_buf, 1);
+    ref_field = motion->ref2[reference];
     DUMPBITS (bit_buf, bits, 1);
 
+    picture->vmiMC_mv_field_sel[picture->motion_direction][1]=reference; /*the op of ref for lower field*/
     motion_x = motion->pmv[1][0] + get_motion_delta (picture,
 						     motion->f_code[0]);
     motion_x = bound_motion_vector (motion_x, motion->f_code[0]);
@@ -1358,7 +1813,13 @@
     motion_y = bound_motion_vector (motion_y, motion->f_code[1]);
     motion->pmv[1][1] = motion_y;
 
+    if(picture->can_hw_decode==NO_HW_ACCEL)
+    {
     MOTION (table, ref_field, motion_x, motion_y, 8, 8);
+    }
+    #ifdef LOG_MPEG2_SOFT_DECODE
+	print_motion_fi_16x8 (reference, 1, motion_x, motion_y);
+    #endif
 #undef bit_buf
 #undef bits
 #undef bit_ptr
@@ -1371,6 +1832,7 @@
 #define bits (picture->bitstream_bits)
 #define bit_ptr (picture->bitstream_ptr)
     int motion_x, motion_y, other_x, other_y;
+    int dmv_x, dmv_y;
     unsigned int pos_x, pos_y, xy_half;
 
     NEEDBITS (bit_buf, bits, bit_ptr);
@@ -1379,17 +1841,26 @@
     motion_x = bound_motion_vector (motion_x, motion->f_code[0]);
     motion->pmv[1][0] = motion->pmv[0][0] = motion_x;
     NEEDBITS (bit_buf, bits, bit_ptr);
-    other_x = ((motion_x + (motion_x > 0)) >> 1) + get_dmv (picture);
+    dmv_x=get_dmv (picture);
+    other_x = ((motion_x + (motion_x > 0)) >> 1) + dmv_x;
 
     motion_y = motion->pmv[0][1] + get_motion_delta (picture,
 						     motion->f_code[1]);
     motion_y = bound_motion_vector (motion_y, motion->f_code[1]);
     motion->pmv[1][1] = motion->pmv[0][1] = motion_y;
-    other_y = (((motion_y + (motion_y > 0)) >> 1) + get_dmv (picture) +
+    dmv_y=get_dmv (picture);
+    other_y = (((motion_y + (motion_y > 0)) >> 1) + dmv_y +
 	       picture->dmv_offset);
 
+    if(picture->can_hw_decode==NO_HW_ACCEL)
+    {
     MOTION (mpeg2_mc.put, motion->ref[0], motion_x, motion_y, 16, 0);
     MOTION (mpeg2_mc.avg, motion->ref[1], other_x, other_y, 16, 0);
+    }
+
+   #ifdef LOG_MPEG2_SOFT_DECODE
+    print_motion_fi_dmv(motion_x, motion_y, dmv_x, dmv_y, other_x, other_y);
+    #endif
 #undef bit_buf
 #undef bits
 #undef bit_ptr
@@ -1425,11 +1896,17 @@
 #define MOTION_CALL(routine,direction)				\
 do {								\
     if ((direction) & MACROBLOCK_MOTION_FORWARD)		\
+    {                                                                                   \
+    	picture->motion_direction=0;                                    \
 	routine (picture, &(picture->f_motion), mpeg2_mc.put);	\
+     }                                                                                  \
     if ((direction) & MACROBLOCK_MOTION_BACKWARD)		\
+    {                                                                         \
+       picture->motion_direction=1;    \
 	routine (picture, &(picture->b_motion),			\
 		 ((direction) & MACROBLOCK_MOTION_FORWARD ?	\
 		  mpeg2_mc.avg : mpeg2_mc.put));		\
+    }                                                                        \
 } while (0)
 
 #define NEXT_MACROBLOCK							    \
@@ -1594,6 +2071,12 @@
 	    return 1;
 	}
     }
+
+    #ifdef LOG_MPEG2_SOFT_DECODE
+	mb_cnt=0;
+	print_macroblock_increment(offset + mba->mba);
+    #endif
+	
     DUMPBITS (bit_buf, bits, mba->len + 1);
     picture->offset = (offset + mba->mba) << 4;
 
@@ -1639,11 +2122,16 @@
 	NEEDBITS (bit_buf, bits, bit_ptr);
 
 	macroblock_modes = get_macroblock_modes (picture);
-
+	
 	/* maybe integrate MACROBLOCK_QUANT test into get_macroblock_modes ? */
 	if (macroblock_modes & MACROBLOCK_QUANT)
 	    picture->quantizer_scale = get_quantizer_scale (picture);
 
+	#ifdef LOG_MPEG2_SOFT_DECODE
+	    print_macroblock_modes(picture, macroblock_modes);
+	    print_macroblock_quantizer_scale(picture->quantizer_scale);
+       #endif
+
 	if (macroblock_modes & MACROBLOCK_INTRA) {
 
 	    int DCT_offset, DCT_stride;
@@ -1685,6 +2173,9 @@
 		NEEDBITS (bit_buf, bits, bit_ptr);
 		DUMPBITS (bit_buf, bits, 1);
 	    }
+		
+	    if(picture->can_hw_decode==VD_HW_MPEG2_MC)
+		mpeg2_vmi_mc_render_MB(picture, macroblock_modes, 0x3f, 0);
 	} else {
 
 	    if (picture->picture_structure == FRAME_PICTURE)
@@ -1737,8 +2228,9 @@
 		    break;
 		}
 
+	    int coded_block_pattern=0;
 	    if (macroblock_modes & MACROBLOCK_PATTERN) {
-		int coded_block_pattern;
+		
 		int DCT_offset, DCT_stride;
 		int offset;
 		uint8_t * dest_y;
@@ -1752,6 +2244,9 @@
 		}
 
 		coded_block_pattern = get_coded_block_pattern (picture);
+		#ifdef LOG_MPEG2_SOFT_DECODE
+		print_coded_block_pattern(coded_block_pattern);
+		#endif
 
 		offset = picture->offset;
 		dest_y = picture->dest[0] + offset;
@@ -1773,10 +2268,15 @@
 		    slice_non_intra_DCT (picture,
 					 picture->dest[2] + (offset >> 1),
 					 picture->pitches[2]);
+		
 	    }
 
 	    picture->dc_dct_pred[0] = picture->dc_dct_pred[1] =
 		picture->dc_dct_pred[2] = 128 << picture->intra_dc_precision;
+
+	    if(picture->can_hw_decode==VD_HW_MPEG2_MC)
+		  mpeg2_vmi_mc_render_MB(picture, macroblock_modes, coded_block_pattern, 0);
+    
 	}
 
 	NEXT_MACROBLOCK;
@@ -1807,6 +2307,11 @@
 	DUMPBITS (bit_buf, bits, mba->len);
 	mba_inc += mba->mba;
 
+      #ifdef LOG_MPEG2_SOFT_DECODE
+	  print_macroblock_increment( mba_inc);
+      #endif
+
+
 	if (mba_inc) {
 	    picture->dc_dct_pred[0] = picture->dc_dct_pred[1] =
 		picture->dc_dct_pred[2] = 128 << picture->intra_dc_precision;
@@ -1817,16 +2322,24 @@
 
 		do {
 		    MOTION_CALL (motion_zero, MACROBLOCK_MOTION_FORWARD);
+		    if(picture->can_hw_decode==VD_HW_MPEG2_MC)
+		       mpeg2_vmi_mc_render_MB(picture, MACROBLOCK_MOTION_FORWARD, 0, 1);
 		    NEXT_MACROBLOCK;
 		} while (--mba_inc);
 	    } else {
-		do {
+		do {  /*B picture*/
 		    MOTION_CALL (motion_reuse, macroblock_modes);
+	           if(picture->can_hw_decode==VD_HW_MPEG2_MC)
+		       mpeg2_vmi_mc_render_MB(picture, macroblock_modes, 0, 1);
 		    NEXT_MACROBLOCK;
 		} while (--mba_inc);
 	    }
 	}
     }
+
+
+
+
 #undef bit_buf
 #undef bits
 #undef bit_ptr
diff -ruN xine-lib-1.1.2-via/src/libmpeg2/slice_vmi.c xine-lib-1.1.2-my-2/src/libmpeg2/slice_vmi.c
--- xine-lib-1.1.2-via/src/libmpeg2/slice_vmi.c	1970-01-01 03:00:00.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/libmpeg2/slice_vmi.c	2006-11-02 08:04:26.000000000 +0200
@@ -0,0 +1,331 @@
+/*
+ *    Copyright (c) 1998-2006 VIA Technologies, Inc.
+ *    Copyright (c) 2001-2006 S3 Graphics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTIES OR REPRESENTATIONS; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "xine_internal.h"
+#include "video_out.h"
+#include "mpeg2.h"
+#include "mpeg2_internal.h"
+
+#include "slice_vmi.h"
+
+// Accelerator specific header.
+#include "viampg.h"
+#include "viavid.h"
+
+
+//#define CLE266_LOG
+
+/* Picture encoded size limitation here.
+ * Compressed data will not be larger than de-compressed picture?
+ * For HDTV.
+ */
+//#define SLICE_BUF_SIZE 1920*1080*2 + 15
+#define SLICE_BUF_SIZE 1194*1024 //modifyied by Dave
+
+void mpeg2_vmi_close(mpeg2dec_t * mpeg2dec) {
+
+   if (mpeg2dec->accel.slice_buffer_handle)
+    free(mpeg2dec->accel.slice_buffer_handle);
+ 
+}
+
+/* Init the structure for cle266 functions.
+ * Return -1 if failed.
+ */
+
+int mpeg2_vmi_init(mpeg2dec_t * mpeg2dec) {
+ 
+  mpeg2dec->accel.slice_buffer_handle = malloc(SLICE_BUF_SIZE);
+  if (!mpeg2dec->accel.slice_buffer_handle){ 
+  	printf("VMI HW Slice Init failed, not enough memeory??, Using Software decoder Instead.\n");
+	mpeg2dec->frame_format = XINE_IMGFMT_YV12; 
+  	return -1;
+  }
+  
+  mpeg2dec->accel.current=mpeg2dec->accel.slice_buffer =
+    (uint8_t *)(((unsigned long)(mpeg2dec->accel.slice_buffer_handle) + 15) &(~(unsigned long)0xf)); // Horace edit for 64 bits OS
+
+  mpeg2dec->accel.slice_received_count=0;
+  mpeg2dec->accel.last_slice_code=0;
+  mpeg2dec->accel.mb_frame_height=0;
+  mpeg2dec->accel.mb_frame_width=0;
+  mpeg2dec->accel.mb_pic_height=0;
+  mpeg2dec->accel.decoded=0;
+  
+  return 0;
+}
+
+
+/* Accumulate slice data and check if one good frame is
+ *   done, i.e. all slice came in correct order.
+ *   Then call vo_driver function to decode.
+ */
+void mpeg2_vmi_slice (mpeg2dec_accel_t* accel, picture_t * picture, int code, uint8_t * buffer, uint32_t chunk_size, uint8_t *chunk_buffer) {
+
+    /*add  for HDTV*/
+  uint32_t       chunk_count;
+  int32_t        added_count_for_alignment;
+  uint32_t       *slice_received_count;
+  const uint32_t size_of_uint32             = sizeof(uint32_t);   
+   
+ /*add for HDTV*/
+ chunk_count                = chunk_size;
+ slice_received_count       = &(accel->slice_received_count);
+ /*add for HTDV*/
+  if (code == 1) {  // First slice of a coded picture.
+#ifdef CLE266_LOG
+    fprintf(stderr, "libmpeg2: CLE266: first slice comes now.\n");
+#endif
+   
+    // Frame size in mb.
+    // Note coded_picture_width is already snapped to mb boundary.
+    accel->mb_frame_width  = picture->coded_picture_width/16; 
+    accel->mb_frame_height = (!(picture->mpeg1) && (picture->progressive_sequence)) ?
+      		2*((picture->display_height+31)/32) : (picture->display_height+15)/16; 
+    // Height of this coded picture in mb.
+    accel->mb_pic_height = (picture->picture_structure == FRAME_PICTURE ) ?
+    		accel->mb_frame_height :   accel->mb_frame_height / 2;
+  }
+
+  if ((code == accel->last_slice_code ||
+       code == accel->last_slice_code + 1) &&
+      code <= accel->mb_pic_height) {
+    // Then this is the wanted slice.
+    /* Slice buffer layout:
+     * A set of slices, stored from the buffer's first byte one by one
+     *   with no blank byte beween slices.
+     * A slice: dwsize|dwslice_start_code|slice_data|padding_to_dw_boundary|qw0.
+     * The dwsize element is the size of the data after it, include the padding and
+     *   the 8 zero bytes, used to access the next slice.
+     */
+    uint32_t slice_size = 0;
+     if (chunk_count%size_of_uint32)
+  		  added_count_for_alignment = size_of_uint32*3-(chunk_count%size_of_uint32);
+     else
+   		 added_count_for_alignment = size_of_uint32*2-(chunk_count%size_of_uint32);
+ 	 slice_size = chunk_size + added_count_for_alignment +4 +8;
+    //slice_size = mpeg2dec->chunk_size + (4 - mpeg2dec->chunk_size%4) +4 +8;
+    *(uint32_t *)(accel->current) = slice_size;
+    // Check slice buffer overflow.
+    if ((unsigned int)(accel->current + slice_size
+		       - accel->slice_buffer) <=
+	SLICE_BUF_SIZE) {// modified by Dave
+      accel->current += 4;
+      accel->current[0] = 0;
+      accel->current[1] = 0;
+      accel->current[2] = 1;
+      accel->current[3] = code;  // Note code is uint8_t.
+      accel->current += 4;
+    /*  memcpy((void *)(mpeg2dec->current),
+	     (void *)(mpeg2dec->chunk_buffer),
+	     mpeg2dec->chunk_size);*/
+      xine_fast_memcpy((void *)(accel->current),    /*zhaolin[20060228]:use xine_fast_memcpy replace memcpy*/
+	     (void *)(chunk_buffer),
+	     chunk_size);
+      accel->current += chunk_size;
+      memset((void *)(accel->current),0,slice_size - chunk_size);
+      // Note here we also cleared next slice's size field to 0.
+      accel->current += slice_size - chunk_size -4;  // Total - Data - Code.
+
+      // Update slice_count.
+      //*(unsigned int *)accel_data_cle266->slice_buffer += 1;// comment by Dave
+      
+     #ifdef CLE266_LOG
+    		printf("libmpeg2: VMI: count slice .\n");
+     #endif
+      accel->last_slice_code = code;
+
+      picture->v_offset = code * 16;
+
+	(*slice_received_count)++;
+      #ifdef CLE266_LOG
+    		fprintf(stderr, "Fire slice, slice_received_count %d\n", *slice_received_count);
+     #endif
+      /*add for HDTV*/
+      return;  // This is the only path for normal decoding.
+    } 
+  }
+
+  // Error!
+#ifdef CLE266_LOG
+   fprintf(stderr, "libmpeg2: CLE266: slice error.\n");
+#endif
+
+  picture->v_offset = 0;  // So that frame is bad, will not do actual decode.
+  slice_vmi_reset(accel);
+
+  return;
+}
+/*Jack Liu, VeXP, fix mpeg2 zigzag issue*/
+extern uint8_t mpeg2_scan_norm[64];
+extern uint8_t mpeg2_scan_norm_vmi[64];
+
+void decode_vmi_frame (mpeg2dec_accel_t* accel, picture_t * picture) {
+
+   /*add for HDTV*/
+   uint8_t       *slice_current;
+  uint32_t       *slice_received_count;
+  /*add for HDTV*/
+  vmi_accel_t * p_vmi_accel=(vmi_accel_t *)picture->current_frame->accel_data;
+  
+  // We are ready to do decode, just collect data and call accelerator. Accelerator is only called here.
+
+ 
+  /* Note: Some members are directly copied since their definations are identical
+   *   in driver and decoder.
+   */
+  {
+    // General info.
+    p_vmi_accel->mpg_accel_param.dwDecoderMode  = USE_SLICE;
+    p_vmi_accel->mpg_accel_param.dwMpeg2        = !(picture->mpeg1);  // Actually we are not using HW to decode MPEG1.
+    p_vmi_accel->mpg_accel_param.dwMPEG4Decode  = 0;
+
+    p_vmi_accel->mpg_accel_param.dwPictureType      = picture->picture_coding_type;  // Same defination.
+    p_vmi_accel->mpg_accel_param.dwDecodePictStruct = picture->picture_structure;    // Same defination.
+    
+    p_vmi_accel->mpg_accel_param.dwAlternateScan    = picture->alternate_scan;  // Boolean if we will use the alternate scan.
+    
+    {
+      int i,j;
+      unsigned char GLDintra_quantizer_matrix[64];
+      unsigned char GLDnon_intra_quantizer_matrix[64]; /*Jack Liu, VeXP, fix mpeg2 zigzag issue*/
+      
+     p_vmi_accel->mpg_accel_param.dwQMatrixChanged = TRUE;
+     
+     for(i=0;i<64;i++){
+	  	GLDintra_quantizer_matrix[mpeg2_scan_norm_vmi[i]]=picture->intra_quantizer_matrix[mpeg2_scan_norm[i]];
+		GLDnon_intra_quantizer_matrix[mpeg2_scan_norm_vmi[i]]=picture->non_intra_quantizer_matrix[mpeg2_scan_norm[i]];
+	} /*Jack Liu, VeXP, fix mpeg2 zigzag issue*/
+	
+      for(i=0,j=0;i<64;i+=4,j++){
+	p_vmi_accel->mpg_accel_param.dwQMatrix[0][j] =
+	  (GLDintra_quantizer_matrix[i] & 0xff) |
+	  ((GLDintra_quantizer_matrix[i+1] & 0xff) << 8)|
+	  ((GLDintra_quantizer_matrix[i+2] & 0xff) << 16)|
+	  ((GLDintra_quantizer_matrix[i+3] & 0xff) << 24);
+      }
+      for(i=0,j=0;i<64;i+=4,j++){
+	p_vmi_accel->mpg_accel_param.dwQMatrix[1][j] =
+	  (GLDnon_intra_quantizer_matrix[i] & 0xff) |
+	  ((GLDnon_intra_quantizer_matrix[i+1] & 0xff) << 8)|
+	  ((GLDnon_intra_quantizer_matrix[i+2] & 0xff) << 16)|
+	    ((GLDnon_intra_quantizer_matrix[i+3] & 0xff) << 24);
+      }
+    }
+    /*add for HDTV*/
+    
+     slice_received_count       = &(accel->slice_received_count);
+     slice_current = (uint8_t *)accel->slice_buffer;
+      /* update the real hw_slice_buffer ptr */
+      accel->current = slice_current;
+
+      /*  After VMI 2.2, AP needs to assign the slice number count to the
+       *  slice data structure, for multiple slice issue
+       */
+     // if ((cle266_driver_t *)(accel_cle266->vo_accel.driver)->p_vmi_info.dwAPIVersion >= API_VERSION_NUMERIC(2,2)){
+         *(unsigned int *)slice_current= *slice_received_count; // Horace edit for 64 bits OS
+     // }
+     #ifdef CLE266_LOG
+    		printf("Fire slice, slice_received_count %d\n", *slice_received_count);
+     #endif
+      *slice_received_count = 0;
+  /*add for HDTV,end*/
+    p_vmi_accel->mpg_accel_param.dwMBwidth      = accel->mb_frame_width;
+    //VIAMPGSurface.dwV_size_g2800 = vertical_size>2800;
+    p_vmi_accel->mpg_accel_param.dwTopFirst     = picture->top_field_first;
+    p_vmi_accel->mpg_accel_param.dwFramePredDct = picture->frame_pred_frame_dct;
+    p_vmi_accel->mpg_accel_param.dwMBAmax       = accel->mb_frame_width * accel->mb_frame_height;
+    p_vmi_accel->mpg_accel_param.dwIntravlc     = picture->intra_vlc_format;
+    p_vmi_accel->mpg_accel_param.dwDcPrec       = picture->intra_dc_precision;
+    p_vmi_accel->mpg_accel_param.dwQscaleType   = picture->q_scale_type;
+    p_vmi_accel->mpg_accel_param.dwConcealMV    = picture->concealment_motion_vectors;
+    //VIAMPGSurface.dwSliceFirst = 1;
+   p_vmi_accel->mpg_accel_param.dwSecondField  = picture->second_field;
+    
+    if(!picture->mpeg1){  // ToDo: b_, f_ and [0],[1] may need checking.
+      p_vmi_accel->mpg_accel_param.BVMVRange = picture->b_motion.f_code[1];
+      p_vmi_accel->mpg_accel_param.BHMVRange = picture->b_motion.f_code[0];
+      p_vmi_accel->mpg_accel_param.FVMVRange = picture->f_motion.f_code[1];
+      p_vmi_accel->mpg_accel_param.FHMVRange = picture->f_motion.f_code[0];
+    } else {
+      p_vmi_accel->mpg_accel_param.BVMVRange = picture->b_motion.f_code[0];
+      p_vmi_accel->mpg_accel_param.BHMVRange = picture->b_motion.f_code[0];
+      p_vmi_accel->mpg_accel_param.FVMVRange = picture->f_motion.f_code[0];
+      p_vmi_accel->mpg_accel_param.FHMVRange = picture->f_motion.f_code[0];
+    }
+  }
+
+  //calculate hardware surface id.
+  {
+	vmi_accel_t * p_vmi_accel_fr, *p_vmi_accel_br;
+	
+  	p_vmi_accel->mpg_accel_param.dwDecodeBuffIndex=p_vmi_accel->surf_id;
+	p_vmi_accel->mpg_accel_param.dwOldRefFrame=p_vmi_accel->mpg_accel_param.dwRefFrame=-1;
+
+	if((picture->forward_reference_frame)&&(picture->forward_reference_frame->accel_data)){
+		p_vmi_accel_fr=(vmi_accel_t *)picture->forward_reference_frame->accel_data;
+		p_vmi_accel->mpg_accel_param.dwOldRefFrame=p_vmi_accel_fr->surf_id;
+	}		
+
+       if((picture->backward_reference_frame)&&(picture->backward_reference_frame->accel_data)){
+		p_vmi_accel_br=(vmi_accel_t *)picture->backward_reference_frame->accel_data;
+		p_vmi_accel->mpg_accel_param.dwRefFrame=p_vmi_accel_br->surf_id;
+	}	
+   	
+  }
+
+
+  p_vmi_accel->decoded_ok=1;
+  
+  // ToDo: check sth.
+  p_vmi_accel->proc_begin_frame(picture->current_frame);
+  
+  if(p_vmi_accel->p_vmi_info->dwAPIVersion < API_VERSION_NUMERIC(2,2))
+  {
+  	fprintf(stderr, "branch < \n");
+  	p_vmi_accel->proc_render_frame(picture->current_frame,accel->slice_buffer+4);
+  }
+  else
+  {
+  	fprintf(stderr, "branch => \n");  
+       p_vmi_accel->proc_render_frame(picture->current_frame,accel->slice_buffer);
+  }
+
+}
+
+void slice_vmi_reset (mpeg2dec_accel_t* accel) {
+/*
+  // First of all check environment.
+  if (mpeg2dec->frame_format!= XINE_IMGFMT_VIA) {
+    printf("libmpeg2: VMI: slice() called in wrong environment!\n");
+    return;
+  }
+*/
+  accel->last_slice_code = 0;
+  accel->current = accel->slice_buffer + 4;
+  // We store slice_count in the head of slice_buffer.
+  *(unsigned int *)accel->slice_buffer = 0;  // slice_count
+
+  accel->slice_received_count=0;
+  accel->decoded = 0;
+}
+
+void vmi_reset (mpeg2dec_t * mpeg2dec) {
+  
+ slice_vmi_reset (&mpeg2dec->accel);  // I don't think there is anything more to do.
+}
diff -ruN xine-lib-1.1.2-via/src/libmpeg2/slice_vmi.h xine-lib-1.1.2-my-2/src/libmpeg2/slice_vmi.h
--- xine-lib-1.1.2-via/src/libmpeg2/slice_vmi.h	1970-01-01 03:00:00.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/libmpeg2/slice_vmi.h	2006-10-19 01:30:30.000000000 +0300
@@ -0,0 +1,13 @@
+#ifndef _SLICE_VMI_H
+#define _SLICE_VMI_H
+#include "mpeg2.h"
+
+/* slice_vmi.c */
+void mpeg2_vmi_close(mpeg2dec_t * mpeg2dec);
+int mpeg2_vmi_init(mpeg2dec_t * mpeg2dec);
+void mpeg2_vmi_slice (mpeg2dec_accel_t* accel, picture_t * picture, int code, uint8_t * buffer, uint32_t chunk_size, uint8_t *chunk_buffer);
+void decode_vmi_frame (mpeg2dec_accel_t* accel, picture_t * picture);
+void slice_vmi_reset (mpeg2dec_accel_t* accel);
+void vmi_reset (mpeg2dec_t * mpeg2dec);
+
+#endif
diff -ruN xine-lib-1.1.2-via/src/video_out/Makefile.am xine-lib-1.1.2-my-2/src/video_out/Makefile.am
--- xine-lib-1.1.2-via/src/video_out/Makefile.am	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/video_out/Makefile.am	2006-10-18 21:43:55.000000000 +0300
@@ -78,6 +78,22 @@
 macosx_module = xineplug_vo_out_macosx.la
 endif
 
+vmi_module = xineplug_vo_out_vmi.la
+vmi_src = video_out_vmi.c
+if HAVE_X11
+vmi_lib = $(X_LIBS)
+endif
+
+#Horace Lan begin
+if HAVE_MV_LIB
+vmi_lnk = -L/usr/X11R6/lib -lddmpeg -lviamv \
+		-L/lib -lc -lpthread
+else
+vmi_lnk = -L/usr/X11R6/lib -lddmpeg \
+		-L/lib -lc -lpthread
+endif		
+#Horace Lan end
+
 lib_LTLIBRARIES = $(xshm_module) $(xv_module) $(xvmc_module) \
                   $(opengl_module) \
                   $(syncfb_module) \
@@ -91,6 +107,7 @@
                   $(caca_module) \
 		  $(macosx_module) \
 		  $(xxmc_module) \
+		  $(vmi_module) \
                   xineplug_vo_out_none.la
 
 xineplug_vo_out_xshm_la_SOURCES = yuv2rgb.c yuv2rgb_mmx.c yuv2rgb_mlib.c \
@@ -179,5 +196,28 @@
 xineplug_vo_out_macosx_la_LDFLAGS = -avoid-version -module @XINE_PLUGIN_MIN_SYMS@ \
 	-Wl,-framework -Wl,Cocoa -framework Cocoa -framework OpenGL
 
+	
+xineplug_vo_out_vmi_la_SOURCES = deinterlace.c video_out_vmi.c
+if HAVE_X11
+xineplug_vo_out_vmi_la_LIBADD = \
+	$(X_LIBS) \
+	$(XINE_LIB)
+else
+xineplug_vo_out_vmi_la_LIBADD = \
+	$(XINE_LIB)
+endif
+
+#Horace Lan begin
+if HAVE_MV_LIB
+xineplug_vo_out_vmi_la_LDFLAGS = -avoid-version -module @XINE_PLUGIN_MIN_SYMS@ \
+				    -L/usr/X11R6/lib -lddmpeg -lviamv \
+				    -L/lib -lc -lpthread
+else				    
+xineplug_vo_out_vmi_la_LDFLAGS = -avoid-version -module @XINE_PLUGIN_MIN_SYMS@ \
+				    -L/usr/X11R6/lib -lddmpeg \
+				    -L/lib -lc -lpthread
+endif				    
+#Horace Lan end
+
 noinst_HEADERS = deinterlace.h video_out_syncfb.h \
 	yuv2rgb.h x11osd.h
diff -ruN xine-lib-1.1.2-via/src/video_out/video_out_vmi.c xine-lib-1.1.2-my-2/src/video_out/video_out_vmi.c
--- xine-lib-1.1.2-via/src/video_out/video_out_vmi.c	1970-01-01 03:00:00.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/video_out/video_out_vmi.c	2006-10-18 21:43:55.000000000 +0300
@@ -0,0 +1,3966 @@
+/*
+ *    Copyright (c) 1998-2006 VIA Technologies, Inc.
+ *    Copyright (c) 2001-2006 S3 Graphics Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTIES OR REPRESENTATIONS; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+// ToDo: Improve memcpy, use the fast one, may need aligned buffer.
+// ToDo: Maybe blend directly in the overlay surface in frame buffer is faster?
+/* ToDo: Go toward 2XMPEG2@MPML, how to? 2 vo_driver instance? 
+ *         or 1 vo_driver instance with 2 context?
+ */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include <unistd.h>
+#include <sys/io.h>
+
+// ToDo: autoconfig checkings?
+#include <sys/mman.h>
+
+#if defined (__SVR4) && defined (__sun)
+# include <sys/int_types.h>
+#else
+# include <stdint.h>
+#endif
+
+#if defined(__FreeBSD__)
+#include <machine/param.h>
+#endif
+#include <sys/types.h>
+#include <sys/ipc.h>
+// We don't need this anymore? #include <sys/shm.h>
+#include <sys/time.h>
+
+// KGy CLE266_VO
+#ifdef HAVE_X11
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/cursorfont.h>
+#include <X11/extensions/XShm.h>
+#include <X11/extensions/Xv.h>
+#include <X11/extensions/Xvlib.h>
+#endif
+
+
+#define XINE_ENGINE_INTERNAL  //define this to access video_decoder_streamtype of xine_stream_t 
+
+// KGy CLE266_VO
+// FB related stuff.
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <linux/fb.h>
+
+#include "xine.h"
+#include "video_out.h"
+#include "xine_internal.h"
+#include "alphablend.h"
+#include "deinterlace.h"
+#include "xineutils.h"
+#include "vo_scale.h"
+
+// KGy CLE266_VO
+// CLE266 headers are placed in dir src/video_out/cle266.
+#include "viampg.h"
+#include "viavid.h"
+#include "viafb.h"
+
+// Horace Lan
+#ifdef HAVE_MV_LIB
+#include <viamv.h>
+#endif
+
+#include "accel_xvmc.h"
+
+//  #define LOG
+//if LOG is defined, all msg in lprintf() will be printed.
+
+
+// Surface number for CLE266 HWSlice acceleration.
+#define NUM_MPEG2_ACCEL_SURFS 8
+// Register entry name.
+#define REG_ENTRY_COLORKEY "video.cle266_colorkey"
+/*define screen number*/
+#define SDK_VID_PRI				1
+#define SDK_VID_SND				2
+
+
+typedef struct cle266_driver_s cle266_driver_t;
+
+typedef struct {
+  int                value;
+  int                min;
+  int                max;
+
+  cfg_entry_t       *entry;
+} cle266_property_t;
+
+
+// KGy CLE266_VO
+/* !Notice
+ * We depend on frame id created in video_out.c as mpeg2 surface index.
+ * That id mechanism must be OK, or we shall use our own index.
+ */
+typedef struct {
+  vo_frame_t         vo_frame;
+
+  /* There will be only one buffer allocated.
+   * base[0] is the start address of the buffer.
+   * base[1] and base [2] is always calculated for
+   *   yv12 planar from base[0].
+   */
+  /*Modify,DaveLiu,6/6/2006,this is memory base for frame base[3], 
+   for 64 bit OS we must align memory address to 16,so base []3 will be chuck[3]+offset ,
+   we must free chuck[3], or there will be memory leak*/  
+  char * chunk[3];
+  unsigned int buf_size;
+
+  vmi_accel_t vmi_accel_data;
+} cle266_frame_t;
+
+typedef enum environment_e {
+  NONE = 0,
+  X    = 1,
+  FB   = 2
+} environment_t;
+
+typedef struct {
+  unsigned int top,bottom,left,right;
+} rect;
+
+struct cle266_driver_s {
+
+  /* Standard stuf. */
+  vo_driver_t        vo_driver;
+  vo_overlay_t      *overlay;
+  config_values_t   *config;
+  xine_t            *xine;
+
+  /* Properties and capabilities and accelerators. */
+  cle266_property_t  props[VO_NUM_PROPERTIES];
+  uint32_t           capabilities;
+
+  /* Flag for environment type, XServer or FB. */
+  environment_t      working_env;
+
+  /* X11 related stuff. */
+#ifdef HAVE_X11
+  Display           *display;
+  int                screen;
+  Drawable           drawable;
+  GC                 gc;
+  XColor             black;
+#endif
+
+  /* FB related stuff. */
+  int video_on_snd;
+  int                      fd;  // FB device.
+  struct fb_var_screeninfo fb_var;
+  struct fb_fix_screeninfo fb_fix;
+
+  /*These two structure are private in viafb -Dave*/
+  struct viafb_ioctl_mode viafb_mode;
+  struct viafb_ioctl_samm viafb_samm;
+  unsigned int screen_depth;
+  // Screen size, no matter FB or X or anything.
+  unsigned int screen_width;
+  unsigned int screen_height;
+
+  /* All scaling information goes here. */
+  vo_scale_t         sc;
+  int                last_delivered_width;
+  int                last_delivered_height;
+  double             last_delivered_ratio;
+  int                delivered;
+  // Bool for check if we have got any frame. Set to 0 by memset in init.
+
+  /* All color key information goes here. */
+  uint32_t           colorkey;  // Actual color value for 16 or 24/32 bits, used to draw onto screen.
+  uint32_t           colorkey_high,colorkey_low;  // Color range for colorkey value, used to set device parameter.
+  uint32_t           keycolor;  // Color in ARGB to use as colorkey color, come from config.
+  uint32_t           color_precision;  // Half of the allowed color component error.
+
+  /* All deinterlacing information goes here. */
+  // The two members are not used currently.
+  cle266_frame_t        *recent_frames[VO_NUM_RECENT_FRAMES];
+  cle266_frame_t        *cur_frame;
+  // I don't think this is good, the frame may have been freed when using this pointer.
+  cle266_frame_t     deinterlace_frame;
+  int                deinterlace_method;
+  int                deinterlace_enabled;
+
+  /* Device related stuff. */
+
+  // Pointer to VMI info, for all VMI_DriverProc operations.
+  LPVMI_INFO_PARAM   p_vmi_info;  // ToDo: validity checking?
+  unsigned long      video_capability;
+
+  /* Lock between vo_thread and vd_thread, access to config_FourCC in
+   *   update_frame_format() and display_frame(): never do any operation
+   *   that is not available under this config. And slice_receive_data()
+   *   runs in vd_thread, no need of locking.
+   * This lock protects the config_FourCC flag and surfaces in frame buffer.
+   * The config_FourCC flag shall be modified only bu update_frame_format().
+   *   It shall lock whenever modify the flag and/or surfaces but don't have to
+   *   lock on testing the flag, since it won't be changed by other.
+   * Other worker functions shall lock first then check then do the job then unlock.
+   * => Now update_overlay code has been changed, UI thread, decoder thread and
+   *   VO thread will all do this, so this lock is also used to protect USECOLROKEY
+   *   and OUTPUTENABLED property, the overlay status shadow structure and the 
+   *   device.
+   * For functions like clean_output_area() that wants both config_lock and 
+   *   display lock (call XLockDisplay()), it must first get config_lock
+   *   then go on lock display. Or there will be dead lock.
+   */
+  pthread_mutex_t    config_lock;
+  /* FourCC flag for current config type.
+   * This may be YUV2,YV12,VIA or "\0\0\0\0", 0 means no surfaces created.
+   */
+  uint32_t           config_FourCC;
+  /* When we destroy old surface and allocate new surface in update_frame_format(),
+   *   we hide output until something valid for display arrives.
+   * Protected by config_lock.
+   */
+  int                waitting_for_video_img;
+
+  /* Description of current surface set in frame buffer.
+   * All surfaces, overlay, MPEG2&SubP will use this to describe the size.
+   * Actual image may be smaller than this.
+   */
+  unsigned long      surf_width,surf_height;
+  // MMap pointers and pitches.
+  uint8_t           *subp_surf;
+  uint32_t           subp_pitch;
+  uint8_t           *overlay_surf[2][3];
+  uint32_t           overlay_pitches[3];
+  uint8_t           *alpha_surf;
+  uint32_t           alpha_pitch;  // This is got from driver, for draw alpha image.
+  uint32_t           alpha_width;  // Width and height is used to set alpha window.
+  uint32_t           alpha_height;  // Height is also used to draw alpha image.
+  int                use_NV12_for_YV12;  // CN400 only supports NV12.
+  /* NV12 is easy to convert to YV12 format, but now our decoder only
+   *   knows to write into YV12. So we will provide a YV12 buffer in
+   *   system memory for decoder to write in and we convert the format
+   *   at display time, after software alpha blending for subpicture.
+   * This flag is derived from MPEG4_IDCT capability. Better querying
+   *   support from driver is needed. When it is available, we will
+   *   use the capability flag instead of this one.
+   * Due to lack of document on NV12 surface locking, currently
+   *   YUY2 will be used for YV12 frame. config_FourCC will always
+   *   be the same as the surface format, and config matching test
+   *   will be modified.
+   * When possible NV12 is prefered because of less data copying.
+   */
+
+  /* Plain overlay surface index - which surface to draw in. Inited to 0 by memset, can be 0 or 1. */
+  unsigned long      cur_overlay_surf;
+
+  // Flags for alpha blending enable/disable, used to set_alphawin.
+  int                const_alpha_enable;
+  int                surf_alpha_enable;
+  // We have to store const alpha value here.
+  unsigned char      const_alpha;
+
+  /* Subpicture related stuff. */
+  int                have_subp;             // There are something actually exist, we shall display.
+  int                subp_data_empty;       // No subp data, if the blend() get called, we will build the subp data.
+  int                subp_on;               // Subpicture on/off status, we don't have to send command if status is not changed.
+  int                OSD_pixel_changed;     // Palette changes caused OSD pixel value change, need to redraw OSD.
+  unsigned char      OSD_pixel;             // Selected color index along with 0xF alpha value, opaque OSD.
+  rect               subp_list[100];        // Let's make it fast and clean. All drawn subpicture will be registered here for clean up.
+  int                cur_rect_entry;        // Current subp_list entry to be written in. 99 is believed to be enough, cur_rect_entry = 0 means no entry.
+  unsigned int       palette[16];
+  int                palette_changed;
+  // size, base, pitch, format makes a vo_frame's data buffer here, for blending.
+  // This blending buffer is always used when blending is done. Buffer format will always match with current config.
+  unsigned int       blend_buf_size;
+  /*Modify,DaveLiu,6/6/2006,this is memory base for blend_buffer_base[3],    for 64 bit OS
+  we must align memory address to 16,so blend_buffer_base [3] will be chuck[3]+offset ,
+   we must free chuck[3], or there will be memory leak*/  
+  uint8_t           *chunk[3];
+  uint8_t           *blend_buf_base[3];     // [0] is the allocated buffer.
+  int                blend_buf_pitches[3];
+  int                blended;               // Shall use the blended buffer to display, also means no error during blending process.
+  // Note things are memset to 0 on open plugin.
+
+  /* Update overlay parameters. */
+  /* Update overlay is a very slow operation due to waitting for device.
+   * This operation shall be carried out only when necessary,
+   *   this is the same structure used to call driver, this one will shadow
+   *   current overlay status.
+   */
+  DDUPDATEOVERLAY    overlay_status;
+
+  /* Macrovision support related stuff.
+   * Some thing in property set is also used for macrovision.
+   */
+  MACROVISIONINFO    macrovision_info;
+
+  int used_accel_buffers;
+  alphablend_t       alphablend_extra_data;
+  /*Joyce 20051107, in video_out_loop, there is check_redraw_needed operation, but colorkey 
+  won't update at that time. so use the flag the keep the update info and update colorkey when  displaying frame*/
+  int redraw_needed; 
+};
+
+// For compatibilty with different visual_ts, we need to know which type it is.
+typedef enum {
+  via,xine_fb,xine_x11
+} visd_type;
+
+typedef struct {
+  video_driver_class_t driver_class;
+
+  // Used by open_plugin to know how to use input "visual".
+  visd_type             visual_data_type;
+
+  // Used to check if we are in correct env by open_plugin().
+  environment_t        init_env;
+
+  // VMI info is needed by all VMI_DriverProc operations.
+  VMI_INFO_PARAM     vmi_info;        /* General info structure for VMI 2.0 */
+
+  config_values_t     *config;
+  xine_t              *xine;
+} cle266_class_t;
+
+//==============================================================================================
+// Prototypes.
+
+static int cle266_redraw_needed (vo_driver_t *this_gen);
+
+//==============================================================================================
+// Utility.
+
+static int get_fb_var_screeninfo(int fd, struct fb_var_screeninfo *var)
+{
+  
+  if(ioctl(fd, FBIOGET_VSCREENINFO, var))
+    {
+      lprintf("video_out_cle266: ioctl FBIOGET_VSCREENINFO");
+      return 0;
+    }
+
+ //To do, all below in this function should make no sense.
+  var->xres_virtual = var->xres;
+  var->xoffset      = 0;
+  var->yoffset      = 0;
+  var->nonstd       = 0;
+  var->vmode       &= ~FB_VMODE_YWRAP;
+
+  /* Get proper value for maximized var->yres_virtual. */
+  if(ioctl(fd, FBIOGET_VSCREENINFO, var) == -1)
+    {
+      lprintf("video_out_cle266: ioctl FBIOGET_VSCREENINFO");
+      return 0;
+    }
+
+  return 1;
+}
+
+static int get_fb_fix_screeninfo(int fd, struct fb_fix_screeninfo *fix)
+{
+  if(ioctl(fd, FBIOGET_FSCREENINFO, fix))
+    {
+      lprintf("video_out_cle266: ioctl FBIOGET_FSCREENINFO");
+      return 0;
+    }
+  return 1;
+}
+
+
+/* Check if required format matches current config.
+ * Return: TRUE if match, FALSE if don't match.
+ * Must be called with the config_lock in hand.
+ * And this must be valid.
+ */
+int cle266_check_format_match(cle266_driver_t *this,
+			      uint32_t format) {
+  return
+    this->use_NV12_for_YV12 ?
+    ((format != XINE_IMGFMT_YV12 && format == this->config_FourCC) ||
+     (format == XINE_IMGFMT_YV12 && this->config_FourCC == XINE_IMGFMT_YUY2)) :
+    format == this->config_FourCC;
+}
+
+// The two functions only change value of mapped address and pitches in cle266_driver.
+
+/* Create and first lock then map surface into our address space.
+ * Supports YUY2,YV12 for video overlay and SUBP for sub-picture.
+ * Overlay will use double buffer and sub-picture will use single buffer.
+ * The mapped address will be put into cle266_driver NULL when fail.
+ * Returns 0 when succeed, none-zero when fail.
+ */
+int cle266_create_and_lock_surface(cle266_driver_t *this,
+				   uint32_t format,  // FourCC
+				   unsigned int width,
+				   unsigned int height) {
+
+  DDSURFACEDESC SurfaceDesc;
+  DDLOCK        lock;
+  uint32_t      ret = 0;
+
+  if (format != FOURCC_SUBP      &&
+      format != FOURCC_ALPHA     &&
+      format != XINE_IMGFMT_YUY2 &&
+      format != XINE_IMGFMT_YV12 &&
+      format != FOURCC_NV12)
+    return 1;  // Wrong format.
+
+  xprintf(this->xine,XINE_VERBOSITY_INFO,"create and map surface: format %x, width: %d, height: %d.\n",
+	   format,width,height);
+
+  SurfaceDesc.dwWidth              = width;
+  SurfaceDesc.dwHeight             = height;
+  SurfaceDesc.dwBackBufferCount    = 1;  // Double buffer for overlay, 1 back buffer for subp.
+  SurfaceDesc.dwFourCC             = format;
+  ret = VMI_DriverProc(this->p_vmi_info,CREATESURFACE, (void *)&SurfaceDesc,NULL);
+  if (ret != VMI_OK) {
+    xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: create_and_lock_surface : failed to create the %x surface.\n",format);
+    return 2;
+  }
+
+  lock.dwFourCC = format;
+  ret = VMI_DriverProc(this->p_vmi_info,LOCKSURFACE,(unsigned long *)&lock,NULL);
+  if (ret != VMI_OK) {
+    xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: failed to lock the %x surface.\n",format);
+    VMI_DriverProc(this->p_vmi_info,DESTROYSURFACE,(unsigned long *)&SurfaceDesc,NULL);
+    return 1;
+  }
+
+  switch (format) {
+  case XINE_IMGFMT_YV12:
+    {
+      int i;
+      for (i=0;i<2;i++) {
+	this->overlay_surf[i][0] = lock.SWDevice.lpSWOverlaySurface[i];
+	this->overlay_surf[i][1] = lock.SWDevice.lpSWOverlaySurface[i] + lock.SWDevice.dwSWCbPhysicalAddr[i] - lock.SWDevice.dwSWPhysicalAddr[i];
+	this->overlay_surf[i][2] = lock.SWDevice.lpSWOverlaySurface[i] + lock.SWDevice.dwSWCrPhysicalAddr[i] - lock.SWDevice.dwSWPhysicalAddr[i];
+      }
+      this->overlay_pitches[0] = lock.SWDevice.dwPitch;
+      this->overlay_pitches[1] = this->overlay_pitches[2] = lock.SWDevice.dwPitch /2;  // What if dwPitch is odd?
+    }
+    break;
+  case XINE_IMGFMT_YUY2:
+    {
+      int i;
+      for (i=0;i<2;i++) {
+	this->overlay_surf[i][0] = lock.SWDevice.lpSWOverlaySurface[i];
+	this->overlay_surf[i][1] = this->overlay_surf[i][2] = NULL;
+      }
+      this->overlay_pitches[0] = lock.SWDevice.dwPitch;
+      this->overlay_pitches[1] = this->overlay_pitches[2] = 0;
+    }
+    break;
+  case FOURCC_SUBP:
+    this->subp_surf = lock.SubDev[((int)this->p_vmi_info->handle)&1].lpSUBOverlaySurface[0];//zhaolin:
+    this->subp_pitch = lock.SubDev[((int)this->p_vmi_info->handle)&1].dwPitch;
+    if (this->subp_surf && this->subp_pitch) {  // Do the initial cleaning.
+      int y;
+      for (y=0;y<this->surf_height;y++)
+	memset((void *)((unsigned long)this->subp_surf + this->subp_pitch * y),
+	       0,this->surf_width);
+    }
+    break;
+  case FOURCC_ALPHA:
+    this->alpha_surf   = lock.ALPDevice.lpALPOverlaySurface;
+    this->alpha_pitch  = lock.ALPDevice.dwPitch;
+    //this->alpha_width  = lock.ALPDevice.;
+    //this->alpha_height = lock.ALPDevice.;
+    // ToDo: init alpha surface to a value??
+    break;
+  case FOURCC_NV12:
+    /* Don't know how to use this yet.
+       
+    */
+    break;
+  }
+
+  return 0;
+}
+
+// ToDo: May fail, but don't know what to do on fail, so no return value currently.
+void cle266_unmap_and_destroy_surface(cle266_driver_t *this,
+				      uint32_t format) {
+
+  DDSURFACEDESC SurfaceDesc;
+  uint32_t      ret = 0;
+
+  if (format != FOURCC_SUBP      &&
+      format != FOURCC_ALPHA     &&
+      format != XINE_IMGFMT_YUY2 &&
+      format != XINE_IMGFMT_YV12 &&
+      format != XINE_IMGFMT_VIA)  // We also deal with MPEG2 surface for simple coding.
+    return;  // Wrong format.
+
+  SurfaceDesc.dwFourCC = format;
+  ret = VMI_DriverProc(this->p_vmi_info,DESTROYSURFACE,(unsigned long *)&SurfaceDesc,NULL);
+  if (ret != VMI_OK) {
+     xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: failed to destroy %x surface.\n",format);
+    return;
+  }
+
+  // Reset pointers, mmap of frame buffer is always kept there.
+  switch (format) {
+  case XINE_IMGFMT_YV12:
+  case XINE_IMGFMT_YUY2:
+    {
+      int i;
+      for (i=0;i<2;i++) {
+	this->overlay_surf[i][0] = this->overlay_surf[i][1] = this->overlay_surf[i][2] = NULL;
+      }
+      this->overlay_pitches[0] = this->overlay_pitches[1] = this->overlay_pitches[2] = 0;
+    }
+    break;
+  case FOURCC_SUBP:
+    this->subp_surf = NULL;
+    this->subp_pitch = 0;
+    break;
+  case FOURCC_ALPHA:
+    this->alpha_surf   = 0;
+    this->alpha_pitch  = 0;
+    //this->alpha_width  = lock.ALPDevice.;
+    //this->alpha_height = lock.ALPDevice.;
+    break;
+  case XINE_IMGFMT_VIA:
+    break;  // Nothing to do.
+  }
+
+  return;
+}
+
+// Pair of functions to register subpicture rectangles and do the clean up.
+// Return 1 if the rect list is full, register failed.
+int cle266_register_subp_rectangle(cle266_driver_t *this,
+				   unsigned int top,
+				   unsigned int bottom,
+				   unsigned int left,
+				   unsigned int right) {
+
+  if (!this)
+    return 2;
+
+  // We don't check rect validity.
+
+  if (this->cur_rect_entry < 99) {
+
+    // Entry 0 is for total rectangle.
+    this->cur_rect_entry++;
+
+    // Register the rectangle.
+    this->subp_list[this->cur_rect_entry].top    = top;
+    this->subp_list[this->cur_rect_entry].bottom = bottom;
+    this->subp_list[this->cur_rect_entry].left   = left;
+    this->subp_list[this->cur_rect_entry].right  = right;
+
+    // Compare and set if larger, we will get the so called total rectangle.
+    if (this->subp_list[0].top    > top)    this->subp_list[0].top    = top;
+    if (this->subp_list[0].bottom < bottom) this->subp_list[0].bottom = bottom;
+    if (this->subp_list[0].left   > left)   this->subp_list[0].left   = left;
+    if (this->subp_list[0].right  < right)  this->subp_list[0].right  = right;
+
+    return 0;
+  } else
+    return 1;
+}
+
+// Clean up according to registered rectangles.
+void cle266_clean_subp_surface(cle266_driver_t *this) {
+  if (!this)
+    return;
+
+  // Hope this is faster than the init clean method ...
+
+  if (this->subp_surf && this->subp_pitch) {
+    while (this->cur_rect_entry) {
+
+      if ((this->subp_list[this->cur_rect_entry].top  <=
+	   this->subp_list[this->cur_rect_entry].bottom) &&
+	  (this->subp_list[this->cur_rect_entry].left <=
+	   this->subp_list[this->cur_rect_entry].right)) {
+
+	unsigned int clean_height,clean_width;  // Actual line/colum count.
+	int y;
+
+	clean_height = this->subp_list[this->cur_rect_entry].bottom > (this->surf_height - 1) ?
+	  this->surf_height - this->subp_list[this->cur_rect_entry].top:
+	  this->subp_list[this->cur_rect_entry].bottom - this->subp_list[this->cur_rect_entry].top + 1 ;
+
+	clean_width = this->subp_list[this->cur_rect_entry].right > (this->surf_width - 1) ?
+	  this->surf_width - this->subp_list[this->cur_rect_entry].left:
+	  this->subp_list[this->cur_rect_entry].right - this->subp_list[this->cur_rect_entry].left + 1 ;
+
+	for (y = this->subp_list[this->cur_rect_entry].top;
+	     y < this->subp_list[this->cur_rect_entry].top + clean_height;
+	     y++)
+	  memset((void *)((unsigned long)this->subp_surf + this->subp_pitch * y + this->subp_list[this->cur_rect_entry].left),
+		 0,clean_width);
+      }
+
+      this->cur_rect_entry--;
+    }
+  }
+
+  // Then reset the total rectangle.
+  this->subp_list[0].top    = 0;
+  this->subp_list[0].bottom = 0;
+  this->subp_list[0].left   = 0;
+  this->subp_list[0].right  = 0;
+
+  return;
+}
+
+void cle266_draw_ia44 (cle266_driver_t* this, vo_overlay_t* overlay) {
+
+  int  src_width  = overlay->width;
+  int  src_height = overlay->height;
+  rle_elem_t *rle        = overlay->rle;
+  rle_elem_t *rle_limit  = rle + overlay->num_rle;
+  int x_off       = overlay->x;
+  int y_off       = overlay->y;
+  int mask;
+  int x, y;
+  int clip_right;
+  
+  uint8_t *dst_y = this->subp_surf + this->subp_pitch  * y_off + x_off;
+  uint8_t *dst;
+  /*joyce 20060509, for hw osd palette entry number limitation, we let  hw osd only support 
+  no border text. thus each color text only needs one foreground color. the trans has effect on
+  osd quality, stolen from xine's original white no border trans  */
+ static uint8_t textpalette_noborder_trans[XINE_TEXT_PALETTE_SIZE] =  {0, 0, 0, 0, 0, 0, 2, 6, 9, 12, 15 };
+int trans_idx;
+  if (!this || !overlay)
+    return;
+
+  if (!this->subp_surf || !this->subp_pitch)
+    return;
+
+  /* avoid wraping overlay if drawing to small image */
+  if( (x_off + overlay->width) < this->surf_width )
+    clip_right = overlay->width;
+  else
+    clip_right = this->surf_width - 1 - x_off;
+
+  /* avoid buffer overflow */
+  if( (src_height + y_off) >= this->surf_height )
+    src_height = this->surf_height - 1 - y_off;
+
+  for (y = 0; y < src_height; y++) {
+    mask = !(overlay->hili_top > y || overlay->hili_bottom < y);
+
+    dst = dst_y;
+    for (x = 0; x < src_width;) {
+
+      // One rle_element one time.
+
+      int len = x + rle->len > clip_right ? clip_right - x + 1 : rle->len;
+
+      if (len > 0) {
+	uint8_t norm_pixel,clip_pixel;
+	if (overlay->osd_overlay) {  // FixMe: this pixel building depemds on RLE content and may change the pciture.
+	    
+/*joyce 20060509. tip  from xine's original white no border p, map xine's original 11 text color index to just one foregound  color */
+	    trans_idx = (rle->color)%XINE_TEXT_PALETTE_SIZE;
+	    if((rle->color)%XINE_TEXT_PALETTE_SIZE ==0)
+	        rle->color = 0;
+	   else 
+	        rle->color = (rle->color)/XINE_TEXT_PALETTE_SIZE+1;
+	       
+	  norm_pixel = (uint8_t)(((rle->color & 0x07) | 0x08) | (textpalette_noborder_trans[trans_idx] << 4));
+	 
+	    clip_pixel = norm_pixel;
+	} else {
+	  norm_pixel = (uint8_t)((rle->color & 0x03) | ((overlay->trans[rle->color] & 0x0F) << 4));
+	  clip_pixel = (uint8_t)(((rle->color & 0x03) | 0x04) | ((overlay->hili_trans[rle->color] & 0x0F) << 4));
+	}
+	if (mask) {
+	  if (x < overlay->hili_left) {
+	    if (x + len - 1 < overlay->hili_left) {
+	      memset(dst,norm_pixel,len);
+	      dst += len;
+	    } else {
+	      memset(dst,norm_pixel,overlay->hili_left -x);
+	      dst += overlay->hili_left - x;
+	      len -= overlay->hili_left - x;
+	      if (len < overlay->hili_right - overlay->hili_left + 1) {
+		memset(dst,clip_pixel,len);
+		dst += len;
+	      } else {
+		memset(dst,clip_pixel,overlay->hili_right - overlay->hili_left +1);
+		dst += overlay->hili_right - overlay->hili_left +1;
+		len -= overlay->hili_right - overlay->hili_left +1;
+		memset(dst,norm_pixel,len);
+		dst += len;
+	      }
+	    }
+	  } else if (x <= overlay->hili_right) {  // Assume right > left.
+	    if (len < overlay->hili_right - x + 1) {
+	      memset(dst,clip_pixel,len);
+	      dst += len;
+	    } else {
+	      memset(dst,clip_pixel,overlay->hili_right - x +1);
+	      dst += overlay->hili_right - x +1;
+	      len -= overlay->hili_right - x +1;
+	      memset(dst,norm_pixel,len);
+	      dst += len;
+	    }
+	  } else {
+	    memset(dst,norm_pixel,len);
+	    dst += len;
+	  }
+	} else {
+	  memset(dst,norm_pixel,len);
+	  dst += len;
+	}
+      }
+      // Finished drawing the rle_element.
+
+      x += rle->len;
+      rle++;
+      if (rle >= rle_limit) break;
+    }  // for (x = 0; x < src_width;)
+    if (rle >= rle_limit) break;
+
+    dst_y += this->subp_pitch;
+  }
+}
+
+/* Draw screen content for black background with/without colorkey.
+ * ToDo: maybe we can draw 3 rectangles to make the drawing faster, this
+ *   may be better than draw a large background and then draw a small color
+ *   key rectangle on the drawn background.
+ * ???This function shall always be called with the this->config_lock locked.
+ */
+static void cle266_clean_output_area (cle266_driver_t *this) {
+
+  int draw_colorkey =
+    this->props[VO_PROP_OUTPUTENABLED].value &&
+    !this->waitting_for_video_img &&
+    this->props[VO_PROP_USECOLORKEY].value;
+
+  switch (this->working_env) {
+  case X:
+    {
+    	
+#ifdef HAVE_X11
+      XLockDisplay (this->display);
+     
+      XSetForeground (this->display, this->gc, this->black.pixel);
+      
+      XFillRectangle(this->display, this->drawable, this->gc,
+		     this->sc.gui_x, this->sc.gui_y, this->sc.gui_width, this->sc.gui_height);
+
+      if (draw_colorkey) {
+	XSetForeground (this->display, this->gc, this->props[VO_PROP_COLORKEY ].value);
+	XFillRectangle (this->display, this->drawable, this->gc,
+			this->sc.output_xoffset, this->sc.output_yoffset,
+			this->sc.output_width, this->sc.output_height);
+      }
+
+      XUnlockDisplay (this->display);
+#endif
+
+    }
+    break;
+  case FB:
+    /* Draw the output area to black.
+     * This requires the tty to be set to graphic mode to avoid characters printed on screen.
+     */
+    // ToDo: When to do this? How to deal with variable FB?
+    {
+    }
+    break;
+  case NONE:
+     xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: clean output area: wrong working envrionment.\n");
+  }
+}
+
+/* When calling this function, the config_lock must be held by the caller.
+ * onoff: if (OUTPUTENABLED && onoff == TRUE) overlay is turned on, and the
+ *   overlay can be turned off even if the output is enabled. If the overlay
+ *   is on but OUTPUTENABLED == FALSE, the overlay will always be turned off.
+ */
+static void cle266_update_overlay(cle266_driver_t *this) {
+
+  int do_the_op= 0;  // Shall really send command to driver.
+  static DDUPDATEOVERLAY  UpdateOverlay;
+  uint32_t  ret;
+
+  if (!this) {
+    lprintf("vo_driver_cle266: cle266_update_overlay: no instance.\n");
+    return;
+  }
+  
+  memset(&UpdateOverlay,0,sizeof(DDUPDATEOVERLAY));
+
+  // ToDo: clean up all code related to color key value, use property, config and generator function.
+  // ToDo: check if it's OK to call this function before any frame delivered. Check sc values.
+
+  if (!this->waitting_for_video_img &&
+      this->props[VO_PROP_OUTPUTENABLED].value) {  // Turn on.
+
+    lprintf("vo_driver_cle266: update overlay. source: top: %d, left: %d, width: %d, height: %d, target: top: %d, left: %d, width: %d, height: %d, window: (%d,%d).\n",
+	   this->sc.displayed_xoffset, this->sc.displayed_yoffset,
+	   this->sc.displayed_width, this->sc.displayed_height,
+	   this->sc.output_xoffset, this->sc.output_yoffset,
+	   this->sc.output_width, this->sc.output_height,
+	   this->sc.gui_win_x,this->sc.gui_win_y);
+
+    UpdateOverlay.rDest.left   = this->sc.output_xoffset + this->sc.gui_win_x;
+    UpdateOverlay.rDest.top    = this->sc.output_yoffset + this->sc.gui_win_y;
+    UpdateOverlay.rDest.right  = this->sc.output_xoffset + this->sc.gui_win_x + this->sc.output_width;
+    UpdateOverlay.rDest.bottom = this->sc.output_yoffset + this->sc.gui_win_y + this->sc.output_height;
+    
+    UpdateOverlay.rSrc.left    = 0; // Hw seems to have bug for non-zero value. this->sc.displayed_xoffset;
+    UpdateOverlay.rSrc.top     = 0; // this->sc.displayed_yoffset;
+    // Use frame->width,height may be better?
+    UpdateOverlay.rSrc.right   = this->last_delivered_width;  //this->sc.displayed_xoffset + this->sc.displayed_width;
+    UpdateOverlay.rSrc.bottom  = this->last_delivered_height; //this->sc.displayed_yoffset + this->sc.displayed_height;
+
+    UpdateOverlay.dwFourcc = this->config_FourCC;    
+    
+    if (this->props[VO_PROP_USECOLORKEY].value) {
+      UpdateOverlay.dwFlags = DDOVER_SHOW | DDOVER_KEYDEST;
+      UpdateOverlay.dwColorSpaceLowValue  = this->props[VO_PROP_COLORKEY ].value; //this->colorkey_low;
+      //UpdateOverlay.dwColorSpaceHighValue = this->colorkey_high;
+    } else {
+      UpdateOverlay.dwFlags = DDOVER_SHOW;
+      if(this->sc.output_on_snd)
+      	UpdateOverlay.dwFlags|=DDOVER_ON_SND;
+
+    }
+
+    if (UpdateOverlay.rDest.left   != this->overlay_status.rDest.left   ||
+	UpdateOverlay.rDest.top    != this->overlay_status.rDest.top    ||
+	UpdateOverlay.rDest.right  != this->overlay_status.rDest.right  ||
+	UpdateOverlay.rDest.bottom != this->overlay_status.rDest.bottom ||
+	UpdateOverlay.rSrc.left    != this->overlay_status.rSrc.left    ||
+	UpdateOverlay.rSrc.top     != this->overlay_status.rSrc.top     ||
+	UpdateOverlay.rSrc.right   != this->overlay_status.rSrc.right   ||
+	UpdateOverlay.rSrc.bottom  != this->overlay_status.rSrc.bottom  ||
+	UpdateOverlay.dwFourcc     != this->overlay_status.dwFourcc     ||
+	UpdateOverlay.dwFlags      != this->overlay_status.dwFlags      ||
+	UpdateOverlay.dwColorSpaceLowValue != this->overlay_status.dwColorSpaceLowValue) {
+      do_the_op = 1;
+    }
+  } else if (this->overlay_status.dwFlags != DDOVER_HIDE &&
+	     this->config_FourCC) {
+    /* The result from experiment is that the dwFourcc is mandatory or
+     *   we can't hide the overlay. this->config_FourCC is 0 when just
+     *   initialized.
+     */
+    UpdateOverlay.dwFlags = DDOVER_HIDE;
+    UpdateOverlay.dwFourcc = this->config_FourCC;
+    do_the_op = 1;
+  }
+
+  if (do_the_op) {
+
+    ret = VMI_DriverProc(this->p_vmi_info,UPDATEOVERLAY, (unsigned long *)&UpdateOverlay,NULL);
+    if (ret != VMI_OK) {
+       xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: cle266_update_overlay: Failed.\n");
+    } else {  // Update overlay done, update the status record.
+      this->overlay_status.rDest.left   = UpdateOverlay.rDest.left;
+      this->overlay_status.rDest.top    = UpdateOverlay.rDest.top;
+      this->overlay_status.rDest.right  = UpdateOverlay.rDest.right;
+      this->overlay_status.rDest.bottom = UpdateOverlay.rDest.bottom;
+      this->overlay_status.rSrc.left    = UpdateOverlay.rSrc.left;
+      this->overlay_status.rSrc.top     = UpdateOverlay.rSrc.top;
+      this->overlay_status.rSrc.right   = UpdateOverlay.rSrc.right;
+      this->overlay_status.rSrc.bottom  = UpdateOverlay.rSrc.bottom;
+      this->overlay_status.dwFourcc     = UpdateOverlay.dwFourcc;
+      this->overlay_status.dwFlags      = UpdateOverlay.dwFlags;
+      this->overlay_status.dwColorSpaceLowValue = UpdateOverlay.dwColorSpaceLowValue;
+    }
+  }
+}
+
+
+static void begin_frame(vo_frame_t  *cur_frame_gen){
+
+  cle266_frame_t  *cur_frame = (cle266_frame_t *)cur_frame_gen;
+
+   if((!cur_frame)	||(!cur_frame->vmi_accel_data.p_vmi_info) ){
+   	lprintf("video_out_cle266::begin_frame, error parameters.\n");
+		return;
+    }		
+
+   VMI_DriverProc(cur_frame->vmi_accel_data.p_vmi_info,BEGINFRAME,(void *)(&cur_frame->vmi_accel_data.mpg_accel_param), NULL);
+
+}
+
+static void render_frame(vo_frame_t  *cur_frame_gen,void *decode_data) {
+    cle266_frame_t  *cur_frame = (cle266_frame_t *)cur_frame_gen;
+
+    if((!cur_frame)	||(!cur_frame->vmi_accel_data.p_vmi_info) || (!decode_data)){
+		lprintf("video_out_cle266::render_frame, error parameters.\n");
+		return;
+    }		
+    VMI_DriverProc(cur_frame->vmi_accel_data.p_vmi_info,RENDERFRAME,decode_data,NULL);
+
+}
+
+//==============================================================================================
+// Alphablender
+
+static int cle266_get_screen_info(via_alphablending_interface_t *this,
+				  unsigned int *width,unsigned int *height) {
+  cle266_driver_t *driver = NULL;
+
+  if (this)
+    if (this->base_interface.vo_port)
+      if (this->base_interface.vo_port->driver) {
+	driver = (cle266_driver_t *)this->base_interface.vo_port->driver;
+
+	*width  = driver->screen_width;
+	*height = driver->screen_height;
+
+	if (driver->working_env == FB)
+	  return driver->fd;
+	else
+	  return -1;
+      }
+
+  *width  = 0;
+  *height = 0;
+
+  return -1;
+}
+
+static  int cle266_get_alpha(via_alphablending_interface_t *this,
+                         unsigned int width,unsigned int height,unsigned int top,  unsigned int left,char *alpha_buf){
+
+cle266_driver_t *driver = NULL;
+
+  if (this)
+    if (this->base_interface.vo_port)
+      if (this->base_interface.vo_port->driver) {
+		driver = (cle266_driver_t *)this->base_interface.vo_port->driver;
+		unsigned int valid_left,valid_width;
+		int x,y;
+		char linebuf[800];
+		if (top  >= driver->alpha_height ||left >= driver->alpha_width ||
+			(top+height)>= driver->alpha_height ||(left+width) >= driver->alpha_width) {
+			 xprintf(driver->xine,XINE_VERBOSITY_INFO,"cle266_draw_alpha: draw area out of valid range.\n");
+	  		return -1;
+		}
+		if (driver->video_capability & HW_VID_ALPHA256) {
+	  		for (y = 0; y < height; y++) {
+	    			memcpy(alpha_buf+width*y,driver->alpha_surf + ((driver->alpha_pitch * (top + y)) +left),width);
+	  		}
+		} else {
+			int flag_left,flag_width;
+			int cur_byte;
+			unsigned char mask;
+			flag_left=left&0x1;
+			flag_width=width&0x1;
+			valid_left=flag_left?((left-1)/2):(left/2);
+			valid_width=(flag_width)?((width+1)/2):(flag_left)?(width/2+1):(width/2);//
+			for(y=0;y<height;y++){
+				cur_byte=0;
+				memcpy(linebuf,driver->alpha_surf + ((driver->alpha_pitch * (top + y)) +valid_left),valid_width);
+				mask=flag_left?0xF0:0xF;
+				for(x=0;x<width;x++){
+					alpha_buf[width* y+x]=(mask==0xF)?((linebuf[cur_byte]&mask)<<4):((linebuf[cur_byte]&mask));
+					if(mask==0xF0) cur_byte++;
+					mask=~mask;
+				}
+				
+			}
+		}
+	return 0;
+      	}
+      return -1;
+}
+
+/* Utility function, must be called with the config lock in hand
+ *   and *this is believed to be valid and the device shall
+ *   be capable of alpha.
+ */
+static unsigned int cle266_set_alphawin(cle266_driver_t *this) {
+  ALPHACTRL alpha_ctrl;
+  
+  alpha_ctrl.AlphaEnable = 1;
+
+  if (this->const_alpha_enable && this->surf_alpha_enable)
+    alpha_ctrl.type = ALPHA_COMBINE;
+  else if (this->const_alpha_enable  && !this->surf_alpha_enable)
+    alpha_ctrl.type = ALPHA_CONSTANT;
+  else if (!this->const_alpha_enable && this->surf_alpha_enable)
+    alpha_ctrl.type = ALPHA_STREAM;
+  else if (!this->const_alpha_enable && !this->surf_alpha_enable)
+    alpha_ctrl.type = ALPHA_DISABLE;
+
+  // ToDo: better logic?
+  alpha_ctrl.ConstantFactor =
+    this->video_capability & HW_VID_ALPHA16 ?
+    (unsigned char)(this->const_alpha & 0xf0) >> 4 :
+    (unsigned char)(this->const_alpha & 0xff);
+    
+  return VMI_DriverProc(this->p_vmi_info,SETALPHAWIN,(void *)&alpha_ctrl,NULL);
+}
+
+static int cle266_set_const_alpha_internal(cle266_driver_t *this,
+					   unsigned char alpha, int enable) {
+  if (this)
+    if (this->video_capability & (HW_VID_ALPHA16 | HW_VID_ALPHA256)) {
+      unsigned long ret;
+
+      pthread_mutex_lock(&this->config_lock);
+
+      this->const_alpha_enable = enable;
+      this->const_alpha = alpha;
+
+      ret = cle266_set_alphawin(this);
+
+      pthread_mutex_unlock(&this->config_lock);
+
+      if (ret == VMI_OK) {
+	 xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: set_const_alpha: enable: %d, alpha: %d.\n",
+		 enable,alpha);
+	return 0;
+      } else {
+	 xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: set_const_alpha: failed. enable: %d, alpha: %d.\n",
+		 enable,alpha);
+	return -1;
+      }
+    }
+
+  return -1;
+}
+
+static int cle266_set_const_alpha(via_alphablending_interface_t *this,
+				  unsigned char alpha, int enable) {
+  cle266_driver_t *driver = NULL;
+
+  if (this)
+    if (this->base_interface.vo_port)
+      if (this->base_interface.vo_port->driver) {
+	driver = (cle266_driver_t *)this->base_interface.vo_port->driver;
+	return cle266_set_const_alpha_internal(driver,alpha,enable);
+      }
+
+  return -1;
+}
+
+static int cle266_set_alpha_surf_size(via_alphablending_interface_t *this,
+				      unsigned int width, unsigned int height) {
+  cle266_driver_t *driver = NULL;
+  unsigned int surf_w,surf_h;
+
+  if (this)
+    if (this->base_interface.vo_port)
+      if (this->base_interface.vo_port->driver) {
+	driver = (cle266_driver_t *)this->base_interface.vo_port->driver;
+
+	surf_w = width  > driver->screen_width  ? driver->screen_width  : width;
+	surf_h = height > driver->screen_height ? driver->screen_height : height;
+
+	 xprintf(driver->xine,XINE_VERBOSITY_INFO,"video_out_cle266: set_alpha_surf_size: width: %d, height %d. Actual size: width: %d, height: %d.\n",
+		 width,height,driver->alpha_width,driver->alpha_height);
+
+	if (surf_w != driver->alpha_width  ||
+	    surf_h != driver->alpha_height ||
+	    !driver->alpha_surf) {
+
+	  if (driver->alpha_surf)
+	    cle266_unmap_and_destroy_surface(driver,FOURCC_ALPHA);
+
+	  if (cle266_create_and_lock_surface(driver,FOURCC_ALPHA,surf_w,surf_h)) {  // Failed.
+	    xprintf(driver->xine,XINE_VERBOSITY_INFO,"video_out_cle266: set_alpha_surf_size: Failed to create alpha surface.");
+	    return -1;
+	  }
+
+	  driver->alpha_width  = surf_w;
+	  driver->alpha_height = surf_h;
+	}  // else: no chagne, we have the correct alpha surface already.
+
+	return 0;
+      }
+
+  return -1;
+}
+
+static int cle266_set_surf_controlled_alpha_internal(cle266_driver_t *this,
+						     int enable,
+						     unsigned int top, unsigned int left) {
+  if (this)
+    if (this->video_capability & (HW_VID_ALPHA16 | HW_VID_ALPHA256)) {
+      RECTL alphawin = {left,top,left + this->alpha_width -1,top + this->alpha_height -1};
+      unsigned long ret;
+
+      pthread_mutex_lock(&this->config_lock);
+
+      this->surf_alpha_enable = enable;
+      // ToDo: ret is ignored here.
+      ret = cle266_set_alphawin(this);
+
+      ret = VMI_DriverProc(this->p_vmi_info,UPDATEALPHA,(void *)&alphawin,NULL);
+
+      pthread_mutex_unlock(&this->config_lock);
+
+      if (ret == VMI_OK) {
+	 xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: set_surf_controlled_alpha: enable: %d, top: %d, left: %d.\n",
+		 enable,top,left);
+	return 0;
+      } else {
+	 xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: set_surf_controlled_alpha: Failed. enable: %d, top: %d, left: %d.\n",
+		 enable,top,left);
+	return -1;
+      }
+    }
+
+  return -1;
+}
+
+static int cle266_set_surf_controlled_alpha(via_alphablending_interface_t *this,
+					    int enable,
+					    unsigned int top, unsigned int left) {
+  cle266_driver_t *driver = NULL;
+
+  if (this)
+    if (this->base_interface.vo_port)
+      if (this->base_interface.vo_port->driver) {
+	driver = (cle266_driver_t *)this->base_interface.vo_port->driver;
+	return cle266_set_surf_controlled_alpha_internal(driver,enable,top,left);
+      }
+
+  return -1;
+}
+
+static int cle266_draw_alpha(via_alphablending_interface_t *this,
+			     char *src_buf,
+			     unsigned int src_width,  unsigned int src_height,
+			     unsigned int draw_width, unsigned int draw_height,
+			     unsigned int src_top,    unsigned int src_left,
+			     unsigned int dst_top,    unsigned int dst_left) {
+  cle266_driver_t *driver = NULL;
+
+  if (this)
+    if (this->base_interface.vo_port)
+      if (this->base_interface.vo_port->driver) {
+	driver = (cle266_driver_t *)this->base_interface.vo_port->driver;
+	unsigned int src_valid_width,src_valid_height;
+	unsigned int dst_valid_width,dst_valid_height;
+	unsigned int actual_width,actual_height;
+	int y;
+
+	/* ToDo: we don't fully understand dst_size etc. in alphadevice,
+	 *   so now we are simply using screen size to check, only available
+	 *   under FB.
+	 */
+
+	if (!driver->alpha_surf) {
+	  xprintf(driver->xine,XINE_VERBOSITY_INFO,"cle266_draw_alpha: No surface.\n");
+	  return -1;
+	}
+
+	// Check and clip.
+	if (src_top  >= src_height ||
+	    src_left >= src_width  ||
+	    dst_top  >= driver->alpha_height ||
+	    dst_left >= driver->alpha_width) {
+	 xprintf(driver->xine,XINE_VERBOSITY_INFO,"cle266_draw_alpha: draw area out of valid range.\n");
+	  return -1;
+	}
+	src_valid_width  = src_width  - src_left > draw_width  ? draw_width  : src_width  - src_left;
+	src_valid_height = src_height - src_top  > draw_height ? draw_height : src_height - src_top;
+	dst_valid_width  = driver->alpha_width  - dst_left > draw_width  ? draw_width  : driver->alpha_width  - dst_left;
+	dst_valid_height = driver->alpha_height - dst_top  > draw_height ? draw_height : driver->alpha_height - dst_top;
+	actual_width     = src_valid_width  > dst_valid_width  ? dst_valid_width  : src_valid_width;
+	actual_height    = src_valid_height > dst_valid_height ? dst_valid_height : src_valid_height;
+
+	// ToDo: Better logic to decide 16 or 256?
+	if (driver->video_capability & HW_VID_ALPHA256) {
+	  for (y = 0; y < actual_height; y++) {
+	    memcpy(driver->alpha_surf + ((driver->alpha_pitch * (dst_top + y)) + dst_left),
+		   src_buf            + (src_width            * (src_top + y)) + src_left,
+		   actual_width);
+	  }
+	} else {  // 16, sure?
+	  // ToDo: For CLE266, build 4 bpp alpha line to local buffer then copy to alpha surface.
+	  // ToDo: Make this faster! Write one line a time, write one image a time, or write one byte a time, which is faster?
+	  // Now using one line a time method.
+
+	  /* Note: The 4bpp packed alpha surface uses the lower 4 bits for even index pixels,
+	   *   i.e. pixel[0], pixel[2], pixel[4] etc. and the upper 4 bits from the same byte
+	   *   is for the odd pixel, i.e. pixel[1], pixel[3], pixel[5], etc. and pixel[0] and
+	   *   pixel[1] is from the same byte.
+	   */
+
+	  unsigned char line_buf[800];  // 1600 alpha pixels.
+	  int  maintain_left,maintain_right;  // Don't destroy the other pixel if we want to write a half byte.
+	  int  whole_byte_number;
+
+	  maintain_left = dst_left & 0x1;  // Keep the lower 4 bits.
+	  maintain_right = !((dst_left + actual_width -1) & 0x1);
+	  whole_byte_number = actual_width / 2 - ((maintain_left && maintain_right) ? 1 : 0);
+
+	  for (y = 0;y < actual_height; y++) {
+	    int x = 0;
+	    int counter;
+	    int cur_byte = 0;
+
+	    // Note: interger devide, don't merge the /2 together.
+
+	    if (maintain_left) {
+	      line_buf[0] = *(driver->alpha_surf + driver->alpha_pitch * (dst_top + y) + (x + dst_left)/2);
+	      line_buf[0] = (unsigned char)((line_buf[0] & 0xf) | (*(src_buf + src_width * (src_top + y) + x + src_left) & 0xf0));
+	      x++;
+	      cur_byte++;
+	    }
+	    for (counter = 0; counter < whole_byte_number; counter++) {
+	      line_buf[cur_byte] = (unsigned char)(((*(src_buf + src_width * (src_top + y) + x + src_left) >> 4) & 0xf) | 
+						   (*(src_buf + src_width * (src_top + y) + (x + 1) + src_left) & 0xf0));
+	      x += 2;
+	      cur_byte++;
+	    }
+	    if (maintain_right) {
+	      line_buf[cur_byte] = *(driver->alpha_surf + driver->alpha_pitch * (dst_top + y) + (x + dst_left)/2);
+	      line_buf[cur_byte] = (unsigned char)((line_buf[cur_byte] & 0xf0) | ((*(src_buf + src_width * (src_top + y) + x + src_left) >> 4) & 0xf));
+	    }
+
+	    memcpy(driver->alpha_surf + driver->alpha_pitch * (dst_top + y) + dst_left/2,
+		   line_buf,(actual_width+1)/2 + ((maintain_left && maintain_right) ? 1 : 0));
+	  }
+	}
+
+	return 0;
+      }
+
+  return -1;
+}
+
+static int cle266_draw_constant_alpha(via_alphablending_interface_t *this,
+				      unsigned char alpha,
+				      unsigned int draw_width, unsigned int draw_height,
+				      unsigned int dst_top,    unsigned int dst_left) {
+  cle266_driver_t *driver = NULL;
+
+  if (this)
+    if (this->base_interface.vo_port)
+      if (this->base_interface.vo_port->driver) {
+	driver = (cle266_driver_t *)this->base_interface.vo_port->driver;
+	unsigned int actual_width,actual_height;
+	int y;
+
+	/* ToDo: we don't fully understand dst_size etc. in alphadevice,
+	 *   so now we are simply using screen size to check, only available
+	 *   under FB.
+	 */
+
+	if (!driver->alpha_surf) {
+	 xprintf(driver->xine,XINE_VERBOSITY_INFO,"cle266_draw_alpha: No surface.\n");
+	  return -1;
+	}
+
+	// Check and clip.
+	if (dst_top  >= driver->alpha_height ||
+	    dst_left >= driver->alpha_width) {
+	  if (driver->xine->verbosity >= XINE_VERBOSITY_INFO)
+	    printf("cle266_draw_alpha: draw area out of valid range.\n");
+	  return -1;
+	}
+	actual_width  = driver->alpha_width  - dst_left > draw_width  ? draw_width  : driver->alpha_width  - dst_left;
+	actual_height = driver->alpha_height - dst_top  > draw_height ? draw_height : driver->alpha_height - dst_top;
+
+	// ToDo: Better logic to decide 16 or 256?
+	if (driver->video_capability & HW_VID_ALPHA256) {
+	  for (y = 0; y < actual_height; y++)
+	    memset(driver->alpha_surf + ((driver->alpha_pitch * (dst_top + y)) + dst_left),
+		   alpha,actual_width);
+	} else {  // 16, sure?
+	  // We are doing memset to alpha surface directly here.
+	  int  maintain_left,maintain_right;  // Don't destroy the other pixel if we want to write a half byte.
+	  int  whole_byte_number;
+
+	  maintain_left = dst_left & 0x1;  // Keep the lower 4 bits.
+	  maintain_right = !((dst_left + actual_width -1) & 0x1);
+	  whole_byte_number = actual_width / 2 - ((maintain_left && maintain_right) ? 1 : 0);
+
+	  for (y = 0;y < actual_height; y++) {
+	    // Note: interger devide, don't merge the /2 together.
+
+	    if (maintain_left) {
+	      *(driver->alpha_surf + driver->alpha_pitch * (dst_top + y) + dst_left/2) =
+		(unsigned char)((*(driver->alpha_surf + driver->alpha_pitch * (dst_top + y) + dst_left/2) & 0xf) | (alpha & 0xf0));
+	    }
+	    if (maintain_right) {
+	      *(driver->alpha_surf + driver->alpha_pitch * (dst_top + y) + (dst_left + draw_width -1)/2) =
+		(unsigned char)((*(driver->alpha_surf + driver->alpha_pitch * (dst_top + y) + (dst_left + draw_width -1)/2) & 0xf0) | ((alpha >> 4) & 0xf));
+	    }
+
+	    memset(driver->alpha_surf + driver->alpha_pitch * (dst_top + y) + dst_left/2,
+		   (unsigned char)((alpha & 0xf0) | ((alpha >> 4) & 0xf)), whole_byte_number);
+	  }
+	}
+
+	return 0;
+      }
+
+  return -1;
+}
+
+static int cle266_generate_draw_bin_alpha(via_alphablending_interface_t *this,
+					  unsigned int format,     char *src_buf,
+					  unsigned int src_pitch,  unsigned int src_height,
+					  unsigned int draw_width, unsigned int draw_height,
+					  unsigned int src_top,    unsigned int src_left,
+					  unsigned int dst_top,    unsigned int dst_left,
+					  unsigned int hollow_high_color, unsigned int hollow_low_color,
+					  unsigned char normal_alpha,
+					  unsigned char hollow_alpha,
+					  alpha_mode mode) {
+  cle266_driver_t *driver = NULL;
+
+  if (this)
+    if (this->base_interface.vo_port)
+      if (this->base_interface.vo_port->driver) {
+	driver = (cle266_driver_t *)this->base_interface.vo_port->driver;
+
+	if (!driver->alpha_surf) {
+	  xprintf(driver->xine,XINE_VERBOSITY_INFO,"cle266_draw_alpha: No surface.\n");
+	  return -1;
+	}
+
+	//al zhang code starts from here
+	unsigned int src_valid_width,src_valid_height,src_width;
+	unsigned int dst_valid_width,dst_valid_height;
+	unsigned int actual_width,actual_height;
+	char *  src_color;
+	unsigned char src_red,src_green,src_blue;
+	int x,y;
+	unsigned char red[2],grn[2],blue[2],tbuf[1024];
+	unsigned char hollow_alpha_cn,normal_alpha_cn;
+	
+	hollow_alpha_cn = hollow_alpha;
+	normal_alpha_cn = normal_alpha;
+	hollow_alpha&=0xf0;
+	normal_alpha&=0xf0;
+
+	red[0]   = hollow_high_color;/*the corlor is ABGR 32bits*/
+	grn[0]   = (hollow_high_color >> 8);
+	blue[0]  = (hollow_high_color >> 16);
+	red[1]   = hollow_low_color;
+	grn[1]   = (hollow_low_color >> 8);
+	blue[1]  = (hollow_low_color >> 16);
+	switch(format){
+
+	  /* ToDo: we don't fully understand dst_size etc. in alphadevice,
+	   *   so now we are simply using screen size to check, only available
+	   *   under FB.
+	   */
+	case VIA_PIX_FMT_RGBA32:
+	  // Check and clip.
+	  src_width = src_pitch >> 2;
+	  if (src_top  >= src_height ||
+	      src_left >= src_width  ||
+	      dst_top  >= driver->alpha_height ||
+	      dst_left >= driver->alpha_width) {
+	    xprintf(driver->xine,XINE_VERBOSITY_INFO,"cle266_draw_alpha: draw area out of valid range.\n");
+	    return -1;
+	  }
+	  src_valid_width  = src_width  - src_left > draw_width  ? draw_width  : src_width  - src_left;
+	  src_valid_height = src_height - src_top  > draw_height ? draw_height : src_height - src_top;
+	  dst_valid_width  = driver->alpha_width  - dst_left > draw_width  ? draw_width  : driver->alpha_width  - dst_left;
+	  dst_valid_height = driver->alpha_height - dst_top  > draw_height ? draw_height : driver->alpha_height - dst_top;
+	  actual_width     = src_valid_width  > dst_valid_width  ? dst_valid_width  : src_valid_width;
+	  actual_height    = src_valid_height > dst_valid_height ? dst_valid_height : src_valid_height;
+	  //now start writing the alpha surface,once a line 
+	  if(driver->video_capability & HW_VID_ALPHA256)
+	    {
+	      for(y = 0; y < actual_height; y++){
+		for(x = 0; x < actual_width; x++){
+		  src_color = src_buf + src_pitch*(src_top + y) + ((x + src_left) << 2);
+		  src_blue   = *(src_color);
+		  src_green = *(src_color + 1);
+		  src_red  = *(src_color + 2);
+		  if((red[0] >= src_red && src_red >= red[1])&& 
+		     (grn[0] >= src_green && src_green >= grn[1])&& 
+		     (blue[0] >= src_blue && src_blue >= blue[1]))
+		    {
+	              *(tbuf+x)= hollow_alpha_cn;
+		    }
+	          else
+		    {
+	              *(tbuf+x)=normal_alpha_cn;
+		    }
+		}
+		memcpy(driver->alpha_surf+(y + dst_top) * driver->alpha_pitch + dst_left, tbuf,actual_width);
+	      }
+	    }
+	  else
+	    {
+	      for(y = 0; y < actual_height; y++){
+		for(x = 0; x < actual_width; x++){
+		  src_color = src_buf + src_pitch*(src_top + y) + ((x + src_left) << 2);
+		  src_red   = *(src_color);
+		  src_green = *(src_color + 1);
+		  src_blue  = *(src_color + 2);
+		  int x1 = x + dst_left%2;
+
+		  if((red[0] >= src_red && src_red >= red[1])&& 
+		     (grn[0] >= src_green && src_green >= grn[1])&& 
+		     (blue[0] >= src_blue && src_blue >= blue[1])){  //the src color falls into the hollow space
+	            if(x1%2==0){  //the pixel positin on alpha surface is even,such as pixel(0,2,4,...) 
+		      *(tbuf + x1/2) = (*(tbuf + x1/2) & 0xf0) | (hollow_alpha >> 4);
+		    }
+	            else{ //the pixel positin on alpha surface is odd,such as pixel(1,3,5,...) 
+		      *(tbuf + x1/2) = (*(tbuf + x1/2) & 0x0f) | hollow_alpha;
+		    }
+	          }
+		  else{ //the src color falls out of the hollow space
+		    if(x1%2==0){
+		      *(tbuf + x1/2) = (*(tbuf + x1/2) & 0xf0) | (normal_alpha >> 4);
+		    }
+	            else{
+	              *(tbuf + x1/2) = (*(tbuf + x1/2) & 0x0f) | normal_alpha;
+	            }
+		  }
+		}
+		if((dst_left%2)==1 && (actual_width)%2==1){
+		  //both sides are odd pixels
+		  memcpy(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1)+1, tbuf + 1,(actual_width >> 1));
+		  *(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1)) = \
+		    ((*(unsigned char*)(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1))) & 0x0f) | \
+		    (*tbuf & 0xf0);
+
+		}
+		else if((dst_left)%2==1){
+		  //left side  is an odd pixel and right side is an even pixel,so we must process the both sides
+		  memcpy(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1)+1, tbuf + 1,(actual_width >> 1) - 1);
+		  //process the left side
+		  *(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1)) = \
+		    ((*(unsigned char*)(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1))) & 0x0f) | \
+		    (*tbuf & 0xf0);
+		  //process the right side
+		  *(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + ((dst_left + actual_width -1) >> 1)) = \
+		    ((*((unsigned char*)(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + ((dst_left + actual_width - 1) >> 1)))) & 0xf0) | \
+		    (*(tbuf + (actual_width >> 1)) & 0x0f);
+		}
+		else if(actual_width%2==1){
+		  // right side is an even pixel 
+		  memcpy(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1), tbuf,(actual_width >> 1));
+		  *(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + ((dst_left + actual_width - 1) >> 1)) = \
+		    ((*((unsigned char*)(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + ((dst_left + actual_width - 1) >> 1)))) & 0xf0) | \
+		    (*(tbuf + (actual_width >> 1)) & 0x0f);
+		}
+		else{
+		  memcpy(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1), tbuf,actual_width >> 1);
+		}
+	      }
+	    }
+	  break; //case 0
+	case VIA_PIX_FMT_BGR24://process windows 24bits bitmap RGB
+	  // Check and clip.
+	  src_width = src_pitch / 3;
+	  if (src_top  >= src_height ||
+	      src_left >= src_width  ||
+	      dst_top  >= driver->alpha_height ||
+	      dst_left >= driver->alpha_width) {
+	    xprintf(driver->xine,XINE_VERBOSITY_INFO,"cle266_draw_alpha: draw area out of valid range.\n");
+	    return -1;
+	  }
+	  src_valid_width  = src_width  - src_left > draw_width  ? draw_width  : src_width  - src_left;
+	  src_valid_height = src_height - src_top  > draw_height ? draw_height : src_height - src_top;
+	  dst_valid_width  = driver->alpha_width  - dst_left > draw_width  ? draw_width  : driver->alpha_width  - dst_left;
+	  dst_valid_height = driver->alpha_height - dst_top  > draw_height ? draw_height : driver->alpha_height - dst_top;
+	  actual_width     = src_valid_width  > dst_valid_width  ? dst_valid_width  : src_valid_width;
+	  actual_height    = src_valid_height > dst_valid_height ? dst_valid_height : src_valid_height;
+	  //now start writing the alpha surface,once a line 
+	  if(driver->video_capability & HW_VID_ALPHA256)
+	    {
+	      for(y = 0; y < actual_height; y++){
+		for(x = 0; x < actual_width; x++){
+		  src_color = src_buf + src_pitch*(src_top + y) + ((x + src_left) * 3);
+		  src_blue   = *(src_color);
+		  src_green = *(src_color + 1);
+		  src_red  = *(src_color + 2);
+		  if((red[0] >= src_red && src_red >= red[1])&& 
+		     (grn[0] >= src_green && src_green >= grn[1])&& 
+		     (blue[0] >= src_blue && src_blue >= blue[1]))
+		    {
+	              *(tbuf+x)= hollow_alpha_cn;
+		    }
+	          else
+		    {
+	              *(tbuf+x)=normal_alpha_cn;
+		    }
+		}
+		memcpy(driver->alpha_surf+(y + dst_top) * driver->alpha_pitch + dst_left, tbuf,actual_width);
+	      }
+	    }
+	  else
+	    {
+	      for(y = 0; y < actual_height; y++){
+		for(x = 0; x < actual_width; x++){
+		  src_color = src_buf + src_pitch*(src_top + y) + ((x + src_left) * 3);
+		  src_blue   = *(src_color);
+		  src_green = *(src_color + 1);
+		  src_red  = *(src_color + 2);
+		  int x1 = x + dst_left%2;
+		  if((red[0] >= src_red && src_red >= red[1])&& 
+		     (grn[0] >= src_green && src_green >= grn[1])&& 
+		     (blue[0] >= src_blue && src_blue >= blue[1])){
+		    //the src color falls into the hollow space
+		    if(x1%2==0){
+		      //the pixel positin on alpha surface is even,such as pixel(0,2,4,...) 
+		      *(tbuf + x1/2) = (*(tbuf + x1/2) & 0xf0) | (hollow_alpha >> 4);
+		    }
+		    else{ //the pixel positin on alpha surface is odd,such as pixel(1,3,5,...) 
+		      *(tbuf + x1/2) = (*(tbuf + x1/2) & 0x0f) | hollow_alpha;
+		    }
+	          }
+		  else{
+		    //the src color falls out of the hollow space
+		    if(x1%2==0){
+		      *(tbuf + x1/2) = (*(tbuf + x1/2) & 0xf0) | (normal_alpha >> 4);
+		    }
+		    else{
+		      *(tbuf + x1/2) = (*(tbuf + x1/2) & 0x0f) | normal_alpha;
+		    }
+		  }
+		}
+		if((dst_left%2)==1 && (actual_width)%2==1){
+		  //both sides are odd pixels
+		  memcpy(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1)+1, tbuf + 1,(actual_width >> 1));
+		  *(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1)) = \
+		    ((*(unsigned char*)(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1))) & 0x0f) | \
+		    (*tbuf & 0xf0);
+
+		}
+		else if((dst_left)%2==1){
+		  //left side  is an odd pixel and right side is an even pixel,so we must process the both sides
+		  memcpy(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1)+1, tbuf + 1,(actual_width >> 1) - 1);
+		  //process the left side
+		  *(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1)) = \
+		    ((*(unsigned char*)(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1))) & 0x0f) | \
+		    (*tbuf & 0xf0);
+		  //process the right side
+		  *(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + ((dst_left + actual_width -1) >> 1)) = \
+		    ((*((unsigned char*)(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + ((dst_left + actual_width - 1) >> 1)))) & 0xf0) | \
+		    (*(tbuf + (actual_width >> 1)) & 0x0f);
+		}
+		else if(actual_width%2==1){
+		  // right side is an even pixel 
+		  memcpy(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1), tbuf,(actual_width >> 1));
+		  *(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + ((dst_left + actual_width - 1) >> 1)) = \
+		    ((*((unsigned char*)(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + ((dst_left + actual_width - 1) >> 1)))) & 0xf0) | \
+		    (*(tbuf + (actual_width >> 1)) & 0x0f);
+		}
+		else{
+		  memcpy(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1), tbuf,actual_width >> 1);
+		}
+	      }
+	    }
+	  break;//case 1
+	case VIA_PIX_FMT_BGR555: //process 16bits windows bitmap RGB(0:5:5:5),just add triple 0 to the end of every color 
+	  // Check and clip.
+	  src_width = src_pitch >> 1;
+	  if (src_top  >= src_height ||
+	      src_left >= src_width  ||
+	      dst_top  >= driver->alpha_height ||
+	      dst_left >= driver->alpha_width) {
+	   xprintf(driver->xine,XINE_VERBOSITY_INFO,"cle266_draw_alpha: draw area out of valid range.\n");
+	    return -1;
+	  }
+	  src_valid_width  = src_width  - src_left > draw_width  ? draw_width  : src_width  - src_left;
+	  src_valid_height = src_height - src_top  > draw_height ? draw_height : src_height - src_top;
+	  dst_valid_width  = driver->alpha_width  - dst_left > draw_width  ? draw_width  : driver->alpha_width  - dst_left;
+	  dst_valid_height = driver->alpha_height - dst_top  > draw_height ? draw_height : driver->alpha_height - dst_top;
+	  actual_width     = src_valid_width  > dst_valid_width  ? dst_valid_width  : src_valid_width;
+	  actual_height    = src_valid_height > dst_valid_height ? dst_valid_height : src_valid_height;
+	  //now start writing the alpha surface,once a line 
+	  //tbuf = (unsigned char*)malloc(actual_width >> 1);
+	  if(driver->video_capability & HW_VID_ALPHA256)
+	    {
+	      for(y = 0; y < actual_height; y++){
+		for(x = 0; x < actual_width; x++){
+		  short temp;
+		  src_color = src_buf + src_pitch*(src_top + y) + ((x + src_left) << 1);
+		  temp = *((short int*)src_color);
+		  src_blue   = temp << 3;
+		  src_green = (temp >> 2) & 0xf8;//*(src_color + 1);
+		  src_red  = (temp >> 7) & 0xf8;
+		  //int x1 = x + dst_left%2;
+		  if((red[0] >= src_red && src_red >= red[1])&& 
+		     (grn[0] >= src_green && src_green >= grn[1])&& 
+		     (blue[0] >= src_blue && src_blue >= blue[1]))
+		    {
+	              *(tbuf+x)= hollow_alpha_cn;
+		    }
+	          else
+		    {
+	              *(tbuf+x) = normal_alpha_cn;
+		    }
+		}
+		memcpy(driver->alpha_surf+(y + dst_top) * driver->alpha_pitch + dst_left, tbuf,actual_width);
+	      }
+	    }
+	  else{
+	    for(y = 0; y < actual_height; y++){
+	      for(x = 0; x < actual_width; x++){
+		short temp;
+		src_color = src_buf + src_pitch*(src_top + y) + ((x + src_left) << 1);
+		temp = *((short int*)src_color);
+		src_blue   = temp << 3;
+		src_green = (temp >> 2) & 0xf8;//*(src_color + 1);
+		src_red  = (temp >> 7) & 0xf8;
+		int x1 = x + dst_left%2;
+		if((red[0] >= src_red && src_red >= red[1])&& 
+		   (grn[0] >= src_green && src_green >= grn[1])&& 
+		   (blue[0] >= src_blue && src_blue >= blue[1])){
+		  //the src color falls into the hollow space
+		  if(x1%2==0){
+		    //the pixel positin on alpha surface is even,such as pixel(0,2,4,...) 
+		    *(tbuf + x1/2) = (*(tbuf + x1/2) & 0xf0) | (hollow_alpha >> 4);
+		  }
+		  else{ //the pixel positin on alpha surface is odd,such as pixel(1,3,5,...) 
+		    *(tbuf + x1/2) = (*(tbuf + x1/2) & 0x0f) | hollow_alpha;
+		  }
+		}
+		else{
+		  //the src color falls out of the hollow space
+		  if(x1%2==0){
+		    *(tbuf + x1/2) = (*(tbuf + x1/2) & 0xf0) | (normal_alpha >> 4);
+		  }
+		  else{
+		    *(tbuf + x1/2) = (*(tbuf + x1/2) & 0x0f) | normal_alpha;
+		  }
+		}
+	      }
+	      if((dst_left%2)==1 && (actual_width)%2==1){
+		//both sides are odd pixels
+		memcpy(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1)+1, tbuf + 1,(actual_width >> 1));
+		*(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1)) = \
+		  ((*(unsigned char*)(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1))) & 0x0f) | \
+		  (*tbuf & 0xf0);
+
+	      }
+	      else if((dst_left)%2==1){
+		//left side  is an odd pixel and right side is an even pixel,so we must process the both sides
+		memcpy(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1)+1, tbuf + 1,(actual_width >> 1) - 1);
+		//process the left side
+		*(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1)) = \
+		  ((*(unsigned char*)(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1))) & 0x0f) | \
+		  (*tbuf & 0xf0);
+		//process the right side
+		*(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + ((dst_left + actual_width -1) >> 1)) = \
+		  ((*((unsigned char*)(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + ((dst_left + actual_width - 1) >> 1)))) & 0xf0) | \
+		  (*(tbuf + (actual_width >> 1)) & 0x0f);
+	      }
+	      else if(actual_width%2==1){
+		// right side is an even pixel 
+		memcpy(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1), tbuf,(actual_width >> 1));
+		*(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + ((dst_left + actual_width - 1) >> 1)) = \
+		  ((*((unsigned char*)(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + ((dst_left + actual_width - 1) >> 1)))) & 0xf0) | \
+		  (*(tbuf + (actual_width >> 1)) & 0x0f);
+	      }
+	      else{
+		memcpy(driver->alpha_surf+(y + dst_top) * (driver->alpha_pitch) + (dst_left >> 1), tbuf,actual_width >> 1);
+	      }
+	    }//for(y) case 2
+	  }
+	  break;
+	default:
+	  lprintf("\nNow the bin alpha can only support 32bpp pic!\n");
+	  return -1;
+	} //switch (format)
+
+	return 0;
+      }
+
+  return -1;
+}
+
+
+static int cle266_generate_draw_bin_alpha_from_bmp(via_alphablending_interface_t *this,
+						   const char *file,
+						   unsigned int draw_width,unsigned int draw_height,
+						   unsigned int src_top,unsigned int src_left,
+						   unsigned int dst_top,unsigned int dst_left,
+						   unsigned int hollow_high_color,
+						   unsigned int hollow_low_color,
+						   unsigned char normal_alpha,
+						   unsigned char hollow_alpha,
+						   alpha_mode mode)
+{
+  //we will open an  24bits bitmap and convert it to ABGR
+  cle266_driver_t *driver = NULL;
+  
+  if (this)
+    if (this->base_interface.vo_port)
+      if (this->base_interface.vo_port->driver) {
+	driver = (cle266_driver_t *)this->base_interface.vo_port->driver;
+
+	if (!driver->alpha_surf) {
+	  xprintf(driver->xine,XINE_VERBOSITY_INFO,"cle266_draw_alpha: No surface.\n");
+	  return -1;
+	}
+	//al zhang code starts from here
+	unsigned int src_valid_width,src_valid_height,src_width,src_height;
+	unsigned int dst_valid_width,dst_valid_height;
+	unsigned int actual_width,actual_height,actual_pitch;
+
+	unsigned int x,pitch,buf_size,width,height,format;
+	int y, fd, byte_pixel;
+	unsigned char * buf;
+	bmpfileheader_t bmpfh;
+	bmpinfoheader_t bmpih;
+
+	fd = open(file,O_RDONLY);
+	if(fd==-1)
+	  return -1;
+	read(fd,(void*)&bmpfh,sizeof(bmpfileheader_t));
+	read(fd,(void*)&bmpih,sizeof(bmpinfoheader_t));
+	if(bmpih.biBitCount!=24 && bmpih.biBitCount!= 16)
+	  {
+	    close(fd);
+	    return -1;
+	  }
+	width = bmpih.biWidth;
+	height = bmpih.biHeight;
+
+	src_width = width;
+	src_height = height;
+	if (src_top  >= src_height ||
+	    src_left >= src_width  ||
+	    dst_top  >= driver->alpha_height ||
+	    dst_left >= driver->alpha_width) {
+	  xprintf(driver->xine,XINE_VERBOSITY_INFO,"cle266_draw_alpha: draw area out of valid range.\n");
+	  return -1;
+	}
+	src_valid_width  = src_width  - src_left > draw_width  ? draw_width  : src_width  - src_left;
+	src_valid_height = src_height - src_top  > draw_height ? draw_height : src_height - src_top;
+	dst_valid_width  = driver->alpha_width  - dst_left > draw_width  ? draw_width  : driver->alpha_width  - dst_left;
+	dst_valid_height = driver->alpha_height - dst_top  > draw_height ? draw_height : driver->alpha_height - dst_top;
+	actual_width     = src_valid_width  > dst_valid_width  ? dst_valid_width  : src_valid_width;
+	actual_height    = src_valid_height > dst_valid_height ? dst_valid_height : src_valid_height;
+
+	byte_pixel = (bmpih.biBitCount >> 3);
+	x = ((width * byte_pixel) % 4);
+
+	pitch = x > 0 ? width * byte_pixel + 4 - x : width * byte_pixel;
+	format = byte_pixel == 3 ? VIA_PIX_FMT_BGR24 : VIA_PIX_FMT_BGR555;
+	buf_size = width * byte_pixel;//bitmap pitch without stuff bytes
+	actual_pitch = actual_width * byte_pixel;
+	buf = malloc(buf_size);
+
+	lseek(fd,(sizeof(bmpfileheader_t) + sizeof(bmpinfoheader_t)) + (height - actual_height - src_top) * pitch ,SEEK_SET);
+	for(y = 0; y < actual_height; y++){
+	  read(fd, buf, buf_size);
+	  if(x!=0)
+	    lseek(fd,(4 - x),SEEK_CUR);
+	  if(cle266_generate_draw_bin_alpha(this,format,
+					    buf,
+					    actual_pitch, 1,
+					    draw_width,1,
+					    0,src_left,
+					    dst_top + actual_height - 1 - y,dst_left,
+					    hollow_high_color,hollow_low_color,
+					    normal_alpha,hollow_alpha,
+					    mode) != 0){
+	    close(fd);
+	    free(buf);
+	    return -1;
+	  }
+	}
+        close(fd);      
+	free(buf);
+
+	return 0;
+
+      }
+  return -1; 
+}
+
+//=======================================================================
+// vo_frame functions
+
+static void cle266_frame_field (vo_frame_t *vo_img, int which_field) {
+  // ToDo: What's this for?
+}
+
+// Note: This is only called at vo_driver quit time, to free a frame.
+static void cle266_dispose_frame (vo_frame_t *vo_img) {
+
+  cle266_frame_t  *frame = (cle266_frame_t  *) vo_img ;
+  cle266_driver_t *this  = (cle266_driver_t *) vo_img->driver;
+
+  if (!frame || !this)
+    return;
+
+  // Only the allocated image buffer need to be freed.
+ if(frame->chunk[0])
+      free(frame->chunk[0]);  // No problem if it's NULL.
+ if(frame->chunk[1])
+      free(frame->chunk[1]); 
+  if(frame->chunk[2])
+      free(frame->chunk[2]); 
+
+  free (frame);
+}
+
+//=======================================================================
+// vo_driver functions
+
+static uint32_t cle266_get_capabilities (vo_driver_t *this_gen) {
+  cle266_driver_t *this = (cle266_driver_t *) this_gen;
+  return this->capabilities;
+}
+
+static const char **cle266_query_special_interface(vo_driver_t *this_gen) {
+  cle266_driver_t *this = (cle266_driver_t *)this_gen;
+
+  static const char *cle266_interfaces[] = {"VIAUniChromeAlpha",NULL};
+  static const char *null_interface_list = NULL;
+
+  if (this)
+    if (this->video_capability)
+      return cle266_interfaces;
+
+  return &null_interface_list;
+}
+
+static vo_special_interface_t *cle266_get_special_interface(vo_driver_t *this_gen,
+							    const char *id) {
+  cle266_driver_t *this = (cle266_driver_t *)this_gen;
+
+  static via_alphablending_interface_t alpha_blender = {
+    {"VIAUniChromeAlpha",NULL},
+    cle266_get_screen_info,
+     cle266_get_alpha,
+    cle266_set_const_alpha,
+    cle266_set_alpha_surf_size,
+    cle266_set_surf_controlled_alpha,
+    cle266_draw_alpha,
+    cle266_draw_constant_alpha,
+    cle266_generate_draw_bin_alpha,
+    cle266_generate_draw_bin_alpha_from_bmp
+  };
+
+  if (this && id)
+    if (!strcasecmp(id,"VIAUniChromeAlpha") && this->video_capability)
+      return (vo_special_interface_t *)&alpha_blender;
+
+  return NULL;
+}
+
+static int cle266_get_property (vo_driver_t *this_gen, int property) {
+
+  cle266_driver_t *this = (cle266_driver_t *) this_gen;
+
+  if (!this || property >= VO_NUM_PROPERTIES)
+    return 0;
+
+  xprintf(this->xine,XINE_VERBOSITY_LOG,"video_out_cle266: get_property #%d: %d\n",
+	    property, this->props[property].value);
+
+  return this->props[property].value;
+}
+
+static void cle266_get_property_min_max (vo_driver_t *this_gen,
+					 int property, int *min, int *max) {
+  cle266_driver_t *this = (cle266_driver_t *) this_gen;
+  if (!this || property >= VO_NUM_PROPERTIES)
+    *min = *max = 0;
+  *min = this->props[property].min;
+  *max = this->props[property].max;
+}
+
+static int cle266_set_property (vo_driver_t *this_gen,
+				int property, int value) {
+
+  cle266_driver_t *this = (cle266_driver_t *) this_gen;
+  unsigned long ret;
+  if (!this || property >= VO_NUM_PROPERTIES)
+    return 0;
+
+  switch (property) {
+  case VO_PROP_INTERLACED:
+
+    /*       this->props[property].value = value; */
+    /*       if (this->xine->verbosity >= XINE_VERBOSITY_LOG) { */
+    /* 	printf("video_out_xv: VO_PROP_INTERLACED(%d)\n", */
+    /* 	       this->props[property].value); */
+    /*       } */
+    /*       this->deinterlace_enabled = value; */
+    /*       if (this->deinterlace_method == DEINTERLACE_ONEFIELDXV) { */
+    /*          xv_compute_ideal_size (this); */
+    /*          xv_compute_output_size (this); */
+    /*       } */
+    break;
+  case VO_PROP_ASPECT_RATIO:
+
+    if (value>=XINE_VO_ASPECT_NUM_RATIOS)
+      value = XINE_VO_ASPECT_AUTO;
+
+    this->props[property].value = value;
+    xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_xv: VO_PROP_ASPECT_RATIO(%d)\n",
+	     this->props[property].value);
+    this->sc.user_ratio = value;
+
+    _x_vo_scale_compute_ideal_size (&this->sc);
+
+    this->sc.force_redraw = 1;    /* trigger re-calc of output size */
+    break;
+  case VO_PROP_ZOOM_X:
+
+    /*       if ((value >= VO_ZOOM_MIN) && (value <= VO_ZOOM_MAX)) { */
+    /*         this->props[property].value = value; */
+    /* 	if (this->xine->verbosity >= XINE_VERBOSITY_LOG)  */
+    /* 	  printf ("video_out_xv: VO_PROP_ZOOM_X = %d\n", */
+    /* 		  this->props[property].value); */
+
+    /* 	this->sc.zoom_factor_x = (double)value / (double)VO_ZOOM_STEP; */
+
+    /* 	xv_compute_ideal_size (this); */
+
+    /* 	this->sc.force_redraw = 1;    /\* trigger re-calc of output size *\/ */
+    /*       } */
+    break;
+  case VO_PROP_ZOOM_Y:
+
+    /*       if ((value >= VO_ZOOM_MIN) && (value <= VO_ZOOM_MAX)) { */
+    /*         this->props[property].value = value; */
+    /* 	if (this->xine->verbosity >= XINE_VERBOSITY_LOG)  */
+    /* 	  printf ("video_out_xv: VO_PROP_ZOOM_Y = %d\n", */
+    /* 		  this->props[property].value); */
+
+    /* 	this->sc.zoom_factor_y = (double)value / (double)VO_ZOOM_STEP; */
+
+    /* 	xv_compute_ideal_size (this); */
+
+    /* 	this->sc.force_redraw = 1;    /\* trigger re-calc of output size *\/ */
+    /*       } */
+    break;
+
+  case VO_PROP_COLORKEY:
+    /* Now we are using the input value directly.
+     * This is the value HW uses to check, shall be the same as the parameter of
+     *   XFillRectangle.
+     * ToDo: define a input color format and use the generate_colorkey() to set
+     *   colorkey value.
+     */
+    {
+      pthread_mutex_lock(&this->config_lock);
+
+      this->props[VO_PROP_COLORKEY].value = value;
+      //this->colorkey = value;
+
+      // Update overlay and clean output area here.
+      cle266_redraw_needed((vo_driver_t *)this);
+      cle266_clean_output_area(this);
+      cle266_update_overlay(this);
+      pthread_mutex_unlock(&this->config_lock);
+    }
+    break;
+  case VO_PROP_USECOLORKEY:
+    {
+      pthread_mutex_lock(&this->config_lock);
+
+      this->props[VO_PROP_USECOLORKEY].value = value ? 1 : 0;
+
+      // Update overlay and clean output area here.
+      cle266_redraw_needed((vo_driver_t *)this);
+      cle266_clean_output_area(this);
+      cle266_update_overlay(this);
+      pthread_mutex_unlock(&this->config_lock);
+    }
+    break;
+
+  case VO_PROP_OUTPUTENABLED:
+    {
+      switch (this->working_env) {
+      case FB:
+      case X:
+	if (value) {
+	  pthread_mutex_lock(&this->config_lock);
+	  this->props[VO_PROP_OUTPUTENABLED].value = 1;  // Set flag only, overlay will be turned on at the time of output.
+	  pthread_mutex_unlock(&this->config_lock);
+	} else {  // Turn off, clean output area.
+	  pthread_mutex_lock(&this->config_lock);
+	  this->props[VO_PROP_OUTPUTENABLED].value = 0;
+	  // Close video overlay here for fast response.
+	  cle266_redraw_needed((vo_driver_t *)this);
+	  cle266_clean_output_area(this);
+	  cle266_update_overlay(this);
+	  pthread_mutex_unlock(&this->config_lock);
+	}
+	break;
+      case NONE:
+	xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: set_property: prop_output_enabled - wrong working environment.\n");
+	break;
+      }
+    }
+    break;
+
+  case VO_PROP_MACROVISION:
+    {
+      #ifdef HAVE_MV_LIB	// Horace Lan    
+      MACROVISIONINFO mvision_info = this->macrovision_info;
+     
+      if (value >=0 && value <=3) {
+	mvision_info.dwLevel = value;
+	ret = VIAMV( SETMACROVISION,
+			     (void *)&mvision_info,
+			     NULL); // Horace Lan
+	if (ret == VMI_OK) {
+	  this->macrovision_info.dwLevel = value;
+	  this->props[VO_PROP_MACROVISION].value = this->macrovision_info.dwLevel;
+	  xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: set_property: macrovision level is changed to: %d.\n",value);
+	} else {
+	  xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: set_property: failed to set macrovision function to level %d.\n",
+		   value);
+	}
+      } else
+	  xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: set_property: illegal macorvision level %d.\n",value);
+      #endif	// Horace Lan	  
+    }
+    break;
+  case VO_PROP_TVOUT:
+    {
+      unsigned int dwTVStatus = value;  // DWord ...
+     
+      ret = VMI_DriverProc(this->p_vmi_info,SETTVOUT,(void *)&dwTVStatus,NULL);
+      xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: %sed to turn %s TV out.\n",
+	       (ret==VMI_OK)?"succeed":"fail",
+	       value?"on":"off");
+    }
+    break;
+   
+   case VO_PROP_TVOVERLAY:
+    {
+      unsigned int dwTVOverlayStatus = value;  // DWord ...
+      ret = VMI_DriverProc(this->p_vmi_info,SETTVOVERLAY,(void *)&dwTVOverlayStatus,NULL);
+      xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: %sed to turn %s TV Overlay.\n",
+	       (ret==VMI_OK)?"succeed":"fail",
+	       value?"on":"off");
+    }
+    break;
+  }
+
+  return value;
+}
+
+static void cle266_frame_free_cb(vo_frame_t *vo_img) {
+
+  cle266_frame_t  *frame = (cle266_frame_t  *) vo_img ;
+  //cle266_driver_t *this  = (cle266_driver_t *) vo_img->driver;
+
+  if (!frame )
+    return;
+
+  if (frame->vo_frame.format == XINE_IMGFMT_VIA) {
+    //vmi_accel_t * p_vmi_accel;
+   // p_vmi_accel=(vmi_accel_t *)img->accel_data;
+    //printf("libffmpeg: get_frame: id: %d.\n",img->id);
+    //p_vmi_accel->decoded_ok=0;
+    frame->vmi_accel_data.decoded_ok=0;
+  }
+}
+
+static vo_frame_t *cle266_allocate_frame(vo_driver_t *this_gen) {
+
+  cle266_frame_t     *frame ;
+  cle266_driver_t    *this = (cle266_driver_t *)this_gen;
+
+ if (this->used_accel_buffers>=NUM_MPEG2_ACCEL_SURFS)
+ 	return NULL; //do not allocate buffer more than NUM_MPEG2_ACCEL_SURFS.
+	
+  frame = (cle266_frame_t *) malloc (sizeof (cle266_frame_t));
+  if (frame == NULL) {
+       xprintf (this->xine,XINE_VERBOSITY_INFO,"cle266_alloc_frame: out of memory\n");
+	return NULL;  // It's up to VO.c to deal with this.
+  }
+  memset (frame, 0, sizeof(cle266_frame_t));
+
+  pthread_mutex_init (&frame->vo_frame.mutex, NULL);
+
+  // supply required functions
+//  frame->vo_frame.copy          = NULL;  // ToDo: provide a copy function?
+  frame->vo_frame.field         = cle266_frame_field;
+  frame->vo_frame.dispose       = cle266_dispose_frame;
+  //frame->vo_frame.frame_free_cb = cle266_frame_free_cb;//fixme for mpeg4 decoded_ok is reset here
+  // Add our private functions.
+  frame->vo_frame.driver  = this_gen;
+
+  //Jack Liu, Add accel private menbers. 
+  frame->vmi_accel_data.surf_id=this->used_accel_buffers;
+  this->used_accel_buffers++;
+  frame->vmi_accel_data.decoded_ok=0;
+  frame->vmi_accel_data.p_vmi_info=this->p_vmi_info;
+  frame->vmi_accel_data.proc_begin_frame=begin_frame;
+  frame->vmi_accel_data.proc_render_frame=render_frame;
+
+  frame->vo_frame.accel_data=&frame->vmi_accel_data; //do not forget this.
+  
+  return (vo_frame_t *) frame;
+}
+
+static void cle266_update_frame_format (vo_driver_t *this_gen,
+					vo_frame_t *frame_gen,
+					uint32_t width, uint32_t height,
+					double ratio, uint32_t format, int flags) {
+
+  cle266_driver_t  *this = (cle266_driver_t *) this_gen;
+  cle266_frame_t   *frame = (cle266_frame_t *) frame_gen;
+ 
+  if (!frame || !this || !width || !height) {
+    lprintf("vo_driver_cle266: update_frame_format: Invalid argument.\n");
+    return;
+  }
+ xine_list_iterator_t head = xine_list_front(this->xine->streams);
+ xine_stream_t *stream = (xine_stream_t *) xine_list_get_value(this->xine->streams, head);
+  if(stream){
+ 	if(stream->last_video_decoder_streamtype== -1)
+ 		stream->last_video_decoder_streamtype=stream->video_decoder_streamtype;
+ }
+
+  /* ToDo:
+   * Check that everything is valid.
+   * What to do if failed?
+   * Other code must be adapted to be able to deal with failed update_frame_format().
+   * Begin
+   * if (can not support)
+   *   no config change, return fail;
+   * if (failed to allocate surface) {
+   *   return fail;
+   *   Then we shall change into config_FourCC = 0, and we will switch to any SW format
+   *     supported if we are asked to display a SW decoded frame.
+   * }
+   *   Reset FourCC of frame->format and this->config_FourCC to "\0\0\0\0"? This func is not supposed to fail.
+   */
+
+  if (format != XINE_IMGFMT_YV12 &&
+      format != XINE_IMGFMT_YUY2 &&
+      format != XINE_IMGFMT_VIA) {
+    	// Wrong format, we shall do nothing, then we will be able to display some still frame, etc.
+   	xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: format not supported.\n");
+   	 frame->vo_frame.format = 0;  // Reset format, good?
+    	return;
+  }
+
+  /* Let's be avid for memory.
+   * We will only re-allocate buffer to increase it's size and 
+   *   free all at dispose time.
+   * Change:
+   * Now we will re-create surface every time frame size changes.
+   *   Surface size will always be in the exact size required.
+   */
+
+  // (Re-)allocate surface.
+  {
+    uint32_t surface_format = (this->use_NV12_for_YV12 ?
+			       (format == XINE_IMGFMT_YV12 ? XINE_IMGFMT_YUY2 : format):
+			       format);
+
+    pthread_mutex_lock(&(this->config_lock));
+    
+    if (width  != this->surf_width  ||
+	height != this->surf_height ||
+	stream->last_video_decoder_streamtype!=stream->video_decoder_streamtype||
+	!cle266_check_format_match(this,format)) {
+	
+     stream->last_video_decoder_streamtype=stream->video_decoder_streamtype;
+      this->waitting_for_video_img = 1;
+      // Hide video output here, show when we have things to display.
+      cle266_clean_output_area(this);
+      cle266_update_overlay(this);  // OK, HIDE with the correct format.
+      this->delivered=0;
+      
+      // Destroy old surface. Operation order is important.
+      if (this->config_FourCC == XINE_IMGFMT_VIA) {
+	// If do accel, there is always the subpic surf. Turn off blending, reset this->subp_on flag, destroy surface.
+	VIASUBPICT sub_p;
+	unsigned int ret;
+
+	sub_p.dwTaskType = VIA_TASK_SP_DISPLAY_DISABLE;
+	//ret = VIASUBPicture((void*)&sub_p);
+	ret=VMI_DriverProc(this->p_vmi_info, SUBPICTURE, (void *)&sub_p, NULL);
+	if (ret != VMI_OK)
+	     xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: update_frame_format: turn off blending: failed to turn off the sub-picture.\n");
+
+	this->subp_on = 0;
+	cle266_unmap_and_destroy_surface(this,FOURCC_SUBP);
+      }
+      cle266_unmap_and_destroy_surface(this,this->config_FourCC);
+
+      // Create new surface.
+      switch (surface_format) {
+      case XINE_IMGFMT_YV12:
+      case XINE_IMGFMT_YUY2:
+	cle266_create_and_lock_surface(this,surface_format,width,height);
+	// ! ToDo: Check for fail.
+	break;
+      case XINE_IMGFMT_VIA:
+	{
+	  // MPEG2 surface.
+	  DDSURFACEDESC  SurfaceDesc;
+	  uint32_t       ret;
+	  int i;
+
+	  SurfaceDesc.dwWidth              = width;
+	  SurfaceDesc.dwHeight             = height;
+	  SurfaceDesc.dwBackBufferCount    = NUM_MPEG2_ACCEL_SURFS - 1;
+	  SurfaceDesc.dwFourCC             = XINE_IMGFMT_VIA;  
+	  ret = VMI_DriverProc(this->p_vmi_info,CREATESURFACE, (unsigned long *)&SurfaceDesc,NULL);
+	  if (ret != VMI_OK) {
+	      xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: update_frame_format: failed to create VIA MPEG surface.\n");
+	    // ! ToDo: What if failed?
+	  }
+	  
+	  // Sub-picture surface and related info.
+	  cle266_create_and_lock_surface(this,FOURCC_SUBP,width,height);
+
+	  // There will be garbage in subpicture surface, clean up the surface.
+	  //zhaolin:
+	  for (i = 0;i<height;i++)
+	  {
+	  	if(this->subp_surf)
+	      memset((void *)(this->subp_surf + this->subp_pitch * i),
+		       0,(size_t)width);
+		}
+
+	  // Here we shall clean up all rect info.
+	  memset(this->subp_list,0,sizeof(rect) * 100);
+	  this->cur_rect_entry  = 0;
+	  this->subp_data_empty = 1;
+	}
+	break;
+      }
+      // Assume succeed here. Then update internal info.
+      this->surf_width    = width;
+      this->surf_height   = height;
+      this->config_FourCC = surface_format;  // config_FourCC is always the same as surface format.
+    }
+
+    pthread_mutex_unlock(&(this->config_lock));
+  }
+
+  // ToDo: is the calculation correct?
+  {
+    unsigned int total_size = 0;
+    unsigned int buf_w,buf_h;
+
+    switch (format) {
+      /* Here we must update bases and pitches
+       *   for every frame, ot there can be cases that
+       *   bases and pitches are not changed.
+       * For example:
+       *   1, Video width increased but height decreased,
+       *      and no more buffer is neededbut the pitch
+       *      and base  must be updated.
+       *   2, Change from a large YUV2 to a small YV12.
+       */
+    case XINE_IMGFMT_YV12:
+    	 {
+    	 	/*Modified;DaveLiu, [5/30/2006],make blend_buf_base address aligned to 16 then ap can run on 64bit OS*/
+              
+              frame->vo_frame.pitches[0] = 8*((width + 7) / 8);
+              frame->vo_frame.pitches[1] = 8*((width + 15) / 16);
+              frame->vo_frame.pitches[2] = 8*((width + 15) / 16);
+              total_size = frame->vo_frame.pitches[0] * height+frame->vo_frame.pitches[1] * ((height+1)/2)*2;
+/*Joyce  20060627, Play wmv9 and h264 continuously, when h264 begin to play, the total size < frame->buf_size, 
+but the frame format change from  YUY2 to YV12, at this time, vo_frame.base still needs reallocing */
+            if (total_size > frame->buf_size ||!frame->vo_frame.base[0] ||!frame->vo_frame.base[1] || !frame->vo_frame.base[2] ) 
+            {
+		   if(frame->chunk[0]){
+		   	 free(frame->chunk[0]);
+			 frame->chunk[0] = NULL;
+		   }
+		   if(frame->chunk[1]) {
+		   	 free(frame->chunk[1]);
+		   	 frame->chunk[1] = NULL;
+		   }
+		   if(frame->chunk[2]){
+		   	 free(frame->chunk[2]);
+			 frame->chunk[2] = NULL;	
+		    }
+
+                  frame->vo_frame.base[0] = xine_xmalloc_aligned(16, frame->vo_frame.pitches[0] * height, (void **)&frame->chunk[0]);
+                  frame->vo_frame.base[1] =xine_xmalloc_aligned(16, frame->vo_frame.pitches[1] * ((height+1)/2), (void **)&frame->chunk[1]);
+                  frame->vo_frame.base[2] =xine_xmalloc_aligned(16, frame->vo_frame.pitches[2] *((height+1)/2),(void **)&frame->chunk[2]);
+		    
+              }
+          }
+
+      break;
+    case XINE_IMGFMT_YUY2:
+           /*Modified;DaveLiu, [5/30/2006],make blend_buf_base address aligned to 16 then ap can run on 64bit OS*/
+    	{
+    	    
+    	    frame->vo_frame.pitches[0] = 8 * ((width + 3) / 4);
+    	    total_size = frame->vo_frame.pitches[0] *height;
+           if (total_size > frame->buf_size)
+    	        frame->vo_frame.base[0] = xine_xmalloc_aligned(16, frame->vo_frame.pitches[0] *height,(void **)&frame->chunk[0]);
+    	}
+       frame->vo_frame.base[1] = frame->vo_frame.base[2] = NULL;
+    	frame->chunk[1]=frame->chunk[2]=NULL;
+      break;
+    case XINE_IMGFMT_VIA:  // Nothing to do ... use a sub-picture buffer and (re-)allocate it here?
+      break;
+    }
+
+    // Don't forget this.
+    frame->buf_size = total_size;
+  }
+  
+  // We get the frame, update frame info.
+  {
+    frame->vo_frame.format = format;
+  }
+
+  return;
+}
+
+
+/*
+ * This func get current frame from video out to img, the format of img is  XINE_IMGFMT_YV12,
+ * the order isn't yvu, but yuv for accordance with xine_get_current_frame.
+ *  This func  is used for snapshot. 
+ * return 
+ * 	1: succeed
+ * 	0: fail
+ */
+static int cle266_get_last_frame_from_hw(vo_driver_t *this_gen, uint8_t *img, int width, int height) 
+{
+	cle266_driver_t  *this = (cle266_driver_t *) this_gen;
+	unsigned long imgformat;
+	uint32_t ret = VMI_OK;
+	ret = VMI_DriverProc(this->p_vmi_info,SNAPSHOT,(void *)img, &imgformat);
+	if (ret != VMI_OK) {
+       	xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: get current frame failed: %d\n",ret);
+		return 0;
+	}	
+  
+	if(!img)
+		return 0;
+
+	uint8_t  *puv =(uint8_t *) malloc(width*height/2); //tmp buffer to store uv.
+	uint8_t  *pu =img + width*height;  //point to img to store u. 
+	uint8_t  *pv  = img + width*height+width*height/4;  //point to img to store v.
+	memcpy(puv,img+width*height,width*height/2);
+
+   	if(imgformat == FOURCC_NV12 ) {
+   		int i;
+		for (i=0;i<width*height/2;i++)  {
+			if(i%2)
+				*(pv++)=*(puv++);
+			else
+				*(pu++)=*(puv++);
+		}
+		free(puv-width*height/2);
+   	} else if(imgformat == FOURCC_YV12 ) {//reverse the order of uv in img.
+   		memcpy(pu, puv+width*height/4,width*height/4);
+   		memcpy(pv, puv,width*height/4);
+		free(puv);
+   	} else {
+		free(puv);
+   	}
+       return 1;
+  }
+
+/* This func will: 
+ *   1, get window geometry from ui.
+ *   2, If need redraw or forced to redraw, clean output area and setup overlay. No real redraw actually.
+ * This func runs in 3 threads: video decoder, vo_loop, ui.
+ */
+// ToDo: now the function itself will never redraw video output window, is this OK?
+static int cle266_redraw_needed (vo_driver_t *this_gen) {
+  cle266_driver_t  *this = (cle266_driver_t *) this_gen;
+  int ret = 0;
+  int redraw = 1;  // So we will calculate output size for every frame if we don't have the cb.
+
+  if( this->delivered ) {
+
+    this->sc.delivered_height = this->last_delivered_height;
+    this->sc.delivered_width  = this->last_delivered_width;
+    this->sc.delivered_ratio  = this->last_delivered_ratio;
+
+    _x_vo_scale_compute_ideal_size(&this->sc);
+    
+    if (this->sc.frame_output_cb)
+      redraw = _x_vo_scale_redraw_needed(&this->sc);
+
+    if( redraw ) {
+      // xv_compute_output_size (this);  // This is mainly for de-interlace.
+      _x_vo_scale_compute_output_size(&this->sc);  // Replace above with this one temporarily.
+
+      // Note: what if no delivered frame? The video output window will be drawn as full black?
+
+      ret = 1;
+       /*Joyce 20051107, in video_out_loop, there is check_redraw_needed operation, but colorkey won't update at that time. 
+       so use the flag this->redraw_needed  to keep the update info and udpate colorkey when displaying frame  */
+      this->redraw_needed = 1;
+    }
+
+  } else
+    ret = 1;  // No frames has been delivered, I don't know why redraw.
+
+  return ret;
+}
+
+/*  CopyYUV420To422 :
+ *  format from YUV420 to YUV422
+ *  YUV420 format in memory is Y, V, U 3 planar mode
+ *  YUV422 is Y0 U0 Y1 V0
+ *            low ....High byte
+ */
+static void CopyYUV420To422(
+    unsigned char* src1,    /* Y */
+    unsigned char* src2,    /* V */
+    unsigned char* src3,    /* U */
+    unsigned char* dst1,
+    int srcPitch,
+    int srcPitch2,
+    int dstPitch,
+    int h,
+    int w )
+{
+    unsigned long *dst = (unsigned long*)dst1;
+    int i, j;
+
+    dstPitch >>= 2;
+    w >>= 1;
+
+    for(j = 0; j < h; j++) {
+         for(i = 0; i < w; i++) {
+             dst[i] = src1[i << 1] | (src1[(i << 1) + 1] << 16) |
+                      (src3[i] << 8) | (src2[i] << 24);
+         }
+         dst += dstPitch;
+         src1 += srcPitch;
+         if(j & 1) {
+             src2 += srcPitch2;
+             src3 += srcPitch2;
+         }
+    }
+}
+
+
+/* !! One set of overlay_begin->overlay_blend->overlay_end->display
+ *     shall be done with the same frame.
+ * ToDo: time stamp style flag can be added to frame to check, not necessary.
+ */
+
+static void cle266_display_frame (vo_driver_t *this_gen, vo_frame_t *frame_gen) {
+
+  cle266_driver_t  *this  = (cle266_driver_t *) this_gen;
+  cle266_frame_t   *frame = (cle266_frame_t *)  frame_gen;
+  int redraw_needed = 0;
+
+  if (!this || !frame)
+    return;
+
+  
+  if(frame->vo_frame.format == XINE_IMGFMT_VIA){
+  	 
+  	if (frame->vmi_accel_data.decoded_ok==0){
+		 frame->vo_frame.free((vo_frame_t *)frame);
+    		return;
+  	}
+  		
+  	if (frame->vmi_accel_data.decoded_ok==2)
+		frame->vmi_accel_data.decoded_ok=0;
+  }
+  
+  	
+  if (!this->delivered)
+    this->sc.force_redraw = 1;  // To draw the initial colorkey.
+
+  /*
+   * tell gui that we are about to display a frame,
+   * ask for offset and output size.
+   */
+  redraw_needed = cle266_redraw_needed (this_gen);
+
+  this->delivered = 1;
+  this->last_delivered_height = frame->vo_frame.height;
+  this->last_delivered_width  = frame->vo_frame.width;
+  this->last_delivered_ratio  = frame->vo_frame.ratio;
+  // ... The surface will keeps on screen until next frame comes to VO.
+
+  
+  /*
+   * let's see if this frame is different in size / aspect
+   * ratio from the previous one
+   */
+  if ( (frame->vo_frame.width != this->sc.delivered_width)
+       || (frame->vo_frame.height != this->sc.delivered_height)
+       || (frame->vo_frame.ratio != this->sc.delivered_ratio) ) {
+
+    lprintf("video_out_vmi: frame format changed\n");
+
+    this->sc.force_redraw = 1;    /* trigger re-calc of output size */
+  }
+
+  /*
+   * deinterlace frame if necessary
+   * (currently only working for YUV images)
+   *
+   *  if (this->deinterlace_enabled && this->deinterlace_method
+   *      && frame->format == XINE_IMGFMT_YV12
+   *      && deinterlace_yuv_supported( this->deinterlace_method ) == 1)
+   *    xv_deinterlace_frame (this);
+   */
+
+  // FixMe: Shall we do size round up for software decoded video below?
+
+  // Now config related part.
+  pthread_mutex_lock(&(this->config_lock));
+  if (cle266_check_format_match(this,frame->vo_frame.format) &&
+      (frame->vo_frame.width == this->surf_width &&
+       frame->vo_frame.height == this->surf_height)) {
+    VMI_FLIP_PARAM vmi_flip;
+    uint32_t ret = VMI_OK;
+
+  /*Joyce 20051212, this->waitting_for_video_img will be set as 1 when updating frame format, which 
+  will disable colorkey setting. So set redraw_needed as 1 to draw colorkey when 1st frame shows */
+    if(this->waitting_for_video_img)
+    	 this->redraw_needed = 1;  
+     // Prepare for show.
+    this->waitting_for_video_img = 0;
+    // Can we do flip before show??
+
+    switch (frame->vo_frame.flags & 0x3) {  // Picture structure?
+    case VO_TOP_FIELD:
+      vmi_flip.dwDisplayPictStruct = VIA_PICT_STRUCT_TOP;
+      break;
+    case VO_BOTTOM_FIELD:
+      vmi_flip.dwDisplayPictStruct = VIA_PICT_STRUCT_BOTTOM;
+      break;
+    case VO_BOTH_FIELDS:
+      vmi_flip.dwDisplayPictStruct = VIA_PICT_STRUCT_FRAME;
+      break;
+    }
+
+    // We shall be able to display this. Format match and valid in switch() ...
+    // But we need to check if surface size matches for sw decoded video.
+    switch (this->config_FourCC) {
+    case XINE_IMGFMT_YV12:
+      {
+	int  i;
+	uint32_t  cp_w = (frame->vo_frame.width  + 1) & (~(uint32_t)0x1);
+	uint32_t  cp_h = (frame->vo_frame.height + 1) & (~(uint32_t)0x1);
+
+	if (this->blended &&
+	    this->blend_buf_base[0] &&
+	    this->blend_buf_size >= frame->buf_size) {  // Use the blended picture.
+	  for (i = 0; i < cp_h; i++)
+	    xine_fast_memcpy((this->overlay_surf[this->cur_overlay_surf][0] + this->overlay_pitches[0] * i),
+		   (this->blend_buf_base[0] + this->blend_buf_pitches[0] * i),
+		   cp_w);
+	  for (i = 0; i < cp_h / 2; i++)
+	    xine_fast_memcpy(this->overlay_surf[this->cur_overlay_surf][1] + this->overlay_pitches[1] * i,
+		   this->blend_buf_base[1] + this->blend_buf_pitches[1] * i,
+		   cp_w / 2);
+	  for (i = 0; i < cp_h / 2; i++)
+	    xine_fast_memcpy(this->overlay_surf[this->cur_overlay_surf][2] + this->overlay_pitches[2] * i,
+		   this->blend_buf_base[2] + this->blend_buf_pitches[2] * i,
+		   cp_w / 2);
+	} else {  // Use the original picture.
+	  for (i = 0; i < frame->vo_frame.height; i++)
+	    xine_fast_memcpy((this->overlay_surf[this->cur_overlay_surf][0] + this->overlay_pitches[0] * i),
+		   (frame->vo_frame.base[0] + frame->vo_frame.pitches[0] * i),
+		   cp_w);
+	  for (i = 0; i < frame->vo_frame.height / 2; i++)
+	    xine_fast_memcpy(this->overlay_surf[this->cur_overlay_surf][1] + this->overlay_pitches[1] * i,
+		   frame->vo_frame.base[1] + frame->vo_frame.pitches[1] * i,
+		   cp_w / 2);
+	  for (i = 0; i < frame->vo_frame.height / 2; i++)
+	    xine_fast_memcpy(this->overlay_surf[this->cur_overlay_surf][2] + this->overlay_pitches[2] * i,
+		   frame->vo_frame.base[2] + frame->vo_frame.pitches[2] * i,
+		   cp_w / 2);
+	}
+
+	vmi_flip.dwDisplayBuffIndex = this->cur_overlay_surf;
+	this->cur_overlay_surf = this->cur_overlay_surf ? 0 : 1;
+      }
+      break;
+    case XINE_IMGFMT_YUY2:  // We may be displaying YV12 format image here.
+      {
+	int  i,j;
+	
+	uint32_t  cp_w = (frame->vo_frame.width  + 1) & (~(uint32_t)0x1);
+	uint32_t  cp_h = (frame->vo_frame.height + 1) & (~(uint32_t)0x1);
+
+	if (this->blended &&
+	    this->blend_buf_base[0] &&
+	    this->blend_buf_size >= frame->buf_size) {  // Use the blended picture.
+
+	  if (frame->vo_frame.format == XINE_IMGFMT_YUY2) {
+	    for (i = 0; i < cp_h; i++)
+	      xine_fast_memcpy(this->overlay_surf[this->cur_overlay_surf][0] + this->overlay_pitches[0] * i,
+		     this->blend_buf_base[0] + this->blend_buf_pitches[0] * i,
+		     cp_w * 2);
+	  } else if (frame->vo_frame.format == XINE_IMGFMT_YV12) {
+	    
+	    CopyYUV420To422(
+    		(unsigned char *)(this->blend_buf_base[0]),    /* Y */
+		(unsigned char *)(this->blend_buf_base[2]),    /* V */
+		(unsigned char *)(this->blend_buf_base[1]),    /* U */
+    		(unsigned char *)(this->overlay_surf[this->cur_overlay_surf][0]),
+		this->blend_buf_pitches[0],
+		this->blend_buf_pitches[1],
+    		this->overlay_pitches[0],
+		cp_h,
+		cp_w);
+	    
+	      }
+
+	} else {  // Use the original picture.
+	  if (frame->vo_frame.format == XINE_IMGFMT_YUY2) {
+	    for (i = 0; i < cp_h; i++)
+	      xine_fast_memcpy(this->overlay_surf[this->cur_overlay_surf][0] + this->overlay_pitches[0] * i,
+		     frame->vo_frame.base[0] + frame->vo_frame.pitches[0] * i,
+		     cp_w * 2);
+	  } else if (frame->vo_frame.format == XINE_IMGFMT_YV12) {
+	  	CopyYUV420To422(
+    		(unsigned char *)(frame->vo_frame.base[0]),    /* Y */
+		(unsigned char *)(frame->vo_frame.base[2]),    /* V */
+		(unsigned char *)(frame->vo_frame.base[1]),    /* U */
+    		(unsigned char *)(this->overlay_surf[this->cur_overlay_surf][0]),
+		this->blend_buf_pitches[0],
+		this->blend_buf_pitches[1],
+    		this->overlay_pitches[0],
+		cp_h,
+		cp_w);
+		    
+	  }
+	}
+
+	vmi_flip.dwDisplayBuffIndex = this->cur_overlay_surf;
+	this->cur_overlay_surf = this->cur_overlay_surf ? 0 : 1;
+      }
+      break;
+    case XINE_IMGFMT_VIA:
+      {
+	if (frame->vmi_accel_data.surf_id>=0)
+	  vmi_flip.dwDisplayBuffIndex = frame->vmi_accel_data.surf_id;
+	else {
+	  xprintf(this->xine,XINE_VERBOSITY_INFO,"video_driver_cle266: display_frame: FATAL no accel_surf for a MPEG surface.\n");
+	  vmi_flip.dwDisplayBuffIndex = 0;  // Safe bet?
+	}
+      }
+      break;
+    }
+
+
+    ret = VMI_DriverProc(this->p_vmi_info,FLIP,(void *)&vmi_flip,NULL);
+
+    if (ret != VMI_OK)
+      xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: display_frame: failed to do flip driver returned %d.\n",ret);
+  } else {
+    // This may happen during update frame format period, we are told to display old frames in queue.
+    xprintf(this->xine,XINE_VERBOSITY_INFO,"Format or size do not match, current config is: %8x, frame format is: %8x.\n",
+	     this->config_FourCC,frame->vo_frame.format);  // Place holer, we shall do some vo_window clean-up thing here.
+  }
+
+  cle266_update_overlay(this);
+
+  /*Joyce 20051107, in video_out_loop, there is check_redraw_needed operation, but colorkey won't update at that time. so update colorkey here */
+  if (redraw_needed || this->redraw_needed){
+  	cle266_clean_output_area(this);
+  	this->redraw_needed = 0;
+  }  	
+
+  this->blended = 0;
+  
+  pthread_mutex_unlock(&(this->config_lock));
+
+  /* Driver have to free the surface it displayed.
+   * Infact, the surface shall be freed by VO until next frame comes to avoid decoder get the frame and
+   *   write data into it then causing tearing artifact on HWOverlay.
+   * XINE is currently a SW only player until CLE266 comes in.
+   * The last_frame in VO will held the frame, doing the actual work mentioned above.
+   */
+  frame->vo_frame.free((vo_frame_t *)frame);
+}
+
+/* We will treat different frame format differently.
+ * But we will regard video_overlays as a thing lives all time when the player is up,
+ *   so flags are kept updated and we will reload subpicture data into device when switching
+ *   to acceleration mode.
+ * The config_lock is locked by begin() and unlocked by end(), blend() is called with the lock
+ *   being held by vo thread. The config will not change during the whole blending process.
+ */
+
+static void cle266_overlay_begin (vo_driver_t *this_gen, vo_frame_t *frame_gen, int changed) {
+
+  cle266_driver_t *this  = (cle266_driver_t *) this_gen;
+  cle266_frame_t  *frame = (cle266_frame_t *) frame_gen;
+
+  lprintf("Begin: %s.\n>",changed?"changed":"not changed");
+
+  if (!this || !frame)
+    return;
+
+  pthread_mutex_lock(&(this->config_lock));
+
+  if (cle266_check_format_match(this,frame->vo_frame.format)) {
+    this->have_subp = 0;
+    
+    switch (frame->vo_frame.format) {
+      // Note a buffer mjust have its own pitch calculated for itself.      
+    case XINE_IMGFMT_YV12:
+      {
+	this->blended = 1;
+	/*Modified;DaveLiu,[5/30/2006], make blend_buf_base address aligned to 16 then ap can run on 64bit OS*/
+      /*Joyce  20060627, Play wmv9 and h264 continuously, when h264 begin to play, the total size < frame->buf_size, 
+but the frame format change from  YUY2 to YV12, at this time, vo_frame.base still needs reallocing */
+       if ((this->blend_buf_size < frame->buf_size &&
+	    frame->buf_size)||!this->blend_buf_base[0]||!this->blend_buf_base[1]||!this->blend_buf_base[2])
+	{
+              if(this->chunk[0]) {
+			 free(this->chunk[0]);
+			 this->chunk[0] = NULL;
+              }
+
+               if(this->chunk[1]) {
+			 free(this->chunk[1]);
+			 this->chunk[1] = NULL;
+               }
+
+              if(this->chunk[2]) {
+			 free(this->chunk[2]);
+			 this->chunk[2] = NULL;
+              }                            
+             
+           
+              this->blend_buf_pitches[0]= frame->vo_frame.pitches[0];
+              this->blend_buf_pitches[1] = frame->vo_frame.pitches[1];
+              this->blend_buf_pitches[2] =frame->vo_frame.pitches[2];
+              this->blend_buf_base[0] = xine_xmalloc_aligned(16, this->blend_buf_pitches[0] * frame->vo_frame.height, (void **)&this->chunk[0]);
+              this->blend_buf_base[1] =xine_xmalloc_aligned(16, this->blend_buf_pitches[1] * ((frame->vo_frame.height+1)/2), (void **)&this->chunk[1]);
+              this->blend_buf_base[2] =xine_xmalloc_aligned(16, this->blend_buf_pitches[2] *((frame->vo_frame.height+1)/2),(void **)&this->chunk[2]);
+              
+              this->blend_buf_size    = frame->buf_size;
+              if (!this->blend_buf_base[0]||!this->blend_buf_base[1]||!this->blend_buf_base[2]) {
+	            xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: overlay_begin: failed to alloc buffer.\n");
+	            this->blend_buf_size = 0;
+	            this->blended = 0;
+	       }
+          }
+	if (this->blended) {
+	  int i;
+	  uint32_t  cp_w = (frame->vo_frame.width  + 1) & (~(uint32_t)0x1);
+	  uint32_t  cp_h = (frame->vo_frame.height + 1) & (~(uint32_t)0x1);
+
+	  for (i=0;i<cp_h;i++)
+	    xine_fast_memcpy(this->blend_buf_base[0] + this->blend_buf_pitches[0] * i,
+		   frame->vo_frame.base[0] + frame->vo_frame.pitches[0] * i,
+		   cp_w);
+	  for (i=0;i<cp_h/2;i++)
+	    xine_fast_memcpy(this->blend_buf_base[1] + this->blend_buf_pitches[1] * i,
+		   frame->vo_frame.base[1] + frame->vo_frame.pitches[1] * i,
+		   cp_w/2);
+	  for (i=0;i<cp_h/2;i++)
+	    xine_fast_memcpy(this->blend_buf_base[2] + this->blend_buf_pitches[2] * i,
+		   frame->vo_frame.base[2] + frame->vo_frame.pitches[2] * i,
+		   cp_w/2);
+	}
+      }
+      break;
+    case XINE_IMGFMT_YUY2:
+      /*Modified;DaveLiu,[5/30/2006], make blend_buf_base address aligned to 16 then ap can run on 64bit OS*/
+      {
+	this->blended = 1;
+	
+	
+	this->blend_buf_pitches[0] = frame->vo_frame.pitches[0];
+	if (this->blend_buf_size < frame->buf_size&& frame->buf_size) 
+	{
+	    free(this->chunk[0]);
+           this->blend_buf_base[0] = xine_xmalloc_aligned(16, this->blend_buf_pitches[0] *frame->vo_frame.height,(void **)&this->chunk[0]);
+           this->blend_buf_size    = frame->buf_size;
+           if (!this->blend_buf_base[0])
+           {
+	        xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: overlay_begin: failed to alloc buffer.\n");
+	        this->blend_buf_size = 0;
+	        this->blended = 0;
+	    }
+    	}
+	this->blend_buf_base[1] = this->blend_buf_base[2] = NULL;
+	this->chunk[1]=this->chunk[2]=NULL;
+	this->blend_buf_pitches[1] = this->blend_buf_pitches[2] = 0;
+	if (this->blended) {
+	  int i;
+	  uint32_t  cp_w = (frame->vo_frame.width  + 1) & (~(uint32_t)0x1);
+	  uint32_t  cp_h = (frame->vo_frame.height + 1) & (~(uint32_t)0x1);
+
+	  for (i=0;i<cp_h;i++)
+	    xine_fast_memcpy(this->blend_buf_base[0] + this->blend_buf_pitches[0] * i,
+		   frame->vo_frame.base[0] + frame->vo_frame.pitches[0] * i,
+		   cp_w * 2);
+	}
+      }
+      break;
+    case XINE_IMGFMT_VIA:
+      if (changed) {  // Clear the surface in frame buffer, only on really change of sub-picture.
+	cle266_clean_subp_surface(this);
+	this->subp_data_empty = 1;
+      }
+      
+      break;
+    }
+  }
+  return;
+}
+
+static void cle266_overlay_end (vo_driver_t *this_gen, vo_frame_t *frame_gen) {
+
+  cle266_driver_t *this  = (cle266_driver_t *) this_gen;
+  cle266_frame_t  *frame = (cle266_frame_t *) frame_gen;
+
+  if (!this || !frame)
+    return;
+
+  if (cle266_check_format_match(this,frame->vo_frame.format)) {
+
+    switch (frame->vo_frame.format) {
+      
+    case XINE_IMGFMT_YV12:
+      // Nothing to do.
+      break;
+    case XINE_IMGFMT_YUY2:
+      // Nothing to do.
+      break;
+    case XINE_IMGFMT_VIA:
+      {
+	VIASUBPICT sub_p;
+	unsigned int ret;
+
+	if (this->have_subp && this->subp_data_empty) { // We just did a subp_data build and load, need to update.
+	  int i;
+	  unsigned int y,cr,cb;
+	  clut_t   *color = (clut_t *)(this->palette);
+	  for (i = 0;i<16;i++) {
+	    cr = color[i].cr;
+	    cb = color[i].cb;
+	    y  = color[i].y;
+	    sub_p.dwRamTab[i] = cr << 16 | cb << 8 | y;
+	  }
+	  
+	  sub_p.dwTaskType = VIA_TASK_SP_RAMTAB;
+	  
+	  //ret = VIASUBPicture((void*)&sub_p);
+	  ret=VMI_DriverProc(this->p_vmi_info, SUBPICTURE, (void *)&sub_p, NULL);
+	  if (ret != VMI_OK) {
+	    if (this->xine->verbosity >= XINE_VERBOSITY_INFO)
+	      printf("video_out_cle266: overlay_end: failed to set the subpicture palette.\n");
+	  }
+	}
+      
+	if ((this->have_subp != this->subp_on) ||
+	    (this->have_subp && this->subp_data_empty)) {
+	  // Change the on/off status or update blending parameter. Update is specially for always have subp condition.
+	  // Note subp_on is 0 after open_plugin and subpicture is not enabled in device.
+	
+	  sub_p.dwTaskType         = this->have_subp ? VIA_TASK_SP_DISPLAY : VIA_TASK_SP_DISPLAY_DISABLE;
+	  sub_p.dwDisplayBuffIndex = 0;  // Now using fixed single buffer. Blend whole surface to video.
+	  sub_p.dwSPTop              = this->subp_list[0].top;
+	  sub_p.dwSPLeft             = this->subp_list[0].left;
+	  sub_p.dwSPWidth            = this->subp_list[0].right - this->subp_list[0].left + 1;
+	  sub_p.dwSPHeight           = this->subp_list[0].bottom - this->subp_list[0].top + 1;
+	  //ret = VIASUBPicture((void*)&sub_p);
+	  /*zhaolinwang[2006.01.13]:replace all VIASUBPicture with VMI_DriverProc(this->p_vmi_info, SUBPICTURE,
+	  for VIASUBPicture((void*)&sub_p) can not send the handle of ap to driver. it would cause bug in
+	  two stream */
+	  ret=VMI_DriverProc(this->p_vmi_info, SUBPICTURE, (void *)&sub_p, NULL);
+	  if (ret != VMI_OK) {
+	    if (this->xine->verbosity >= XINE_VERBOSITY_INFO)
+	      printf("video_out_cle266: overlay_end: failed to %s the sub-picture.\n",
+		     this->have_subp ? "display" : "close");
+	  }
+	  this->subp_on = this->have_subp;
+	}
+
+	if (this->have_subp)
+	  this->subp_data_empty = 0;
+
+	break;
+      }
+    }
+  } else {   // If frame format match.
+    this->blended = 0;
+  }
+
+  pthread_mutex_unlock(&(this->config_lock));
+
+}
+static void cle266_osd_unscale_blend(vo_driver_t *this_gen,vo_overlay_t *overlay){
+	cle266_driver_t *this  = (cle266_driver_t *) this_gen;
+	uint32_t rgb=0;
+ 	int bytes_pix=0;
+  	via_alphablending_interface_t *internal_alpha_blend;
+	if(overlay->osd_status&OSD_SHOWN)return;
+	bytes_pix=this->screen_depth/8;
+  	if(overlay->osd_type==OSD_ALPHA)
+  	 	internal_alpha_blend=cle266_get_special_interface(this_gen,"VIAUniChromeAlpha");
+  	if(overlay->osd_status&OSD_TO_HIDE)
+	{
+  		if(overlay->osd_type==OSD_ALPHA)
+			cle266_draw_constant_alpha(internal_alpha_blend,0xFF,overlay->width, overlay->height,overlay->y, overlay->x);
+		overlay->old_x=0;
+		overlay->old_y=0;
+		overlay->old_width=0;
+		overlay->old_height=0;
+		return;
+	}
+	if(overlay->old_width&&overlay->old_height)
+	{
+		if(overlay->osd_type==OSD_ALPHA)
+			cle266_draw_constant_alpha(internal_alpha_blend,0xFF,overlay->old_width, overlay->old_height,overlay->old_y, overlay->old_x);
+		write_fb_direct(overlay->old_x,overlay->old_y, overlay->old_width, overlay->old_height,this->video_on_snd, NULL);
+	}
+	overlay->osd_status=OSD_SHOWN;
+	if(overlay->osd_type==OSD_ALPHA)
+	{
+		uint8_t *dest_fb=malloc(overlay->width*overlay->height*bytes_pix);
+  		memset(dest_fb,0,overlay->width*overlay->height*bytes_pix);
+  		copy_alphaosd_to_fb(overlay,dest_fb,this->screen_depth ,this->video_on_snd);
+		switch(this->screen_depth)
+		{
+			case 16:
+			cle266_generate_draw_bin_alpha(internal_alpha_blend,
+				  VIA_PIX_FMT_BGR555, dest_fb,
+				  overlay->width*2, overlay->height,
+				  overlay->width, overlay->height,
+				  0,    0,
+				  overlay->y, overlay->x,
+				  0x0,0x0,
+				  0x0,
+				  0xFF,
+				  IGNORE_ALHPA);
+			break;
+			case 24:
+			cle266_generate_draw_bin_alpha(internal_alpha_blend,
+				  VIA_PIX_FMT_BGR24, dest_fb,
+				  overlay->width*3, overlay->height,
+				  overlay->width, overlay->height,
+				  0,    0,
+				  overlay->y, overlay->x,
+				  0x0,0x0,
+				  0x0,
+				  0xFF,
+				  IGNORE_ALHPA);
+			break;
+			case 32:
+			cle266_generate_draw_bin_alpha(internal_alpha_blend,
+				  VIA_PIX_FMT_RGBA32, dest_fb,
+				  overlay->width*4, overlay->height,
+				  overlay->width, overlay->height,
+				  0,    0,
+				  overlay->y, overlay->x,
+				  0x0,0x0,
+				  0x0,
+				  0xFF,
+				  IGNORE_ALHPA);
+			break;
+		}
+		cle266_set_surf_controlled_alpha(internal_alpha_blend,1,0,0);
+		free(dest_fb);
+		return;
+	}
+	else if(overlay->osd_type==OSD_COLORKEY_PRI
+	||overlay->osd_type==OSD_COLORKEY_SND)
+	{
+		copy_colorkeyosd_to_fb(overlay,this->screen_depth ,this->video_on_snd);
+		return;
+	}
+}
+
+// Note that there is the possibility that this function is not called at all.
+static void cle266_overlay_blend (vo_driver_t *this_gen,
+				  vo_frame_t *frame_gen,
+				  vo_overlay_t *overlay) {
+
+  cle266_frame_t  *frame = (cle266_frame_t *) frame_gen;
+  cle266_driver_t *this  = (cle266_driver_t *) this_gen;
+
+  if (!this || !frame || !overlay)
+    return;
+  /*unscaled overlay start-dave*/
+  if(overlay->osd_type!=OSD_ORI)
+  {	
+	cle266_osd_unscale_blend(this_gen,overlay);
+	return;
+  }
+
+/* end*/
+
+  if (cle266_check_format_match(this,frame->vo_frame.format)) {
+    if (overlay->rle) {
+      // Actually have things to draw.
+      this->have_subp = 1;
+
+      switch (frame->vo_frame.format) {
+      case XINE_IMGFMT_YV12:
+	if (this->blended &&
+	    this->blend_buf_base[0] &&
+	    this->blend_buf_size >= frame->buf_size)
+	  blend_yuv(this->blend_buf_base,
+		    overlay,
+		    frame->vo_frame.width, frame->vo_frame.height,
+		    this->blend_buf_pitches,
+		    &this->alphablend_extra_data);
+	break;
+      case XINE_IMGFMT_YUY2:
+	if (this->blended &&
+	    this->blend_buf_base[0] &&
+	    this->blend_buf_size >= frame->buf_size)
+	  blend_yuy2(this->blend_buf_base[0],
+		     overlay,
+		     frame->vo_frame.width, frame->vo_frame.height,
+		     this->blend_buf_pitches[0],
+		     &this->alphablend_extra_data);
+	break;
+      case XINE_IMGFMT_VIA:
+	//int draw = this->subp_changed || this->OSD_pixel_changed;  OSD is not considered now.
+	if (this->subp_data_empty) {
+	  int i;
+	  
+	  // Register rect for clean up, for OSD_pixel_change no need to do this.
+	  if (cle266_register_subp_rectangle(this,
+					     overlay->y,
+					     overlay->y + overlay->height -1,
+					     overlay->x,
+					     overlay->x + overlay->width -1))
+	    return;
+	  
+	  // Build palette here, note cle266_draw_ia44 code shall modify pixel value accoring to this.
+	  if (overlay->osd_overlay) {  // OSD will use palette entry 8-15 for now.
+	    // FixMe: Here we assume OSD have no clip area.
+/*Joyce 20060509. keep xine_text_palettte mechanism unchanged. just copy font color (foreground) to hw palette*/
+		int k;
+	       this->palette[8]= overlay->color[0];  /*0: not used by font, always transparent*/
+		/*set  font color (foreground) such as 10, 21, 32, 43... to hw palette*/
+	    	for(i=9;i<16;i++){
+	    	    k = (i-8)*XINE_TEXT_PALETTE_SIZE - 1;
+	           this->palette[i] = overlay->color[k];
+	    	}		
+	  } else {  // Sub-picture.
+	    for (i=0;i<4;i++)  // Normal color.
+	      this->palette[i] = overlay->color[i];
+	    for (;i<8;i++)  // High light color.
+	      this->palette[i] = overlay->hili_color[i-4];
+	  }
+
+	  // Draw it.
+	  cle266_draw_ia44(this,overlay);
+	}
+	break;
+      }  // switch (this->config_FourCC)
+    }  // if (overlay->rle) {
+  } else {  // If format matches.
+    this->blended = 0;
+  }
+  return;
+}
+
+// Runs in the GUI thread.
+static int cle266_gui_data_exchange (vo_driver_t *this_gen,
+				     int data_type, void *data) {
+
+  cle266_driver_t *this = (cle266_driver_t *) this_gen;
+
+  // ToDo: update overlay? Get needed lock?
+  // ToDo: to get the config_lock, there can be deadlock due to config_lock and XLockDisplay()
+
+  switch (data_type) {
+  case XINE_GUI_SEND_COMPLETION_EVENT:
+    break;
+
+  case XINE_GUI_SEND_EXPOSE_EVENT: {
+    this->sc.force_redraw = 1;
+    //pthread_mutex_lock(&this->config_lock);
+    cle266_redraw_needed((vo_driver_t *)this);
+    cle266_clean_output_area(this);
+    this->sc.force_redraw = 1;  // Temp fix, no lock here, screen can be drawn wrong, correct it ASAP.
+     //zhaolin:added for two stream play ,on top and on bottom
+    int do_the_op= 1;  // Shall really send command to driver.
+    static DDUPDATEOVERLAY  UpdateOverlay;
+    uint32_t  ret;
+
+    if (!this) {
+      lprintf("vo_driver_cle266: cle266_update_overlay: no instance.\n");
+      return;
+    }
+  
+    memset(&UpdateOverlay,0,sizeof(DDUPDATEOVERLAY));
+
+  // ToDo: clean up all code related to color key value, use property, config and generator function.
+  // ToDo: check if it's OK to call this function before any frame delivered. Check sc values.
+
+  if (!this->waitting_for_video_img &&
+      this->props[VO_PROP_OUTPUTENABLED].value) {  // Turn on.
+
+    lprintf("vo_driver_cle266: update overlay. source: top: %d, left: %d, width: %d, height: %d, target: top: %d, left: %d, width: %d, height: %d, window: (%d,%d).\n",
+	   this->sc.displayed_xoffset, this->sc.displayed_yoffset,
+	   this->sc.displayed_width, this->sc.displayed_height,
+	   this->sc.output_xoffset, this->sc.output_yoffset,
+	   this->sc.output_width, this->sc.output_height,
+	   this->sc.gui_win_x,this->sc.gui_win_y);
+
+    UpdateOverlay.rDest.left   = this->sc.output_xoffset + this->sc.gui_win_x;
+    UpdateOverlay.rDest.top    = this->sc.output_yoffset + this->sc.gui_win_y;
+    UpdateOverlay.rDest.right  = this->sc.output_xoffset + this->sc.gui_win_x + this->sc.output_width;
+    UpdateOverlay.rDest.bottom = this->sc.output_yoffset + this->sc.gui_win_y + this->sc.output_height;
+    
+    UpdateOverlay.rSrc.left    = 0; // Hw seems to have bug for non-zero value. this->sc.displayed_xoffset;
+    UpdateOverlay.rSrc.top     = 0; // this->sc.displayed_yoffset;
+    // Use frame->width,height may be better?
+    UpdateOverlay.rSrc.right   = this->last_delivered_width;  //this->sc.displayed_xoffset + this->sc.displayed_width;
+    UpdateOverlay.rSrc.bottom  = this->last_delivered_height; //this->sc.displayed_yoffset + this->sc.displayed_height;
+
+    UpdateOverlay.dwFourcc = this->config_FourCC;    
+    
+    if (this->props[VO_PROP_USECOLORKEY].value) {
+      UpdateOverlay.dwFlags = DDOVER_SHOW | DDOVER_KEYDEST;
+      UpdateOverlay.dwColorSpaceLowValue  = this->props[VO_PROP_COLORKEY ].value; //this->colorkey_low;
+      //UpdateOverlay.dwColorSpaceHighValue = this->colorkey_high;
+    } else {
+      UpdateOverlay.dwFlags = DDOVER_SHOW;
+      if(this->sc.output_on_snd)
+      	UpdateOverlay.dwFlags|=DDOVER_ON_SND;
+
+    }
+
+    if (UpdateOverlay.rDest.left   != this->overlay_status.rDest.left   ||
+	UpdateOverlay.rDest.top    != this->overlay_status.rDest.top    ||
+	UpdateOverlay.rDest.right  != this->overlay_status.rDest.right  ||
+	UpdateOverlay.rDest.bottom != this->overlay_status.rDest.bottom ||
+	UpdateOverlay.rSrc.left    != this->overlay_status.rSrc.left    ||
+	UpdateOverlay.rSrc.top     != this->overlay_status.rSrc.top     ||
+	UpdateOverlay.rSrc.right   != this->overlay_status.rSrc.right   ||
+	UpdateOverlay.rSrc.bottom  != this->overlay_status.rSrc.bottom  ||
+	UpdateOverlay.dwFourcc     != this->overlay_status.dwFourcc     ||
+	UpdateOverlay.dwFlags      != this->overlay_status.dwFlags      ||
+	UpdateOverlay.dwColorSpaceLowValue != this->overlay_status.dwColorSpaceLowValue) {
+      do_the_op = 1;
+    }
+  } else if (this->overlay_status.dwFlags != DDOVER_HIDE &&
+	     this->config_FourCC) {
+    /* The result from experiment is that the dwFourcc is mandatory or
+     *   we can't hide the overlay. this->config_FourCC is 0 when just
+     *   initialized.
+     */
+    UpdateOverlay.dwFlags = DDOVER_HIDE;
+    UpdateOverlay.dwFourcc = this->config_FourCC;
+    do_the_op = 1;
+  }
+
+  if (do_the_op) {
+
+    ret = VMI_DriverProc(this->p_vmi_info,UPDATEOVERLAY, (unsigned long *)&UpdateOverlay,NULL);
+    if (ret != VMI_OK) {
+       xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: cle266_update_overlay: Failed.\n");
+    } else {  // Update overlay done, update the status record.
+      this->overlay_status.rDest.left   = UpdateOverlay.rDest.left;
+      this->overlay_status.rDest.top    = UpdateOverlay.rDest.top;
+      this->overlay_status.rDest.right  = UpdateOverlay.rDest.right;
+      this->overlay_status.rDest.bottom = UpdateOverlay.rDest.bottom;
+      this->overlay_status.rSrc.left    = UpdateOverlay.rSrc.left;
+      this->overlay_status.rSrc.top     = UpdateOverlay.rSrc.top;
+      this->overlay_status.rSrc.right   = UpdateOverlay.rSrc.right;
+      this->overlay_status.rSrc.bottom  = UpdateOverlay.rSrc.bottom;
+      this->overlay_status.dwFourcc     = UpdateOverlay.dwFourcc;
+      this->overlay_status.dwFlags      = UpdateOverlay.dwFlags;
+      this->overlay_status.dwColorSpaceLowValue = UpdateOverlay.dwColorSpaceLowValue;
+    }
+  }
+ 
+    //end of zhaolin
+    //pthread_mutex_unlock(&this->config_lock);
+  }
+    break;
+
+  case XINE_GUI_SEND_DRAWABLE_CHANGED:
+#ifdef HAVE_X11
+    this->drawable = (Drawable) data;
+
+    XLockDisplay (this->display);
+    XFreeGC(this->display, this->gc);
+    this->gc = XCreateGC (this->display, this->drawable, 0, NULL);
+    XUnlockDisplay (this->display);
+    this->sc.force_redraw = 1;
+    //pthread_mutex_lock(&this->config_lock);
+    cle266_redraw_needed((vo_driver_t *)this);
+    cle266_clean_output_area(this);
+    this->sc.force_redraw = 1;  // Temp fix, no lock here, screen can be drawn wrong, correct it ASAP.
+    //pthread_mutex_unlock(&this->config_lock);
+#endif
+    break;
+
+  case XINE_GUI_SEND_TRANSLATE_GUI_TO_VIDEO:
+    {
+      int x1, y1, x2, y2;
+      x11_rectangle_t *rect = data;
+
+      _x_vo_scale_translate_gui2video(&this->sc, rect->x, rect->y,
+				   &x1, &y1);
+      _x_vo_scale_translate_gui2video(&this->sc, rect->x + rect->w, rect->y + rect->h,
+				   &x2, &y2);
+      rect->x = x1;
+      rect->y = y1;
+      rect->w = x2-x1;
+      rect->h = y2-y1;
+#if 0
+      /* onefield_xv divide by 2 the number of lines */
+      if (this->deinterlace_enabled
+          && (this->deinterlace_method == DEINTERLACE_ONEFIELDXV)
+          && (this->cur_frame->format == XINE_IMGFMT_YV12)) {
+        rect->y = rect->y * 2;
+        rect->h = rect->h * 2;
+      }
+#endif
+    }
+    break;
+
+  default:
+    return -1;
+  }
+
+  return 0;
+}
+
+static void cle266_dispose (vo_driver_t *this_gen) {
+
+  cle266_driver_t *this = (cle266_driver_t *) this_gen;
+
+
+  if (!this) {
+    lprintf("video_out_cle266: dispose: no instance passed in.\n");
+    return;
+  }
+
+#ifdef HAVE_X11
+  if (this->working_env == X && this->display && this->gc) {
+    XLockDisplay (this->display);
+    XFreeGC(this->display, this->gc);
+    XUnlockDisplay (this->display);
+  }
+#endif
+
+  // If we are in FB environment, close the devide file.
+  if (this->working_env == FB) {  // Sure fd device is open now.
+    close(this->fd);
+  }
+
+  // No need to destroy the mutex this->lock_config.
+
+  /* How to deal with recent frames?
+     if (this->deinterlace_frame.image) {
+     XLockDisplay (this->display);
+     dispose_ximage (this, &this->deinterlace_frame.shminfo,
+     this->deinterlace_frame.image);
+     XUnlockDisplay (this->display);
+     this->deinterlace_frame.image = NULL;
+     }
+
+     for( i=0; i < VO_NUM_RECENT_FRAMES; i++ )
+     {
+     if( this->recent_frames[i] )
+     this->recent_frames[i]->vo_frame.dispose
+     (&this->recent_frames[i]->vo_frame);
+     this->recent_frames[i] = NULL;
+     }
+  */
+
+  // Hide overlay. No lock, shall be OK.
+  this->props[VO_PROP_OUTPUTENABLED].value = 0;
+  cle266_update_overlay(this);
+
+  // Disable alhpa.
+  // Do these things before anything is destroyed, or there will be oops.
+  cle266_set_const_alpha_internal(this,0,0);
+  cle266_set_surf_controlled_alpha_internal(this,0,0,0);
+  if (this->alpha_surf)
+    cle266_unmap_and_destroy_surface(this,FOURCC_ALPHA);
+
+  // Free what we have allocated here, according to current config.
+  switch (this->config_FourCC) {
+  case XINE_IMGFMT_VIA:  // Trick to destroy the additional sub-picture surface.
+    xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: dispose: Destroying the VIA Sub-picture surface.\n");
+    cle266_unmap_and_destroy_surface(this,FOURCC_SUBP);
+  case XINE_IMGFMT_YV12:
+  case XINE_IMGFMT_YUY2:
+    xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: dispose: Destroying the %x surface.\n",this->config_FourCC);
+    cle266_unmap_and_destroy_surface(this,this->config_FourCC);
+    //case 0:  // '\0''\0''\0''\0' no surface existing.
+    //default:  // Shall not happen.
+  }
+
+    if(this->chunk[0])
+      free(this->chunk[0]);  // No problem if it's NULL.
+ if(this->chunk[1])
+      free(this->chunk[1]); 
+  if(this->chunk[2])
+      free(this->chunk[2]); 
+
+  /* Unlock macrovision resource if locked.
+   * It's better to simply unlock the resource wirh our macrovision info.
+   *   If we don't have the lock, we don't have the dwCPKey, unlock will fail,
+   *   this is more reliable.
+   * ToDo: reset all info, including propeties?
+   */
+  #ifdef HAVE_MV_LIB	// Horace Lan
+  VIAMV( UNLOCKMACROVISION,
+		 (void *)&(this->macrovision_info),
+		 NULL); // Horace Lan
+  #endif // Horace Lan
+  
+    _x_alphablend_free(&this->alphablend_extra_data);
+
+  free (this);
+}
+
+static vo_driver_t *open_plugin (video_driver_class_t *class_gen, const void *visual_gen) {
+
+  cle266_class_t       *class = (cle266_class_t *) class_gen;
+  via_visual_t         *visual,visual_struct;
+  config_values_t      *config;
+  cfg_entry_t          *entry;
+  cle266_driver_t      *this;
+#ifdef HAVE_X11
+  XColor                dummy;
+#endif
+  // NULL?
+  if (!class) {
+    lprintf("video_out_cle266: open_plugin: NULL argument passed in.\n");
+    return NULL;
+  }
+
+  // Compatible layer for different visual_ts.
+  visual = &visual_struct;
+  memset(visual,0,sizeof(via_visual_t));
+  switch (class->visual_data_type) {
+  case via:
+    {
+      via_visual_t *visual_via = (via_visual_t *)visual_gen;
+      if (visual_via) {
+	visual->visual_type     = visual_via->visual_type;
+	visual->display         = visual_via->display;
+	visual->screen          = visual_via->screen;
+	visual->d               = visual_via->d;
+	visual->dest_size_cb    = visual_via->dest_size_cb;
+	visual->frame_output_cb = visual_via->frame_output_cb;
+	visual->user_data       = visual_via->user_data;
+	visual->video_screen  = visual_via->video_screen;
+      }	else {
+	if (class->xine->verbosity >= XINE_VERBOSITY_INFO)
+	  printf("video_out_cle266: open_plugin: NULL via_visual_t pointer.\n");
+	return NULL;
+      }
+    }
+    break;
+  case xine_fb:
+    {
+      fb_visual_t *visual_fb = (fb_visual_t *)visual_gen;
+      if (visual_fb) {
+	visual->frame_output_cb = visual_fb->frame_output_cb;
+	visual->user_data       = visual_fb->user_data;
+      }
+      visual->visual_type = XINE_VISUAL_TYPE_FB;
+    }
+    break;
+  case xine_x11:
+    {
+      x11_visual_t *visual_x11 = (x11_visual_t *)visual_gen;
+      if (visual_x11) {
+	visual->visual_type     = XINE_VISUAL_TYPE_X11;
+	visual->display         = visual_x11->display;
+	visual->screen          = visual_x11->screen;
+	visual->d               = visual_x11->d;
+	visual->dest_size_cb    = visual_x11->dest_size_cb;
+	visual->frame_output_cb = visual_x11->frame_output_cb;
+	visual->user_data       = visual_x11->user_data;
+      } else {
+	  xprintf(class->xine,XINE_VERBOSITY_INFO,"class->video_out_cle266: open_plugin: NULL x11_visual_t pointer.\n");
+	  return NULL;
+      }
+    }
+    break;
+  }
+
+  /* For visual validity checking and visual type matching,
+   *   it's better done in the switch()
+   * Further consideration needed.
+   */
+
+  // Further clean-up needed.
+
+  config = class->config;
+
+  // First allocate the cle266_driver_s.
+  this = malloc (sizeof(cle266_driver_t));
+  if (!this) {
+    xprintf(class->xine,XINE_VERBOSITY_INFO,"video_out_cle266: open_plugin: malloc failed.\n");
+    return NULL;
+  }
+  memset (this, 0, sizeof(cle266_driver_t));  // => Every thing is 0 or NULL.
+
+  this->xine   = class->xine;
+  this->config = config;
+
+  this->p_vmi_info = &class->vmi_info;
+
+    _x_alphablend_init(&this->alphablend_extra_data, class->xine);
+
+  /* Capability stuff:YV12 and YUY2 is basic capability.
+   */
+  this->capabilities = VO_CAP_YV12 | VO_CAP_YUY2;
+
+  // Scale stuff. Do this here for further different sc handling in X and FB.
+  // vo_scale_init() allocates nothing.
+  _x_vo_scale_init (&this->sc, 1, 0, config );
+  this->sc.user_data         = visual->user_data;
+
+  // Then deal with different visual_types.
+  // ToDo: Support more visual types if we can.
+  switch (visual->visual_type) {
+    // Supported:
+  case XINE_VISUAL_TYPE_X11:
+
+    if (class->init_env != X ||
+	!visual->frame_output_cb ||
+	!visual->display ||
+	!visual->d) {  // The three pointers are mandatory.
+     		xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: open_plugin on X: visual type wrong.\n");
+	      cle266_dispose((vo_driver_t *)this);
+      		return NULL;
+    }
+
+    this->working_env = X;
+
+#ifdef HAVE_X11
+    // ToDo: Check validity of display, screen and drawable.
+    this->display  = visual->display;
+    this->screen   = visual->screen;
+    this->drawable = visual->d;
+
+    XLockDisplay (this->display);
+    this->gc       = XCreateGC (this->display, this->drawable, 0, NULL);
+    XAllocNamedColor (this->display,
+		      DefaultColormap(this->display, this->screen),
+		      "black", &this->black, &dummy);
+    {
+      Screen *scn = ScreenOfDisplay(this->display,this->screen);
+      this->screen_width  = XWidthOfScreen(scn);
+      this->screen_height = XHeightOfScreen(scn);
+    }
+    XUnlockDisplay (this->display);
+#endif
+
+    this->props[VO_PROP_USECOLORKEY].value = 1;  // We use color key under X.
+/*Jack 20060613 204MB has HW limitation, better set the color key value close to black */
+    this->props[VO_PROP_COLORKEY ].value = 8;
+  //  this->props[VO_PROP_COLORKEY ].value = 2000;
+    
+    this->sc.frame_output_cb   = visual->frame_output_cb;
+
+    break;
+  case XINE_VISUAL_TYPE_FB:
+
+    // ToDo: If we want to do more things, refer to vo_fb source file.
+
+    if (class->init_env != FB) {
+	xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: open_plugin on FB: visual type wrong.\n");
+	cle266_dispose((vo_driver_t *)this);
+       return NULL;
+    }
+
+    // Open the fb device here. Close in dispose.
+    {
+      char *device_name = "/dev/fb1";
+      this->fd = open(device_name, O_RDWR);
+      if(this->fd < 0) {
+		device_name = "/dev/fb0";
+		xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: open_plug_in on FB: FB device %s will be tried.\n",device_name);
+		this->fd = open(device_name, O_RDWR);
+      }
+      if(this->fd < 0) {
+		 xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: open_plugin on FB: failed to open FB device.\n");
+		cle266_dispose((vo_driver_t *)this);
+		return NULL;
+      }
+    }
+  
+    /*Before show video on second screen, check whether samm is up-Dave*/
+     if(visual->video_screen==SDK_VID_SND){
+     	if(ioctl(this->fd, VIAFB_GET_SAMM_INFO, &this->viafb_samm)>=0&&
+        	this->viafb_samm.samm_status==1)
+        	visual->video_screen=SDK_VID_SND;
+ 	else
+ 		visual->video_screen=SDK_VID_PRI;
+      } 
+     
+
+   
+   
+    // Get screen infos.
+    /*if SAMM is up, viafb driver will be called, or vesa will be call -Dave*/
+     if(visual->video_screen==SDK_VID_SND)
+     if(ioctl(this->fd, VIAFB_GET_RESOLUTION, &this->viafb_mode)<0){
+     	visual->video_screen=SDK_VID_PRI;
+ 	if (this->xine->verbosity >= XINE_VERBOSITY_INFO)
+ 	  printf("video_out_cle266: open_plugin on FB: failed to open SAMM mode.\n");
+     }
+     if(visual->video_screen!=SDK_VID_SND)
+ 	    if(!get_fb_var_screeninfo(this->fd, &this->fb_var) ||
+       		!get_fb_fix_screeninfo(this->fd, &this->fb_fix)) {
+		xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: open_plugin on FB: failed to get FB screen info.\n");
+      		cle266_dispose((vo_driver_t *)this);
+      		return NULL;
+    }
+    if(visual->video_screen!=SDK_VID_SND){
+	this->screen_width  = this->fb_var.xres;
+     	this->screen_height = this->fb_var.yres;
+     	this->video_on_snd=FALSE;
+     }else{
+	this->screen_width  = this->viafb_mode.xres_sec;
+	this->screen_height = this->viafb_mode.yres_sec;
+     	this->video_on_snd=TRUE;
+     }
+     this->sc.output_on_snd=this->video_on_snd;
+   
+     this->working_env = FB;
+
+    this->props[VO_PROP_USECOLORKEY].value = 0;  // By defaut we don't use color key under FB.
+
+    if (visual->frame_output_cb) {
+      this->sc.frame_output_cb = visual->frame_output_cb;
+    } else {
+         if(visual->video_screen!=SDK_VID_SND){
+         	this->sc.gui_width  = this->fb_var.xres;
+         	this->sc.gui_height = this->fb_var.yres;
+         }else{
+         	this->sc.gui_width  = this->viafb_mode.xres_sec;
+         	this->sc.gui_height = this->viafb_mode.yres_sec;
+         }
+
+      	this->sc.user_ratio = XINE_VO_ASPECT_AUTO;
+      	xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: no frame output call back for FB environment, using FullScreen mode. Screen size is %dX%d.\n",
+	      		 this->sc.gui_width,this->sc.gui_height);
+    }
+
+    break;
+    // Possibly supportable:
+  case XINE_VISUAL_TYPE_DFB:
+  case XINE_VISUAL_TYPE_GTK:
+  case XINE_VISUAL_TYPE_AA:
+    // Not supported:
+  case XINE_VISUAL_TYPE_PM:  /* used by the OS/2 port */
+  case XINE_VISUAL_TYPE_DIRECTX:
+  case XINE_VISUAL_TYPE_NONE:
+  default:
+    {
+	xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: open_plugin: invalid visual type.\n");
+      cle266_dispose((vo_driver_t *)this);
+      return NULL;
+    }
+  }
+
+  xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: open_plugin: screen size is %dx%d.\n",
+	   this->screen_width,this->screen_height);
+
+  this->overlay = NULL;
+
+  this->palette_changed = 1;  // So OSD will get a hw palette when DVDNav is not up and run.
+
+  this->overlay_status.dwFlags = DDOVER_HIDE;
+  this->redraw_needed = 0;
+  this->vo_driver.get_capabilities        = cle266_get_capabilities;
+  this->vo_driver.query_special_interface = cle266_query_special_interface;
+  this->vo_driver.get_special_interface   = cle266_get_special_interface;
+  this->vo_driver.alloc_frame             = cle266_allocate_frame;
+  this->vo_driver.update_frame_format     = cle266_update_frame_format;
+  this->vo_driver.overlay_begin           = cle266_overlay_begin;
+  this->vo_driver.overlay_blend           = cle266_overlay_blend;
+  this->vo_driver.overlay_end             = cle266_overlay_end;
+  this->vo_driver.display_frame           = cle266_display_frame;
+  this->vo_driver.get_property            = cle266_get_property;
+  this->vo_driver.set_property            = cle266_set_property;
+  this->vo_driver.get_property_min_max    = cle266_get_property_min_max;
+  this->vo_driver.gui_data_exchange       = cle266_gui_data_exchange;
+  this->vo_driver.dispose                 = cle266_dispose;
+  this->vo_driver.redraw_needed           = cle266_redraw_needed;
+  this->vo_driver.get_last_frame_from_hw = cle266_get_last_frame_from_hw;
+ 
+  
+  // Query device accel capability.
+  {
+    unsigned long mpeg_capability, overlay_capability, ret;
+	
+    // MPEG Decoding, etc.
+    ret = VMI_QueryHWCapability(HW_MPEG_Capability,(void *)&mpeg_capability);
+    if (ret == VMI_OK) {
+      if (mpeg_capability & HW_MPEG2_SLICE)
+		this->capabilities |= (mpeg_capability & HW_MPEG4_INUSED)  ? 0: VO_CAP_MPEG2_SLICE;// add by zepeng  for 2 stream hw+sw
+	if (mpeg_capability & HW_MPEG2_MC)
+	{
+		this->capabilities |= (mpeg_capability & HW_MPEG4_INUSED)  ? 0: VO_CAP_MPEG2_MC;
+		#ifdef HW_MPEG2_MC_Debug
+		fprintf(stderr, "video_out_vmi.c: MC capabiltiy:%d", this->capabilities);
+		#endif
+	}
+       if (mpeg_capability & HW_MPEG4_IDCT)
+		this->capabilities |=   (mpeg_capability & HW_MPEG2_INUSED) ? 0: VO_CAP_MPEG4_IDCT; // add by zepeng  for 2 stream hw+sw
+       if(mpeg_capability & HW_HDTV)
+       	this->capabilities |= (mpeg_capability & HW_MPEG4_INUSED)  ? 0: VO_CAP_HW_HDTV;// add by zepeng  for 2 stream hw+sw
+
+       this->props[VO_PROP_HW_MPEG_Capability].value=mpeg_capability; /*zhaolin[2005.9.27]:add property to judge if had the ability of PIP*/
+    }
+    else
+    {
+         xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: open_plugin failed.\n");
+	  cle266_dispose((vo_driver_t *)this);
+	  return NULL;
+     }
+    // Video processing.
+    ret = VMI_QueryHWCapability(HW_VID_Capability,(void *)&(this->video_capability));
+    if (ret != VMI_OK) {
+     	xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: failed to query hardware VID capability, turning off alpha blending functions.\n");
+      // ToDo: When this function is OK, use the correct path instead of the work around.
+      //this->video_capability = 0;  // Special interface don't exist, and alpha blender will not work.
+      // Work around: if we support MPEG4IDCT, we support ALPHA256.
+      this->video_capability = mpeg_capability & HW_MPEG4_IDCT ? HW_VID_ALPHA256 : HW_VID_ALPHA16;
+      cle266_dispose((vo_driver_t *)this);
+      return NULL;
+    } else {  // ToDo: clean up. 16 level and 256 level is mutually exclusive....
+      if (this->video_capability & HW_VID_ALPHA16)
+	  xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: device capability queried:\n%s","16 level alpha blending");
+      if (this->video_capability & HW_VID_ALPHA256)
+	  xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: device capability queried:\n%s","256 level alpha blending");
+    }
+    // Format supported by verlay for oftware decoded video.
+    // CN400 only support NV12. No driver query available, get by with this.
+    this->use_NV12_for_YV12 = mpeg_capability & HW_MPEG4_IDCT; /*keep this for used to driver before version 71*/
+    /*zhaolin[2006.07.10]: in the driver later than version 71, can query the capability of overlay.
+	overlay capability: HW_OVERLAY_YV12, HW_OVERLAY_NV12,HW_OVERLAY_YUY2*/
+    ret = VMI_QueryHWCapability(HW_OVERLAY_Capability,(void *)&overlay_capability);
+     if (ret == VMI_OK) 
+     {
+      	    this->use_NV12_for_YV12 = (overlay_capability&HW_OVERLAY_NV12)&&(!(overlay_capability&HW_OVERLAY_YV12));
+      }
+    else
+    {
+         xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: query hw overlay capability failed.\n");
+	/*  cle266_dispose((vo_driver_t *)this);
+	      return NULL;*/
+     }
+  }
+
+  cle266_set_surf_controlled_alpha_internal(this,0,0,0);  // Don't need surface if disabling.
+  cle266_set_const_alpha_internal(this,0,0);
+
+  // Properties stuff
+  /* We use 15 vo_frames for software decoded video, and we have
+   *   8 available surfaces for hardware decoded mpeg2 video.
+   */
+  this->props[VO_PROP_MAX_NUM_FRAMES].value = 15;
+  this->props[VO_PROP_MAX_NUM_FRAMES].min   = 15;
+  this->props[VO_PROP_MAX_NUM_FRAMES].max   = 15;
+  // Macrovision.
+  this->props[VO_PROP_MACROVISION_SUPPORTED].min   = 0;
+  this->props[VO_PROP_MACROVISION_SUPPORTED].max   = 1;
+  this->props[VO_PROP_MACROVISION].min   = 0;
+  this->props[VO_PROP_MACROVISION].max   = 3;
+  {
+    #ifdef HAVE_MV_LIB	// Horace Lan
+    unsigned long supported = 0;
+    VIAMV( CHECKMACROVISION,&supported,NULL); // Horace Lan
+    if (supported) {
+      unsigned long ret;
+      xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: Macrovision is supported.\n");
+      ret = VIAMV( LOCKMACROVISION,
+			   (void *)&(this->macrovision_info),
+			   NULL); // Horace Lan
+      if (ret == VMI_OK) {
+	this->props[VO_PROP_MACROVISION_SUPPORTED].value = 1;
+	this->props[VO_PROP_MACROVISION].value = this->macrovision_info.dwLevel;
+	xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: current macrovision level: %ld.\n",
+		 this->macrovision_info.dwLevel);
+      } else {
+	xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: failed to lock macrovision resource.\n");
+	this->props[VO_PROP_MACROVISION_SUPPORTED].value = 0;
+	this->props[VO_PROP_MACROVISION].value = 0;
+      }
+    }else {
+      xprintf(this->xine,XINE_VERBOSITY_INFO,"vo_driver_cle266: Macrovision is not supported.\n");
+      this->props[VO_PROP_MACROVISION_SUPPORTED].value = 0;
+      this->props[VO_PROP_MACROVISION].value = 0;
+    }
+    #endif // Horace Lan    
+  }
+  // Enable/disable video output.
+  this->props[VO_PROP_OUTPUTENABLED].value = 1;  // Default, safe even if the UI never touch this prop.
+  this->props[VO_PROP_OUTPUTENABLED].min   = 0;
+  this->props[VO_PROP_OUTPUTENABLED].max   = 1;
+  // Enable/disable TV encoder output.
+  // ToDo: Propose TV status querying support in driver.
+  this->props[VO_PROP_TVOUT].value = 0;  // Don't know which value shall be default, driver shall tell us.
+  this->props[VO_PROP_TVOUT].min   = 0;
+  this->props[VO_PROP_TVOUT].max   = 1;
+  // Use colorkey or not. Value is set in switch(){} above.
+  this->props[VO_PROP_USECOLORKEY].min   = 0;
+  this->props[VO_PROP_USECOLORKEY].max   = 1;
+  // Colorkey value. We shall use generate_colorkey() to generate colorkey ...
+  this->props[VO_PROP_COLORKEY].min = 0;
+  this->props[VO_PROP_COLORKEY].max = 0xffffffff;
+
+
+
+  this->props[VO_PROP_INTERLACED].value     = 0;
+  this->sc.user_ratio = this->props[VO_PROP_ASPECT_RATIO].value   = XINE_VO_ASPECT_AUTO;
+  this->props[VO_PROP_ZOOM_X].value    = 100;
+  this->props[VO_PROP_ZOOM_Y].value    = 100;
+
+  // ToDo: deinterlace stuff.
+  /*   this->deinterlace_method      = 0; */
+  /*   this->deinterlace_frame.image = NULL; */
+  /*   this->deinterlace_method = config->register_enum (config, "video.deinterlace_method", 4, */
+  /* 						    deinterlace_methods, */
+  /* 						    _("Software deinterlace method (Key I toggles deinterlacer on/off)"), */
+  /* 						    NULL, 10, xv_update_deinterlace, this); */
+  this->deinterlace_enabled = 0;
+
+  pthread_mutex_init(&(this->config_lock),NULL);
+
+  // Start up with the overlay turned off. No locking here, OK.
+  this->waitting_for_video_img = 1;
+
+  //This is useful when allocate frame. Jack Liu 
+  this->used_accel_buffers=0;
+
+   xprintf(this->xine,XINE_VERBOSITY_INFO,"\n>>>>>>>> CLE266 video output plugin opened.\n\n");
+
+  return &this->vo_driver;
+}
+
+//=================================================================================
+// class functions
+
+static char* get_identifier (video_driver_class_t *this_gen) {
+  return "CLE266";
+}
+
+static char* get_description (video_driver_class_t *this_gen) {
+  return _("xine video output plugin using the VIA CLE266 chipset.");
+}
+
+static void dispose_class (video_driver_class_t *this_gen) {
+
+  cle266_class_t *this = (cle266_class_t *) this_gen;
+  uint32_t        ret;
+
+  if (!this)
+    return;
+
+  ret = VMI_Destroy(&this->vmi_info);
+  if (ret != VMI_OK) 
+	xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: dispose_class: Failed to destroy driver. Error code: %lx\n",(unsigned long)ret);
+   else
+   	xprintf(this->xine,XINE_VERBOSITY_INFO,"video_out_cle266: dispose_class: driver successfully destroyed.\n");
+  
+  free (this);
+}
+
+/* KGy: I don't think using two init() makes any sense.
+ * A initialized CLE266_class means some common but visual type specific things
+ *   have been done, but I don't think doing things separately in two init functions
+ *   are good since there may be some operation dependance problem.
+ * This need further consideration and work.
+ */
+// KGy For compatibility, make this to be the generic init_class().
+static void *_init_class (xine_t *xine,
+			  /*void*/ via_visual_t *visual_gen,
+			  visd_type visual_data_type) {
+
+  via_visual_t      *visual = /*(via_visual_t *)*/ visual_gen;
+  cle266_class_t    *this;
+  environment_t      environment = NONE;
+  uint32_t           ret;
+
+  if (!xine || !visual) {
+    lprintf("video_out_cle266: init_class: NULL argument passed in.\n");
+    return NULL;
+  }
+
+  // We deal with different visual type first.
+  // Note: There is a corresponding switch(){} in open_plugin().
+  switch (visual->visual_type) {
+    // Supported:
+  case XINE_VISUAL_TYPE_X11:
+    environment = X;
+#ifdef HAVE_X11 
+    if (!XInitThreads()) {
+      xprintf(xine,XINE_VERBOSITY_INFO,"video_out_cle266: init_class on X: No thread-safe X libraries available.\n");
+      return NULL;
+    }
+#else
+    return NULL;
+#endif
+    break;
+  case XINE_VISUAL_TYPE_FB:
+    environment = FB;
+    // What to do here?
+    break;
+    // Possibly supportable:
+  case XINE_VISUAL_TYPE_DFB:
+  case XINE_VISUAL_TYPE_GTK:
+  case XINE_VISUAL_TYPE_AA:
+    // Not supported:
+  case XINE_VISUAL_TYPE_PM:  /* used by the OS/2 port */
+  case XINE_VISUAL_TYPE_DIRECTX:
+  case XINE_VISUAL_TYPE_NONE:
+  default:
+    xprintf(xine,XINE_VERBOSITY_INFO,"video_out_cle266: init_class: invalid visual type.\n");
+    return NULL;
+  }
+
+  this = (cle266_class_t *) malloc (sizeof (cle266_class_t));
+  if (!this) {
+    xprintf(xine,XINE_VERBOSITY_INFO,"video_out_cle266: init_class: failed to allocate the class structure.\n");
+    return NULL;
+  }
+
+  // Create the driver.
+  /* Init hw-mpeg decode driver,
+   * from VT3259 on, 2 virtual hw-mpeg decoders are available.
+   */
+  this->vmi_info.dwAPIVersion=API_VERSION_NUMERIC(2,2);
+  ret = VMI_Create(&this->vmi_info);
+  if (ret != VMI_OK) {
+    xprintf(xine,XINE_VERBOSITY_INFO,"video_out_cle266: init_class: failed to create CLE266 driver, error code: %lx\n", (unsigned long)ret);
+    free(this);
+    return NULL;
+  }
+
+    xprintf(xine,XINE_VERBOSITY_INFO,"video_out_cle266: driver successfully created.\n");
+  // CLE266Driver is always created when we have the class.
+
+  this->driver_class.open_plugin     = open_plugin;
+  this->driver_class.get_identifier  = get_identifier;
+  this->driver_class.get_description = get_description;
+  this->driver_class.dispose         = dispose_class;
+
+  this->config = xine->config;
+  this->xine   = xine;
+
+  this->init_env = environment;
+
+  this->visual_data_type = visual_data_type;
+
+  return this;
+}
+
+// Compatibility layer.
+static void *init_class (xine_t *xine, void *visual_gen) {
+  via_visual_t *visual = (via_visual_t *)visual_gen;
+  return _init_class(xine,visual,via);
+}
+
+static void *init_class_fb (xine_t *xine, void *visual_gen) {
+  via_visual_t visual;
+
+  memset(&visual,0,sizeof(via_visual_t));
+  visual.visual_type = XINE_VISUAL_TYPE_FB;
+  if (!visual_gen) {
+    fb_visual_t *visual_fb = (fb_visual_t *)visual_gen;
+    visual.frame_output_cb = visual_fb->frame_output_cb;
+    visual.user_data       = visual_fb->user_data;
+  }
+
+  return _init_class(xine,&visual,xine_fb);
+}
+
+static void *init_class_x11 (xine_t *xine, void *visual_gen) {
+  x11_visual_t *visual_x11 = (x11_visual_t *)visual_gen;
+  via_visual_t  visual;
+
+  if (!visual_gen) {
+      xprintf(xine,XINE_VERBOSITY_INFO,"video_out_cle266: init_class_x11: visual_gen is NULL.\n");
+    return NULL;
+  }
+
+  memset(&visual,0,sizeof(via_visual_t));
+  visual.visual_type = XINE_VISUAL_TYPE_X11;
+  visual.display         = visual_x11->display;
+  visual.screen          = visual_x11->screen;
+  visual.d               = visual_x11->d;
+  visual.dest_size_cb    = visual_x11->dest_size_cb;
+  visual.frame_output_cb = visual_x11->frame_output_cb;
+  visual.user_data       = visual_x11->user_data;
+
+  return _init_class(xine,&visual,xine_x11);
+}
+
+//========================================================================================
+
+/* There are 3 plugins for selection, and only one can be initialized at one time.
+ * ! but there is no code checking multi-init and preventing multi-init !
+ * The "cle266" plugin gets the original design and use the via_visual_t, which is not
+ *   compatible with original UIs for xine.
+ *   I HOPE the via_visual_t to be renamed to xine_visual_t and be used by
+ *   all vo_plugins that runs on Linux, then we need forced type conversion any more.
+ *   If we really need different visual_t, such as for XINE_VISUAL_TYPE_DIRECTX, etc,
+ *   we can make each platform a standalone visual_t and use conditional compiling
+ *   to decide which one to use.
+ *   This will be good for video output plugins with multi visual_type support.
+ *   I don't think create so many variations of one plugin is good.
+ *   This plugin will not be probed by xine-lib, and UI shall supply correct visual data
+ *   whenever trying to load this.
+ * The cle266fb and cle266x11 is for original UIs, it's fully compatible with these UIs
+ *   but FB_UI fbxine shall be modified to load cle266fb.
+ */
+
+static vo_info_t vo_info_cle266 = {
+  9,  /* priority */
+  XINE_VISUAL_TYPE_X11 | XINE_VISUAL_TYPE_FB  /* visual type */
+};
+
+static vo_info_t vo_info_cle266fb = {
+  9,  /* priority */
+  XINE_VISUAL_TYPE_FB  /* visual type */
+};
+
+static vo_info_t vo_info_cle266x11 = {
+  9,  /* priority */
+  XINE_VISUAL_TYPE_X11  /* visual type */
+};
+
+//#ifdef COMPILE_PLUGINS
+plugin_info_t xine_plugin_info[] ={
+//#else
+//plugin_info_t vmi_video_out_plugin_info[] ={
+//#endif	
+  /* type, API, "name", version, special_info, init_function */
+  { PLUGIN_VIDEO_OUT, 20, "cle266",    XINE_VERSION_CODE, &vo_info_cle266,    init_class },
+  { PLUGIN_VIDEO_OUT, 20, "cle266fb",  XINE_VERSION_CODE, &vo_info_cle266fb,  init_class_fb },
+  { PLUGIN_VIDEO_OUT, 21, "cle266x11", XINE_VERSION_CODE, &vo_info_cle266x11, init_class_x11 },
+  { PLUGIN_NONE, 0, "", 0, NULL, NULL }
+};
diff -ruN xine-lib-1.1.2-via/src/xine-engine/accel_xvmc.h xine-lib-1.1.2-my-2/src/xine-engine/accel_xvmc.h
--- xine-lib-1.1.2-via/src/xine-engine/accel_xvmc.h	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/xine-engine/accel_xvmc.h	2006-10-18 21:43:55.000000000 +0300
@@ -126,6 +126,24 @@
 #define XINE_XVMC_ACCEL_IDCT   0x00000002
 #define XINE_XVMC_ACCEL_VLD    0x00000004
 
+//Add VMI MPEG2_SLICE/MPEG4_TDCT  definitions here.
+//Jack Liu, 2005-2-4 16:18
+
+#include "viampg.h" 
+#include "viavid.h"
+typedef struct vmi_accel_s {
+
+  int surf_id;
+  int decoded_ok;  //Some frames can not be decoded because lacking of forward_ref or backward_ref especially 
+				 // on first some frames,then we should not  display it.  
+  LPVMI_INFO_PARAM	p_vmi_info;
+  VIAMPGSURFACE	mpg_accel_param;
+  void (*proc_begin_frame) (vo_frame_t *cur_frame_gen);
+  void (*proc_render_frame)(vo_frame_t  *cur_frame_gen,void *decode_data);
+ 
+} vmi_accel_t;
+
+
 
 /* xvmc acceleration types */
 #define XINE_VO_MOTION_ACCEL   1
diff -ruN xine-lib-1.1.2-via/src/xine-engine/viafb.h xine-lib-1.1.2-my-2/src/xine-engine/viafb.h
--- xine-lib-1.1.2-via/src/xine-engine/viafb.h	1970-01-01 03:00:00.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/xine-engine/viafb.h	2006-10-18 21:43:55.000000000 +0300
@@ -0,0 +1,56 @@
+/*
+ * Copyright 1998-2006 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2006 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#define VIAFB_GET_INFO_SIZE     0x56494101 /* 'VIA\01' */
+#define VIAFB_GET_INFO          0x56494102 /* 'VIA\02' */
+#define VIAFB_HOTPLUG           0x56494103 /* 'VIA\03' */
+#define VIAFB_SET_HOTPLUG_FLAG  0x56494104 /* 'VIA\04' */
+#define VIAFB_GET_RESOLUTION    0x56494105 /* 'VIA\05' */
+#define VIAFB_GET_TV_TYPE       0x56494106 /* 'VIA\06' */
+#define VIAFB_GET_SAMM_INFO   0x56494107 /* 'VIA\07' */
+
+#define VIA_ID                  0x56494146
+
+struct viafb_ioctl_mode {
+    unsigned long   xres;
+    unsigned long   yres;
+    unsigned long   refresh;
+    unsigned long   bpp;
+    //unsigned long   mem_size;  
+    //unsigned long   mem_base;
+    //unsigned long   offset_sec; 
+    unsigned long   xres_sec;
+    unsigned long   yres_sec;
+    unsigned long   refresh_sec;
+    unsigned long   bpp_sec;
+};
+struct viafb_ioctl_mode viafbmode;
+
+struct viafb_ioctl_samm {
+    unsigned long     samm_status;
+    unsigned long     size_prim; 
+    unsigned long     size_sec;
+    unsigned long     mem_base;
+    unsigned long     offset_sec; 
+};
diff -ruN xine-lib-1.1.2-via/src/xine-engine/viampg.h xine-lib-1.1.2-my-2/src/xine-engine/viampg.h
--- xine-lib-1.1.2-via/src/xine-engine/viampg.h	1970-01-01 03:00:00.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/xine-engine/viampg.h	2006-10-18 21:43:55.000000000 +0300
@@ -0,0 +1,339 @@
+/*
+ * Copyright 1998-2006 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2006 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _VIAMPG
+#define _VIAMPG
+
+#ifdef XFree86Server
+#include "xf86_ansic.h" /* for Bool */
+#else
+#include "via_types.h"  /* for Bool */
+#endif
+
+typedef struct _VIAMCSURFACE
+{
+    /*
+     *  First part isn't used currently, will be removed later.
+     */
+    unsigned long dwSize;                   /* Size of this structure */
+    unsigned long dwVersion;                /* Interface Version */
+    unsigned long pDevice;                  /* Useless */
+    void * BeginPicture;                        /* Pointer to VIA_BeginPicture */
+    void * EndPicture;                          /* Pointer to VIA_Endicture */
+    void * SetMacroBlock;                       /* Pointer to VIA_SetMacroBlock */
+    void * SliceReceiveData;                    /* Pointer to VIA_SliceReceiveData */
+    void * DriverProc;
+    /* unsigned long dwCompose; */
+    void * DisplayControl;
+    void * SubPicture;
+    void * SetDeInterlaceMode;                  /* Pointer to VIA_SetDeinterlaceMode */
+    unsigned long dwState;                  /* Current state of MPG  */
+    unsigned long dwBufferNumber;           /* Total no. of decoder buffer created. (Always 4 ) */
+    Bool  bInitialized;                         /* Except dwState */
+    unsigned long dwReserved[8];            /* For future expansion */
+
+    /*
+     * Client fills out the following values before calling BeginPicture
+     */
+    unsigned long dwTaskType;                /* Null, Decode or Display */
+
+    /* Decode Picture */
+    unsigned long dwPictureType;             /* I, P or B pictures */
+    unsigned long dwDecodePictStruct;        /* Top Field, Bottom Field or Frame */
+    unsigned long dwDecodeBuffIndex;         /* Decode buffer Index. 0 to ( dwBufferNumber -1) */
+    unsigned long dwAlternateScan;           /* Zig-Zag Scan or Alternative Scan */
+
+    /* Display picture */
+    unsigned long dwDisplayPictStruct;       /* Top Field, Bottom Field or Frame */
+    unsigned long dwDisplayBuffIndex;        /* Display buffer Index. 0 to ( dwBufferNumber -1) */
+    unsigned long dwFrameRate;               /* Frame rate  multiplied by 1000 ( 29.97=29700 ) */
+    unsigned long dwDeinterlaceMode;         /* BOB / Weave */
+    unsigned long dwQMatrix[2][16];          /* Quantiser Matrix, 0:intra, 1:non_intra */
+    unsigned long dwQMatrixChanged;          /* If The Quantiser Matrix is changed?        */
+    unsigned long dwMBwidth;                 /* Macroblock Width                                           */
+    /* unsigned long dwV_size_g2800; */      /* Decide if v_size is greater than 2800      */
+    unsigned long dwMpeg2;                   /* Decide if it is a mpeg2 slice stream       */
+    unsigned long dwTopFirst;
+    unsigned long dwFramePredDct;
+    unsigned long dwMBAmax;                  /* It is equal to mb_width * mb_height; */
+    unsigned long dwIntravlc;
+    unsigned long dwDcPrec;
+    unsigned long dwQscaleType;
+    unsigned long dwConcealMV;
+    /* unsigned long dwSliceFirst; */
+    unsigned long dwSecondField;
+    unsigned long dwOldRefFrame;
+    unsigned long dwRefFrame;
+    unsigned long BVMVRange;                 /* Backward Vertical Motion Vector Range   */
+    unsigned long BHMVRange;                 /* Backward Horizontal Motion Vector Range */
+    unsigned long FVMVRange;                 /* Fordward Vertical Motion Vector Range   */
+    unsigned long FHMVRange;                 /* Fordward Horizontal Motion Vector Range */
+    unsigned long dwMPEGProgressiveMode;     /* default value : VIA_PROGRESSIVE */
+    int   framenum;
+    unsigned long dwDecoderMode;             /* indicate H/W mpeg decoder mode: USE_MC, USE_IDCT, USE_SLICE */
+    unsigned long dwMPEG4Decode;             /* Indicate to use the MPEG4 decoder */
+    unsigned long dwRreserved[6];            /* for future expansion */
+} VIAMPGSURFACE, * LPVIAMPGSURFACE;
+
+/* definition for dwDecoderMode */
+#define USE_SLICE                 0
+#define USE_MC                    1
+#define USE_MC_IDCT               2
+
+/* dwTaskType of VIAMPGSURFACE */
+#define VIA_TASK_NULL              0x00000000 /* Used only to check state and version */
+#define VIA_TASK_DECODE            0x00000001 /* Decode new Picture also Display decoded picture */
+#define VIA_TASK_DISPLAY           0x00000002 /* Display only */
+
+/* dwPictureType of VIAMPGSURFACE */
+#define VIA_PIC_TYPE_I              0x00000001
+#define VIA_PIC_TYPE_P              0x00000002
+#define VIA_PIC_TYPE_B              0x00000003
+
+/* dwDecodePictStruct and dwDisplayPictStruct of VIAMPGSURFACE */
+#define VIA_PICT_STRUCT_TOP                 0x00000001
+#define VIA_PICT_STRUCT_BOTTOM              0x00000002
+#define VIA_PICT_STRUCT_FRAME               0x00000003
+
+/* dwAltScan */
+#define VIA_ALTERNATE_SCAN                  0x1
+#define VIA_ZIG_ZAG_SCAN                    0x0
+
+/* dwDeinterlaceMode of VIAMPGSURFACE */
+#define VIA_DEINTERLACE_WEAVE               0x00000000
+#define VIA_DEINTERLACE_BOB                 0x00000001
+#define VIA_DEINTERLACE_MEDIAN              0x00000002
+
+
+/* dwMPEGProgressiveMode of VIAMPGSURFACE */
+#define VIA_NON_PROGRESSIVE                 0x00000000
+#define VIA_PROGRESSIVE                     0x00000010
+
+/**************************************************************************
+   VIA Macro Block Structure
+***************************************************************************/
+
+/*  
+ *      store the IDCT coefficient values.
+ */
+typedef struct _IDCTCoef4Group {
+    unsigned char  CoefIndex[4];
+    short CoefValue[4];
+} IDCTCoef4Group, *LPIDCTCoef4Group;
+
+
+typedef struct  _VIAMACROBLOCK {
+    unsigned long dwMBLKInfo;       /* Codedblocks, DCT type, Predition direction,    */
+                                    /* Prediction mode and Motion Vectors information */
+                                    /* of current Macro Block                         */
+    unsigned long dwMBLKHOffset;    /* Macro Block horizontal offset                  */
+    unsigned long dwMBLKVOffset;    /* Macro Block vertical offset                    */
+    unsigned long dwMV[24];         /* Motion Vectors in half pixel resolution 	*/
+                                    /* and based on the current Bacro Block's 	*/
+                                    /* upper left corner.                                   */
+                                    /* 1st forward motion vector or Motion Vector 0         */
+                                    /* dwMV[0] is PMV[0][0][0] (Horizontal)                 */
+                                    /* dwMV[1] is PMV[0][0][1] (Vertical  )                 */
+                                    /* 2nd forward motion vector or Motion Vector 1         */
+                                    /* dwMV[2] is PMV[0][1][0] (Horizontal)                 */
+                                    /* dwMV[3] is PMV[0][1][1] (Vertical  )                 */
+                                    /* 1st backward motion vector or Motion Vector 2        */
+                                    /* dwMV[4] is PMV[1][0][0] (Horizontal)                 */
+                                    /* dwMV[5] is PMV[1][0][1] (Vertical  )                 */
+                                    /* 2nd backward motion vector or Motion Vector 3        */
+                                    /* dwMV[6] is PMV[1][1][0] (Horizontal)                 */
+                                    /* dwMV[7] is PMV[1][1][1] (Vertical  )                 */
+                                    /* First forward UV motion vector or Motion Vector 4    */
+                                    /* dwMV[8] is PMV[0][0][0] (Horizontal)                 */
+                                    /* dwMV[9] is PMV[0][0][1] (Vertical  )                 */
+                                    /* 3rd forward motion vector or Motion Vector 5         */
+                                    /* dwMV[10] is PMV[0][0][0] (Horizontal)                */
+                                    /* dwMV[11] is PMV[0][0][1] (Vertical  )                */
+                                    /* 4th forward motion vector or Motion Vector 6         */
+                                    /* dwMV[12] is PMV[0][1][0] (Horizontal)                */
+                                    /* dwMV[13] is PMV[0][1][1] (Vertical  )                */
+                                    /* 3rd backward motion vector or Motion Vector 7        */
+                                    /* dwMV[14] is PMV[1][0][0] (Horizontal)                */
+                                    /* dwMV[15] is PMV[1][0][1] (Vertical  )                */
+                                    /* 4th backward motion vector or Motion Vector 8        */
+                                    /* dwMV[16] is PMV[1][1][0] (Horizontal)                */
+                                    /* dwMV[17] is PMV[1][1][1] (Vertical  )                */
+                                    /* First backward UV motion vector or Motion Vector 9   */
+                                    /* dwMV[18] is PMV[0][0][0] (Horizontal)                */
+                                    /* dwMV[19] is PMV[0][0][1] (Vertical  )                */
+                                    /* Second forward UV motion vector or Motion Vector 4   */
+                                    /* dwMV[20] is PMV[0][0][0] (Horizontal)                */
+                                    /* dwMV[21] is PMV[0][0][1] (Vertical  )                */
+                                    /* Second backward UV motion vector or Motion Vector 9  */
+                                    /* dwMV[22] is PMV[0][0][0] (Horizontal)                */
+                                    /* dwMV[23] is PMV[0][0][1] (Vertical  )                */
+    /* 09-01-1999 */
+    /* Based on Scott's suggestion, I restore the original design as below. */
+    void * lpIDCTBuff;           /* IDCT data for current macro block                      */
+                                 /* Client needs to allocate and maintain 768 bytes        */
+                                 /* For INTRA Macro Block                                  */
+                                 /* ( 64 coeffiients per block * 1 bytes per coefficient * */
+                                 /*   6 clocks ) buffer with the following layout.         */
+                                 /*  Buf[  0..63 ] for Y0                                  */
+                                 /*  Buf[ 64..127] for Y1                                  */
+                                 /*  Buf[128..191] for Y2                                  */
+                                 /*  Buf[192..255] for Y3                                  */
+                                 /*  Buf[256..319] for Cb                                  */
+                                 /*  Buf[320..383] for Cr                                  */
+                                 /* For INTER Macro Block                                  */
+                                 /* ( 64 coeffiients per block * 2 bytes per coefficient * */
+                                 /*   6 clocks ) buffer with the following layout.         */
+                                 /*  Buf[  0..127] for Y0                                  */
+                                 /*  Buf[128..255] for Y1                                  */
+                                 /*  Buf[256..383] for Y2                                  */
+                                 /*  Buf[384..511] for Y3                                  */
+                                 /*  Buf[512..639] for Cb                                  */
+                                 /*  Buf[640..767] for Cr                                  */
+    LPIDCTCoef4Group lpHWIDCTBuff;        /* We fill A.A.N. IDCT coefficient in this buffer which has 256                           */
+                                 /* bytes per block,                                                                       */
+                                 /* 128 bytes [0,2,4,.....126] are for Run of Y0  , where 0 <= Run <= 63                   */
+                                 /* 128 bytes [1,3,5,.....127] are for Level of Y0, where -2048   <= Level  <= 2047        */
+                                 /* 128 bytes [128,130,132,.....254] are for Run of Y1  , where 0 <= Run <= 63             */
+                                 /* 128 bytes [129,131,133,.....255] are for Level of Y1, where -2048   <= Level  <= 2047  */
+                                 /* 128 bytes [256,258,260,.....382] are for Run of Y2  , where 0 <= Run <= 63             */
+                                 /* 128 bytes [257,259,261,.....383] are for Level of Y2, where -2048   <= Level  <= 2047  */
+                                 /* 128 bytes [384,386,388,.....510] are for Run of Y3  , where 0 <= Run <= 63             */
+                                 /* 128 bytes [385,387,389,.....511] are for Level of Y3, where -2048   <= Level  <= 2047  */
+                                 /* 128 bytes [512,514,516,.....638] are for Run of Cb  , where 0 <= Run <= 63             */
+                                 /* 128 bytes [513,515,517,.....639] are for Level of Cb, where -2048   <= Level  <= 2047  */
+                                 /* 128 bytes [640,642,644,.....766] are for Run of Cr  , where 0 <= Run <= 63             */
+                                 /* 128 bytes [641,643,645,.....767] are for Level of Cr, where -2048   <= Level  <= 2047  */
+    unsigned char  byIDCTCount[6];        /* Number of (Run, Level) pair in each block                                              */
+    /* Vincent Lai [2003.07.14],for VT3259 */
+    unsigned char  bReserved[2];          /* Alignment */
+    unsigned long dwVMBNum;               /* The macroblock number per column */
+    unsigned long dwHMBNum;               /* The macroblock number per row */
+    unsigned long dwBiDirectionRounding;  /* Bi-direction prediction rounding control */
+    unsigned long dwRounding;             /* Interpolation rounding control for non-integer motion vector */
+    unsigned long dwQblockSize;           /* Block size of quarter-pel MC in case of progressive MB 0:16x16 ,1:8x8 */
+    unsigned long dwUseQMC;               /* Quarter-pel enable */
+    unsigned long dwUseGMC;               /* GMC enable */
+    unsigned long dwUse4MV;               /* 4MV enable */
+    unsigned long dwScanType;             /* 0:Zig-Zag 1:Alternate Vertical 2:Alternate Horizontal */
+                                                  /* [1:0] block u0,[3:2] block v0,[5:4] block y3,[7:6] block y2,[9:8] block y1,[11:10] block y0 */
+    unsigned long dwDCScalValue[6];       /* DC scal value */
+    unsigned long dwDCTMaxValue[6];       /* DCT coefficients clip value */
+    unsigned long dwQP[6];                /* Inverse Quantization value */
+    unsigned long dwIntra[6];             /* Intra block ,1:Intra block,0:Inter block */
+} VIAMACROBLOCK, * LPVIAMACROBLOCK;
+
+
+#define MBLK_LAST_MACROBLOCK   0x00800000   /* The last macroblock in this picture */
+
+/* dwBLKInfo of VIAMACROBLOCK */
+/* Prediction Type */
+#define MBLK_PREDICY_BWD       0x00000100   /* Backward Prediction */
+#define MBLK_PREDICY_FWD       0x00000080   /* Forward Prediction  */
+#define MBLK_PREDICY_BD        (MBLK_PREDICY_BWD | MBLK_PREDICY_FWD) /* Bidirection Prediction */
+#define MBLK_PREDICY_16X8      0x00000400   /* 16X8 Prediction       */
+#define MBLK_PREDICY_DP        0x00000600   /* Dual Prime Prediction */
+#define MBLK_PREDICY_FRAME     0x00000400   /* Frame Prediction      */
+#define MBLK_PREDICY_FIELD     0x00000200   /* Field Prediction      */
+
+/* DCT Type */
+#define MBLK_DCT_FRAME         0x00000000   /* use Frame DCT for current macroblock */
+#define MBLK_DCT_FIELD         0x00000040   /* use Field DCT for current macroblock */
+
+/* Intra Flag */
+#define MBLK_TYPE_INTRA        0x00000000   /* Intra BacroBlock */
+/* Don't care */
+#define MBLK_TYPE_INTER        0x00000000   /* Inter BacroBlock */
+
+/* This 2 bits are not in "Macro Block Descrition register".
+ * They are in "Motion Vector 0~4 register"
+ * Please do "LPVIAMACROBLOCK->dwMV[?] = LPVIAMACROBLOCK->dwMV[?] | MBLK_MV?_REF_XXX | MBLK_REF_BUFF_INDEX_0"
+ * before calling MPEGSetMacroBlock
+ * Reference Field
+ */
+#define MBLK_MV_REF_BOTTOM     0x00008000   /* Reference Bottom field */
+#define MBLK_REF_BUFF_INDEX_0  0x00000000
+#define MBLK_REF_BUFF_INDEX_1  0x00002000
+#define MBLK_REF_BUFF_INDEX_2  0x00004000
+#define MBLK_REF_BUFF_INDEX_3  0x00006000
+
+/* CBP */
+#define MBLK_CBP_Y0            0x00000001   /* Indicate if Y0 block is coded */
+#define MBLK_CBP_Y1            0x00000002   /* Indicate if Y1 block is coded */
+#define MBLK_CBP_Y2            0x00000004   /* Indicate if Y2 block is coded */
+#define MBLK_CBP_Y3            0x00000008   /* Indicate if Y3 block is coded */
+#define MBLK_CBP_Cb            0x00000010   /* Indicate if Cb block is coded */
+#define MBLK_CBP_Cr            0x00000020   /* Indicate if Cr block is coded */
+
+
+/* 09-01-1999
+ * Based on discuss between me and Jay.
+ * The following structure and definition are for subpicture.
+ */
+/**************************************************************************
+   VIA SubPicture Structure
+***************************************************************************/
+typedef struct  _VIASUBPICT {
+    /*
+     *  First part isn't used currently, will be removed later.
+     */
+    unsigned long dwSize;                   /* Size of this structure   */
+    void * SubPicture;                              /* Pointer to VIA_SubPicture */
+    unsigned char * lpSubpictureBuffer[2];  /* Subpicture frame buffer 0,1 */
+    unsigned long dwPitch;                      /* Subpicture frame buffer pitch */
+    unsigned long dwState;                  /* Current state of H/W SubPicture Engine */
+    Bool  bInitialized;                         /* Except dwState */
+    unsigned long dwReserved[8];            /* For future expansion */
+
+    /*
+     * Client fills out the following values before calling SubPicure
+     */
+    unsigned long dwTaskType;                /* Null, Write or Display */
+
+    /* Write Buffer Index */
+    unsigned long dwWriteBuffIndex;          /* Write buffer Index. 0 or 1 */
+
+    /* Display Buffer Index */
+    unsigned long dwDisplayBuffIndex;        /*Decode buffer Index. 0 or 1        */
+    void * lpSPBuffer;               /*Where SubPicture BMP located       */
+    unsigned long  dwSPLeft;                 /*SubPicture position in Video frame */
+    unsigned long  dwSPTop;
+    unsigned long  dwSPWidth;                /* SubPicture width  */
+    unsigned long  dwSPHeight;               /* SubPicture height */
+    unsigned long  dwRamTab[16];
+    unsigned long  dwRreserved[8];           /* For future expansion */
+                                     /* dwRreserved[0] is used for SUBPICTURE surface Pitch */
+} VIASUBPICT, * LPVIASUBPICT;
+
+
+/* dwTaskType of VIASUBPICTURE */
+#define VIA_TASK_SP_NULL      0x00000000 /* Used only to check state                             */
+#define VIA_TASK_SP_DISPLAY   0x00000002 /* Display SubPciture which                             */
+                                          /* frame Idx = dwDisplayBuffIndex                      */
+                                          /* If callback function SubPicture receive              */
+                                          /* flag = ( VIA_TASK_SP_WRITE | WLKN_TASK_SP_DISPLAY ) */
+                                          /* Write and Display can be done in one function call   */
+#define VIA_TASK_SP_RAMTAB            0x00000006 /* Update Ram_Table(16x24) */
+#define VIA_TASK_SP_DISPLAY_DISABLE   0x00000008 /* Disable Display SubPciture */
+
+#endif
+
diff -ruN xine-lib-1.1.2-via/src/xine-engine/via_types.h xine-lib-1.1.2-my-2/src/xine-engine/via_types.h
--- xine-lib-1.1.2-via/src/xine-engine/via_types.h	1970-01-01 03:00:00.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/xine-engine/via_types.h	2006-10-18 21:43:55.000000000 +0300
@@ -0,0 +1,77 @@
+/*
+ * Copyright 1998-2006 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2006 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ *	Define types used in the codes
+ *	in terms of X11 base types.
+ */
+
+#ifndef VIA_TYPES_H
+#define VIA_TYPES_H
+
+#ifndef Bool
+typedef int Bool;
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef CARD8
+
+typedef unsigned char CARD8;
+
+#endif
+
+
+#ifndef CARD16
+
+typedef unsigned short CARD16;
+
+#endif
+
+
+
+#ifndef CARD32
+
+  #ifdef __x86_64__
+
+    typedef unsigned int CARD32;
+
+  #else
+
+    typedef unsigned long CARD32;
+
+  #endif
+
+#endif
+
+
+
+#endif
+
diff -ruN xine-lib-1.1.2-via/src/xine-engine/viavid.h xine-lib-1.1.2-my-2/src/xine-engine/viavid.h
--- xine-lib-1.1.2-via/src/xine-engine/viavid.h	1970-01-01 03:00:00.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/xine-engine/viavid.h	2006-10-18 21:43:55.000000000 +0300
@@ -0,0 +1,490 @@
+ /*
+ * Copyright 1998-2006 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2006 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHOR(S) OR COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+ 
+
+#ifndef _VIAVID_H
+#define _VIAVID_H
+
+/* API Version : Driver support current version*/
+#define API_VERSION_NUMERIC(x,y) ((x << 16) | y)
+
+/*
+ * FOURCC definitions
+ */
+ 
+
+#define FOURCC_VIA     0x4E4B4C57  /*VIA*/
+#define FOURCC_SUBP    0x50425553  /*SUBP*/
+#define FOURCC_TV0     0x00325654  /*TV0*/
+#define FOURCC_TV1     0x00315654  /*TV1*/
+#define FOURCC_ALPHA   0x48504C41  /*ALPH*/
+#define FOURCC_YUY2    0x32595559  /*YUY2*/
+#define FOURCC_YV12    0x32315659  /*YV12*/
+#define FOURCC_Y211    0x31313259
+#define FOURCC_UYVY    0x59565955
+#define FOURCC_YVYU    0x55595659
+#define FOURCC_IYUV    0x56555949  /* #define FOURCC_IYUV   'VUYI'*/
+#define FOURCC_I420    0x30323449  /* I420 */
+
+#define FOURCC_HQVMPEG 0x31565148  /*HQV1*/
+#define FOURCC_HQVTV0  0x32565148  /*HQV2*/
+#define FOURCC_HQVTV1  0x33565148  /*HQV3*/
+#define FOURCC_HQVYUY2 0x34565148  /*HQV4*/
+#define FOURCC_HQVYV12 0x35565148  /*HQV5*/
+#define FOURCC_NV12   0x3231564E   /* uncompressed overlay surface */
+/*Robert 2003-9-30 for VT3264 */
+#define FOURCC_V410   0x30313456   
+#define FOURCC_V444   0x34343456
+
+
+/*
+ * Actions for VMI functions
+ */
+#define CREATEDRIVER               0x00
+#define DESTROYDRIVER              CREATEDRIVER +1
+#define CREATESURFACE              CREATEDRIVER +2
+#define DESTROYSURFACE             CREATEDRIVER +3
+#define LOCKSURFACE                CREATEDRIVER +4
+#define UNLOCKSURFACE              CREATEDRIVER +5
+#define UPDATEOVERLAY              CREATEDRIVER +6
+#define FLIP                       CREATEDRIVER +7  
+#define SETALPHAWIN                CREATEDRIVER +8
+#define BEGINPICTRE                CREATEDRIVER +9
+#define BEGINPICTURE               CREATEDRIVER +9
+#define ENDPICTURE                 CREATEDRIVER +10
+#define SLICERECEIVEDATA           CREATEDRIVER +11
+#define DRIVERPROC                 CREATEDRIVER +12
+#define DISPLAYCONTROL             CREATEDRIVER +13
+#define SUBPICTURE                 CREATEDRIVER +14
+#define SETDEINTERLACEMODE         CREATEDRIVER +15
+#define MPEGENABLE                 CREATEDRIVER +16  
+#define MPEGGETPICTYPE             CREATEDRIVER +17  
+#define FF_START                   CREATEDRIVER +18  
+#define FF_END                     CREATEDRIVER +19
+#define INITSURFACEMANAGER         CREATEDRIVER +20
+#define FREESURFACEMANAGER         CREATEDRIVER +21
+#define GETVIDEOCONTROL            CREATEDRIVER +22     
+#define SETVIDEOCONTROL            CREATEDRIVER +23
+#define UPDATEALPHA                CREATEDRIVER +24
+/* [seanzhang] remove the macrovison operation */
+#define SETTVOUT                   CREATEDRIVER +29
+#define SETCAPINFO                 CREATEDRIVER +30
+#define SLICERECEIVEDATAEX         CREATEDRIVER +31
+#define SETVIDEOCOLOR              CREATEDRIVER +32
+#define SETTVOVERLAY         CREATEDRIVER +33
+
+/* =========================================================================
+ * New definition for VMI 2.0
+ * =========================================================================*/
+#define BEGINFRAME  	           CREATEDRIVER +40
+#define RENDERFRAME 	           CREATEDRIVER +41
+
+/* take a snapshort support [2004.12.02 seanzhang] */
+#define SNAPSHOT		    CREATEDRIVER+42
+
+#define SETHWFEATURES              CREATEDRIVER+43
+
+/*
+ *  sub-picture surfaces ( frame buffers ) we use
+ */
+#define NUM_FRAME_BUFFERS_SUB           2
+
+/*
+ * Structures for SubPicture surface information
+ */
+typedef struct _SUBDEVICE
+{
+    unsigned char * lpSUBOverlaySurface[NUM_FRAME_BUFFERS_SUB];   /*Max 2 Pointers to SUB Overlay Surface*/
+    unsigned long  dwSUBPhysicalAddr[NUM_FRAME_BUFFERS_SUB];     /*Max 2 Physical address to SUB Overlay Surface*/
+    unsigned long  dwPitch;                  /*SUB frame buffer pitch*/
+    unsigned long  gdwSUBSrcWidth;           /*SUB Source Width*/
+    unsigned long  gdwSUBSrcHeight;          /*SUB Source Height*/
+    unsigned long  gdwSUBDstWidth;           /*SUB Destination Width*/
+    unsigned long  gdwSUBDstHeight;          /*SUB Destination Height*/
+    unsigned long  gdwSUBDstLeft;            /*SUB Position : Left*/
+    unsigned long  gdwSUBDstTop;             /*SUB Position : Top*/
+}SUBDEVICE;
+typedef SUBDEVICE * LPSUBDEVICE;
+
+
+/*
+ *  S/W decode surfaces ( frame buffers ) we use
+ */
+#define NUM_FRAME_BUFFERS_SW           2
+
+/*
+ * Structures for H/W overlay only surface information
+ */
+typedef struct _SWDEVICE
+{
+    unsigned char * lpSWOverlaySurface[NUM_FRAME_BUFFERS_SW];   /* Max 2 Pointers to SW Overlay Surface*/
+    unsigned long  dwSWPhysicalAddr[NUM_FRAME_BUFFERS_SW];     /*Max 2 Physical address to SW Overlay Surface */
+    unsigned long  dwSWCbPhysicalAddr[NUM_FRAME_BUFFERS_SW];  /* Physical address to SW Cb Overlay Surface, for YV12 format use */
+    unsigned long  dwSWCrPhysicalAddr[NUM_FRAME_BUFFERS_SW];  /* Physical address to SW Cr Overlay Surface, for YV12 format use */
+    unsigned long  dwHQVAddr[3];             /* Physical address to HQV surface -- CLE_C0   */
+    /*unsigned long  dwHQVAddr[2];*/                         /*Max 2 Physical address to SW HQV Overlay Surface*/
+    unsigned long  dwWidth;                  /*SW Source Width, not changed*/
+    unsigned long  dwHeight;                 /*SW Source Height, not changed*/
+    unsigned long  dwPitch;                  /*SW frame buffer pitch*/
+    unsigned long  gdwSWSrcWidth;           /*SW Source Width, changed if window is out of screen*/
+    unsigned long  gdwSWSrcHeight;          /*SW Source Height, changed if window is out of screen*/
+    unsigned long  gdwSWDstWidth;           /*SW Destination Width*/
+    unsigned long  gdwSWDstHeight;          /*SW Destination Height*/
+    unsigned long  gdwSWDstLeft;            /*SW Position : Left*/
+    unsigned long  gdwSWDstTop;             /*SW Position : Top*/
+    unsigned long  dwDeinterlaceMode;        /*BOB / WEAVE*/
+}SWDEVICE;
+typedef SWDEVICE * LPSWDEVICE;
+
+
+/*
+ * Structures for alpha surface information
+ */
+typedef struct _ALPHADEVICE
+{
+    unsigned char * lpALPOverlaySurface;
+    unsigned long  dwALPPhysicalAddr;
+    unsigned long  dwPitch;
+    unsigned long  gdwALPSrcWidth;
+    unsigned long  gdwALPSrcHeight;
+    unsigned long  gdwALPDstWidth;
+    unsigned long  gdwALPDstHeight;
+    unsigned long  gdwALPDstLeft;
+    unsigned long  gdwALPDstTop;
+}ALPHADEVICE;
+typedef ALPHADEVICE * LPALPHADEVICE;
+
+
+/*
+ * Structures for LOCK surface
+ */
+
+typedef struct _DDLOCK
+{
+    unsigned long     dwVersion;
+    unsigned long     dwFourCC;
+    unsigned long     dwPhysicalBase;
+    SUBDEVICE       SubDev[2];   /*for two HW MPEG*/
+    SWDEVICE    SWDevice;
+    ALPHADEVICE ALPDevice;
+
+} DDLOCK;
+typedef DDLOCK * LPDDLOCK;
+
+/*
+ * Structures for create surface
+ */
+typedef struct _DDSURFACEDESC
+{
+    unsigned long     dwSize;      /* size of the DDSURFACEDESC structure*/
+    unsigned long     dwFlags;     /* determines what fields are valid*/
+    unsigned long     dwHeight;    /* height of surface to be created*/
+    unsigned long     dwWidth;     /* width of input surface*/
+    unsigned long      lPitch;      /* distance to start of next line(return value)*/
+    unsigned long     dwBackBufferCount;     /* number of back buffers requested*/
+    void *    lpSurface;             /* pointer to the surface memory*/
+    unsigned long     dwColorSpaceLowValue;  /* low boundary of color space that is to*/
+                                     /* be treated as Color Key, inclusive*/
+    unsigned long     dwColorSpaceHighValue; /* high boundary of color space that is*/
+                                     /* to be treated as Color Key, inclusive*/
+    unsigned long     dwFourCC;              /* (FOURCC code)*/
+} DDSURFACEDESC;
+typedef DDSURFACEDESC * LPDDSURFACEDESC;
+
+
+
+/*
+ * structure for passing information to UpdateOverlay fn
+ */
+typedef struct _RECTL
+{
+    unsigned long     left;
+    unsigned long     top;
+    unsigned long     right;
+    unsigned long     bottom;
+} RECTL;
+
+typedef struct _DDUPDATEOVERLAY
+{
+    RECTL     rDest;          /* dest rect */
+    RECTL     rSrc;           /* src rect */
+    unsigned long     dwFlags;        /* flags */
+    unsigned long     dwColorSpaceLowValue;
+    unsigned long     dwColorSpaceHighValue;
+    unsigned long     dwFourcc;
+} DDUPDATEOVERLAY;
+typedef DDUPDATEOVERLAY * LPDDUPDATEOVERLAY;
+
+/* Definition for dwFlags */
+#define DDOVER_HIDE       0x00000001
+#define DDOVER_SHOW       0x00000002
+#define DDOVER_KEYDEST    0x00000004
+#define DDOVER_ENABLE     0x00000008
+#define DDOVER_CLIP       0x00000010
+#define DDOVER_ON_SND     0x80000000 	/*Video is on Secondary Screen*/
+#define DDOVER_ON_PRI     0x00000000 	/*Video is on Primary Screen*/
+#define DDOVER_BOB        0x00200000l	/* Use deinterlace mode to show video */
+
+typedef struct _ALPHACTRL{
+    unsigned char type;
+    unsigned char ConstantFactor;   /* only valid in bit0 - bit3 */
+    unsigned long AlphaEnable;
+} ALPHACTRL , *LPALPHACTRL;
+
+#define ALPHA_CONSTANT  0x01
+#define ALPHA_STREAM    0x02
+#define ALPHA_DISABLE   0x03
+#define ALPHA_GRAPHIC   0x04
+#define ALPHA_COMBINE   0x05
+
+
+typedef struct _VIAVIDCTRL{
+  unsigned long dwCompose;
+  unsigned long dwHighQVDO;
+  unsigned long dwAction;
+  unsigned long dwHQVSwitchFlag;
+} VIAVIDCTRL;
+typedef VIAVIDCTRL * LPVIAVIDCTRL;
+
+/* Video Control definition */
+/* dwCompose, Define which video overlay on top when V1 & V3 on simultaneously */
+#define VW_DVD_TOP               0x00000010
+#define VW_TV_TOP                0x00000020
+#define VW_TV0_TOP               0x00000100
+#define VW_TV1_TOP               0x00000200
+
+/* dwHighQVDO, Define which resource uses HQV engine */
+#define VW_HIGHQVDO_SWITCH       0x00000000
+#define VW_HIGHQVDO_OFF          0x00000000
+#define VW_HIGHQVDO_MPEG         0x00000001
+#define VW_HIGHQVDO_SW           0x00000002
+#define VW_HIGHQVDO_TV0          0x00000004
+#define VW_HIGHQVDO_TV1          0x00000008
+  
+/* dwAction */
+#define ACTION_SET_COMPOSE     1
+#define ACTION_SET_HQV         2
+
+
+typedef struct
+{
+    unsigned long   dwCPKey;
+    unsigned long   dwLevel;
+} MACROVISIONINFO, *LPMACROVISIONINFO;
+
+/* Definition for MacroVision level */
+#define MV_Off 				0
+#define MV_NoColorsrtipping	1
+#define MV_2LineColorstripping	2
+#define MV_4LineColorstripping	3
+
+/*
+ *  Structure for Capture information
+ */
+typedef struct _VIACAPINFO{
+  int CapInterVersion;    /* The capture internal version */
+  int NoAutoDetect;
+  unsigned long dwCapPort;  		/* indicate the data belong to which capture port, 0 or 1 */
+  unsigned long dwDeinterlaceMode;  /* Capture deinterlace mode: bob/weave */
+  unsigned long FieldSwap;          /* input field swap, only for Capture 0 */
+  unsigned long No_HFilter;         /* Capture horizontal filter select   */
+  unsigned long Capture_OverScanOff;   /* Capture Over Scan function select    */
+  unsigned long VideoDecoder;       /* VideoDecoder type */
+  unsigned long Tuner;              /* Tuner type */
+  unsigned long TVEncoder;          /* TVEncoder type */
+  int   SourceWidth;                /* Capture Source Width */
+  int   SourceHeight;               /* Capture Source Height */
+  int   Vdec_Slave_Write;
+  int   Tuner_Slave_Write;
+  int   TVEncoder_Slave_Write;
+  int   DataWidth;                  /* data output bus: 8 or 16 */
+  int   CompositeMode;
+  int   SVideoMode;
+  int   TunerMode;
+  int   Scaler;                     /* 1: use video decoder scaler function, 0: not use */
+  int   Brightness;
+  int   Contrast;
+  int   Hue;
+  int   Saturation;
+  int   Standard;                   /* PAL/NTSC/SECAM */
+  unsigned long Reserved[62];       /* For future use */
+} VIACAPINFO;
+typedef VIACAPINFO * LPVIACAPINFO;
+
+/* Definition for dwDeinterlaceMode */
+#define CAP_WEAVE           0x0
+#define CAP_BOB             0x1
+#define CAP_MEDIAN          0x2
+
+/* Definition for VideoDecoder type */
+#define CAP_NONE            0
+#define CAP_SAA7113H        0x01
+#define CAP_SAA7108H        0x02
+#define CAP_SAA7114H        0x03
+
+/* Definition for Tuner type */
+#define FI1236MK2           0x01
+
+/* Definition for Cap standard */
+#define VIDEO_MODE_PAL		0
+#define VIDEO_MODE_NTSC		1
+#define VIDEO_MODE_SECAM	2
+
+
+/*
+ * Return value of VMI
+ */
+
+#define VMI_OK                              0x00
+#define VMI_ERR                             0x01
+#define VMI_ERR_NO_X_WINDOW                 VMI_ERR +1
+#define VMI_ERR_CANNOT_OPEN_VIDEO_DEVICE    VMI_ERR +2
+#define VMI_ERR_CANNOT_USE_IOCTL            VMI_ERR +3
+#define VMI_ERR_CANNOT_CREATE_SURFACE       VMI_ERR +4
+#define VMI_ERR_CANNOT_SHMGET		  VMI_ERR+5
+#define VMI_ERR_CANNOT_SHMAT				  VMI_ERR+6
+
+/*
+ * Exported Driver functions
+ */
+
+unsigned long VIADriverProc(unsigned long wAction, void * lpParam);
+unsigned long VIABeginPicture(void * lpMPGSurface);
+unsigned long VIAEndPicture(void * lpMPGSurface);
+unsigned long VIASetMacroBlock(void * lpMPGSurface, void * lpMB);
+unsigned long VIASliceReceiveData(unsigned long dwByteCount, unsigned char * lpData);
+unsigned long VIASliceReceiveDataEx(unsigned long dwByteCount, unsigned char * lpData, unsigned long dwEncryptKey);
+unsigned long VIASingleSliceReceiveData(unsigned long dwCount, unsigned char * lpSliceData, unsigned long sCode);
+unsigned long VIADisplayControl(unsigned long devType, void * lpData);
+unsigned long VIASUBPicture(void * lpSubp);
+
+
+/* =========================================================================
+ * New structure for VMI 2.0
+ * =========================================================================*/
+
+#define MAX_FRAME_BUFFERS           8
+
+/*
+ * Structure of VMI information
+ */
+typedef struct _VMI_INFO_PARAM
+{
+    unsigned long     dwAPIVersion;		/* [in/out] for AP & driver sync the status */
+    unsigned long     handle;			/* [out] for 2 H/W mpeg2 */
+} VMI_INFO_PARAM, * LPVMI_INFO_PARAM;
+
+/*
+ * Structure for FLIP
+ */
+typedef struct _VMI_FLIP_PARAM
+{
+    unsigned long     dwDisplayBuffIndex;   /* the back buffer index to flip */
+    unsigned long     dwDisplayPictStruct;  /* flip frame/top field/bottom field */
+} VMI_FLIP_PARAM, * LPVMI_FLIP_PARAM;
+
+/* dwDisplayPictStruct */
+#define VIA_PICT_STRUCT_TOP                 0x00000001
+#define VIA_PICT_STRUCT_BOTTOM              0x00000002
+#define VIA_PICT_STRUCT_FRAME               0x00000003
+
+
+/*
+ * Exported Driver functions
+ */
+unsigned long VMI_Create(LPVMI_INFO_PARAM lpVMI_Info);
+unsigned long VMI_DriverProc(LPVMI_INFO_PARAM lpVMI_Info, unsigned long dwAction, void *lpParam1, void *lpParam2);
+unsigned long VMI_Destroy(LPVMI_INFO_PARAM lpVMI_Info);
+unsigned long VMI_QueryHWCapability(unsigned long dwAction, void *lpHWCapability);
+
+/*
+ *  dwAction for VMI_QueryHWCapability functions
+ */
+#define HW_MPEG_Capability             0x00
+#define HW_VID_Capability                0x01
+#define HW_OVERLAY_Capability       0x02
+
+/* definition for HW_MPEG_Capability */
+#define HW_MPEG2_SLICE      0x00000001
+#define HW_MPEG2_IDCT       0x00000002
+#define HW_MPEG2_MC         0x00000004
+#define HW_MPEG4_SLICE      0x00000010
+#define HW_MPEG4_IDCT       0x00000020
+#define HW_MPEG4_MC         0x00000040
+#define HW_MPEG2_x2         0x00000100
+#define HW_HDTV             0x00000200
+#define HW_MPEG4_INUSED     0x1000000
+#define HW_MPEG2_INUSED     0x10000000
+#define HW_WMV9_SLICE       0x00001000
+#define HW_WMV9_IDCT        0x00002000
+#define HW_WMV9_MC          0x00004000
+
+
+/* definition for HW_VID_Capability */
+#define HW_VID_ALPHA16     0x00000001
+#define HW_VID_ALPHA256    0x00000002
+
+/* definition for HW_OVERLAY_Capability */
+#define HW_OVERLAY_NV12      0x00000001
+#define HW_OVERLAY_YV12      0x00000002
+#define HW_OVERLAY_YUY2      0x00000004
+
+
+typedef struct _VIDEOCOLOR{
+  long dwAction;
+  long hue;
+  long saturation;
+  long brightness;
+  long contrast;
+} VIDEOCOLOR;
+typedef VIDEOCOLOR * LPVIDEOCOLOR;
+
+#define DEFAULT_SYS_HUE         0
+#define DEFAULT_SYS_SATURATION  10000
+#define DEFAULT_SYS_BRIGHTNESS  750
+#define DEFAULT_SYS_CONTRAST    10000
+
+#define OVERLAYSCHEMEFILENAME   ".VIAOVERLAYRC" 
+
+/* Definition for Video Color dwAction*/
+#define VIDEOCOLOR_DEFAULT      0
+#define VIDEOCOLOR_LOADFILE     1
+#define VIDEOCOLOR_SAVEFILE     2
+#define VIDEOCOLOR_VALUE        3
+
+typedef struct _HWFEATURES{
+  long dwAction;
+  long value1;
+  long value2;
+  long value3;
+  long value4;
+} HWFEATURES;
+typedef HWFEATURES * LPHWFEATURES;
+
+/* Definition for HW Features dwAction*/
+#define SET_FBD_YUVBYPASS       0
+#define SET_HQV_FILTER          1
+
+#endif  /* end of _VIAVID_H */
diff -ruN xine-lib-1.1.2-via/src/xine-engine/video_out.h xine-lib-1.1.2-my-2/src/xine-engine/video_out.h
--- xine-lib-1.1.2-via/src/xine-engine/video_out.h	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/xine-engine/video_out.h	2006-10-18 21:43:55.000000000 +0300
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 1998-2006 VIA Technologies, Inc.
+ * Copyright (c) 2001-2006 S3 Graphics Co., Ltd.
  * Copyright (C) 2000-2004 the xine project
  * 
  * This file is part of xine, a free video player.
@@ -59,6 +61,43 @@
 typedef struct video_driver_class_s video_driver_class_t;
 typedef struct vo_overlay_s vo_overlay_t;
 typedef struct video_overlay_manager_s video_overlay_manager_t;
+// KGy CLE266_VO
+typedef struct vo_accel_s vo_accel_t;
+
+#define OSD_TO_SHOW	0x00000001
+#define OSD_TO_HIDE		0x00000010
+#define OSD_SHOWN		0x00000100
+#define OSD_HIDEN		0x00001000
+#define OSD_ORI			0x00
+#define OSD_ALPHA      	0x01
+#define OSD_COLORKEY_PRI 0x02
+#define OSD_COLORKEY_SND 0x12
+
+// KGy CLE266_VO
+/* One thing on vo_frame_t and update_frame_format() prototype.
+ * Update frame format works on a compare with old and new basis
+ *   and vo_frame_t only for "new" status. We can make the old
+ *   status public in vo_frame_t and reduce update_frame_format()
+ *   parameter count.
+ * This will work since in video_out.c:get_frame() all new status
+ *   had already got their value.
+ * This will looks better.
+ * One additional thing, update may fail, but now
+ *   we take no care of this.
+ */
+/* Hint for post:
+ *   Most post will not work on accelerator.
+ *   For port in post, just add intercept function in post.c is OK.
+ *   But for frame in post, every post plugin shall be modified:
+ *   1, Post plugin shall always get frame from the original port so that
+ *     frame management is kept intact.
+ *   2, Post plugin shall check frame format in all post replacement functions,
+ *     and make the behavior to be the same as no post for frames in 
+ *     accelerator format. And it shall free all frames when they encounter with
+ *     accelerator format frame.
+ *   3, ToDo: More things may be added here.
+ */
+
 
 /* public part, video drivers may add private fields
  *
@@ -87,6 +126,17 @@
   /* tell video driver that the decoder starts a new field */
   void (*field) (vo_frame_t *vo_img, int which_field);
 
+ // KGy CLE266_VO
+  /* One hint for accelerator programming:
+   * The draw() function must go through this path to utilize
+   *   xine's vo mechanism and to obey the frame management logic.
+   * But there may be the need of aditional info attached to particular
+   *   frame, or related to particular frame, for the accelerator to
+   *   perform the actual display action.
+   * This can be done with a custom function provided through the 
+   *   vo_accel_s interface or at accel_decode() time.
+   */
+   
   /* append this frame to the display queue, 
      returns number of frames to skip if decoder is late */
   /* when the frame does not originate from a stream, it is legal to pass an anonymous stream */
@@ -103,7 +153,7 @@
 
   /* free memory/resources for this frame */
   void (*dispose) (vo_frame_t *vo_img);
-
+   
   /*
    * public variables to decoders and vo drivers
    * changing anything here will require recompiling them both
@@ -163,6 +213,7 @@
   
   int                        id; /* debugging - track this frame */
   int                        is_first;
+ 
 };
 
 
@@ -174,6 +225,12 @@
 struct xine_video_port_s {
 
   uint32_t (*get_capabilities) (xine_video_port_t *self); /* for constants see below */
+ 
+  // Return an array of strings which are interface id. The array is terminated by a NULL pointer.
+  const char **(*query_special_interface)(xine_video_port_t *self);
+  // Return the pointer to the base of the interface, if success. If failed, return NULL.
+  const vo_special_interface_t *(*get_special_interface)(xine_video_port_t *self,
+							 const char *id);
 
   /* open display driver for video output */
   /* when you are not a full-blown stream, but still need to open the port
@@ -248,7 +305,55 @@
 #define VO_PROP_WINDOW_HEIGHT         16 /* read-only */
 #define VO_PROP_BUFS_IN_FIFO          17 /* read-only */
 #define VO_PROP_NUM_STREAMS           18 /* read-only */
-#define VO_NUM_PROPERTIES             19
+
+#define VO_PROP_MACROVISION           25
+#define VO_PROP_USECOLORKEY           26
+#define VO_PROP_OUTPUTENABLED         27
+#define VO_PROP_MACROVISION_SUPPORTED 28  // KGy Bool.
+#define VO_PROP_TVOUT                 29  // KGy Bool, set only.
+#define VO_PROP_YUVBYPASS               36  /* bool */ 
+#define VO_PROP_HQVFILTER          37   /* uint 0-2 */
+#define VO_PROP_HW_MPEG_Capability    38  /*zhaolin[2005.9.27]:add property to judge if had the ability of PIP*/
+#define VO_PROP_TVOVERLAY               39 /*bool. 1: open tv overlay; 0: close tv overlay*/
+
+#define VO_NUM_PROPERTIES             40  /*size of props array, joyce*/
+
+
+  // KGy CLE266_VO
+  /* Add Macrovision support here.
+   * This is a HW feature/property, can be supported by accelerator.
+   * So now this property will be used by specific vo_driver.
+   * Though this is not a common property, I don't think place it here
+   *   is bad, other drivers can set MIN = MAX = 0 to this indicating
+   *   it is not supporting this property.
+   * 
+   * Add USECOLORKEY property here.
+   * This property is mainly for FB environent. According to different
+   *   UI design, it can be better to use or don't use colorkey, so
+   *   this property is here to enable UI to control wether the colorkey
+   *   will be used. Most vo_driver plugin can ignore this.
+   *
+   * Add OUTPUTENABLED property here.
+   * This property is mainly for FB environment. Some UI design will
+   *   be much simpler if the video output can be turned off.
+   *   Most vo_driver plugin can ignore this.
+   *
+   * For TVOUT property: shall be set/get type ... need driver support.
+   *
+   * ToDo: re-order these definations and update the defination in xine.h.in.
+   */
+
+/* Macrovision specific constants here. Added the VO prefix. */
+#define VO_MV_Off                       0
+#define VO_MV_NoColorsrtipping          1
+#define VO_MV_2LineColorstripping       2
+#define VO_MV_4LineColorstripping       3
+
+/* zoom specific constants FIXME: generate this from xine.tmpl.in */
+#define VO_ZOOM_STEP        100
+#define VO_ZOOM_MAX         400
+#define VO_ZOOM_MIN         100
+
 
 /* number of colors in the overlay palette. Currently limited to 256
    at most, because some alphablend functions use an 8-bit index into
@@ -279,6 +384,109 @@
 #define VO_CAP_XXMC                   0x00000040 /* driver can use extended XvMC */
 
 
+//Jack Liu added, 2005-2-4 10:13, for VMI interface. Because XVMC/XXMC can only be used in X11 env.
+//We put forward a universal capability that can be used both on fb and x11.video_out_vmi is needed.
+#define VO_CAP_MPEG2_SLICE			  0x00000100 /* similar with VO_CAP_XXMC, but use VMI */
+#define VO_CAP_MPEG4_IDCT			  0x00000200 /* similar with VO_CAP_XVMC_IDCT, but use VMI */
+
+#define VO_CAP_HUE                    0x00000400 /* driver can set HUE value                */
+#define VO_CAP_SATURATION             0x00000800 /* driver can set SATURATION value         */
+#define VO_CAP_BRIGHTNESS             0x00001000 /* driver can set BRIGHTNESS value         */
+#define VO_CAP_CONTRAST               0x00002000 /* driver can set CONTRAST value           */
+#define VO_CAP_COLORKEY               0x00004000 /* driver can set COLORKEY value           */
+#define VO_CAP_AUTOPAINT_COLORKEY     0x00008000 /* driver can set AUTOPAINT_COLORKEY value */
+#define VO_CAP_HW_HDTV  			  0x00010000 /* cle266...  can't support mpeg2 HD HW decoding. joyce added*/
+
+#define VO_CAP_MPEG2_MC            0x00020000  /*zhaolin[2006.06.09]: add for HW MC of mpeg2*/
+
+
+// KGy CLE266_VO
+/* vo_accel_s is a dummy structure for video decoding accelerator to
+ *   build their interface upon.
+ */
+/* VO_ACCEL programming guide: accelerator specific header file:
+ * Each hardwire accelerator shall provide a header file to the
+ *   decoder, and decoders want to use the accelerator shall
+ *   include it.
+ * The header file shall contain the actual accelerator interface
+ *   structure built upon the vo_accel_s.
+ * And all needed structure and constant definations shall be included
+ *   in the header file.
+ * Since the accelerator and the decoder conform to the same
+ *   data stream standard, there shall be a lot of definations have
+ *   the same meaning. For such definations, we shall use decoder's defination
+ *   in decoder code and use driver's defination in driver code.
+ *   THIS IS NOT  GOOD BUT TO AVOID CONFUSION WE GET BY, and MAKE SURE
+ *   that the meaning is really the same.
+ * For other definations, accelerator specific prefix shall be added to
+ *   the definations for the read-ability of decoder code.
+ */
+/*=> Change:
+ * 1, The vo_accel_s provided by driver is supposed to be a statical
+ *      structure for read-only use by the decoder.
+ * 2, All functions provided here shall be able to check working environment
+ *      and be safe to run at any time.
+ * 3, Decoder will include the accelerator's headerfile instead of the ones
+ *      we provide here in xine internally. This reduces the work of creating
+ *      out own accelerator header file. For example, CLE266 will cause
+ *      "viamgh.h" incuded by libmpeg2 source.
+ * 4, Existing accelerators will place its interface structure here instead of
+ *      in a stand-alone header file.
+ */
+/*=> Behavoir comment:
+ * I got this comment from libmpeg2 modification for decoding MPEG1.
+ * The CLE266 accelerator can not decode all MPEG1 streams, and
+ *   its develpers strongly recommend to use software decoding for MPEG1.
+ * Then there is a requirement that libmpeg2 decoder shall change its
+ *   acceleration configuration upon input data format.
+ * And there may be dynamic format chagne during one run, I've seen a DVD with
+ *   MPEG2 menu, etc and MPEG1 content.
+ * I think this simple design is better and shall be used for all such cases:
+ * 1, Decoder shall get all available accelerators and software decoding,
+ *    and get an array of different FourCC_Config and func_config, that is all ready.
+ * 2, Decoder shall know the data stream format before getting the first frame
+ *    used to decode the data stream, then chagne to correct configuration and
+ *    get the corresponding format frame, to enable the corresponding accelerator.
+ * 3, For accelerator, the interface provided to decoder shall be static. This means
+ *    that the decoder can get one accelerator and keep it for later use, even
+ *    the accelerator may be put aside and not used for some time.
+ * 4, For a video output plugin, all action needed to enable an accelerator, or,
+ *    make the vo_driver to switch one of its acceleration configuration, shall be
+ *    a simple get_frame() with corresponging frame format, no other action needed.
+ * This shall be possible for any accelerator implementation, IMHO.
+ * Every action needed for an accelerator driver, such as CLE266 video driver and XvMC
+ *   driver, has its time to get done.
+ */
+struct vo_accel_s {
+  uint32_t     FourCC_id;
+  vo_driver_t *driver;
+  /* This is for decoder to pass an instance to the accelerator function.
+   * This is provided by the actua vo_driver and not the post plugin.
+   * ToDo: any better solution?
+   */
+};
+
+// Definations for accelerating capability.
+#define UNICHROME_VDEC_CAP_MPEG2_SLICE 0x00000001
+#define UNICHROME_VDEC_CAP_MPEG4_IDCT  0x00000020
+
+typedef struct cle266_accel_s {
+  vo_accel_t vo_accel;
+
+  unsigned int  (* query_capability)(vo_driver_t* driver);
+  /* Infact decode_info is a VIAMPGSURFACE, use void since
+   *   the defination of VIAMPGSURFACE is not available here.
+   */
+  void (* begin_frame)(vo_driver_t *driver,
+		       vo_frame_t  *cur_frame_gen,
+		       vo_frame_t  *fr_frame_gen,
+		       vo_frame_t  *br_frame_gen,
+		       void *decode_info);
+  void (* render_frame)(vo_driver_t *driver,
+			void *decode_data);
+} cle266_accel_t;
+
+
 /*
  * vo_driver_s contains the functions every display driver
  * has to implement. The vo_new_port function (see below)
@@ -293,6 +501,25 @@
 struct vo_driver_s {
 
   uint32_t (*get_capabilities) (vo_driver_t *self); /* for constants see above */
+  
+    //tzhou CLE266_VO
+  /*Get last frame from hardware, used for snapshot.
+  *  frame information put into img
+  * the format of img is YV12, the order is y, u, v
+  *  return 1 if succeed
+  *            0 if fail
+  */
+  uint32_t (*get_last_frame_from_hw)(vo_driver_t *self, uint8_t *img,  int width, int height);
+
+  const char **(*query_special_interface)(vo_driver_t *self);
+  /* Return the pointer to the base of the interface, if success.
+   *   If failed, return NULL.
+   * Returns a non const pointer for vo_port to add its this pointer
+   *   into the interface structure.
+   * Shall be NULL if no query_special_interface() supported.
+   */
+  vo_special_interface_t *(*get_special_interface)(vo_driver_t *self,
+						   const char *id);
 
   /*
    * allocate an vo_frame_t struct,
@@ -304,9 +531,27 @@
    * check if the given image fullfills the format specified
    * (re-)allocate memory if necessary
    */
+ //VeXP3.6 Jack Liu begin 2005-1-6 18:30   
+ // KGy CLE266_VO
+  // Now the function may Fail!
+  /* This is also used to change the vo_driver to accelerator mode.
+   * The change to accelerator mode process is also a free-allocate
+   *   process.
+   * If succeed, the frame is returned with corresponding format
+   *  FourCC code.
+   * If failed, the frame is returned with "\0\0\0\0" FourCC code.
+   * And there shall be ONLY ONE thread that call update_frame_format(), the
+   *   video decoder thread. Or the vo_driver will get confused by
+   *   requests of different frame format's during the one period.
+   * ToDo: make sure only one decoder will call update_frame_format to request
+   *   only one format at any given period. Some post plugin may use more than
+   *   one format.
+   */
   void (*update_frame_format) (vo_driver_t *self, vo_frame_t *img,
 			       uint32_t width, uint32_t height,
-			       double ratio, int format, int flags);
+			       double ratio, uint32_t format, int flags);
+  // KGy CLE266_VO
+  // Change format to uint32_t type, for correct FourCC comparision.
 
   /* display a given frame */
   void (*display_frame) (vo_driver_t *self, vo_frame_t *vo_img);
@@ -413,6 +658,21 @@
   int               hili_rgb_clut; /* true if clut was converted to rgb */
   
   int               unscaled;      /* true if it should be blended unscaled */
+   //VeXP 3.6 Jack Liu, KGy CLE266_VO
+  /* Our HW can only deal with IA44 picture, so treat osd overlay and
+   *   subpicture from DVD differently.
+   * This flag can be extended to "overlay_type" if needed.
+   */
+  int               osd_overlay;  // TRUE: for OSD, FALSE: for sub-picture.
+
+    /*added for direct draw osd- Dave*/
+  uint32_t       osd_status;
+  uint8_t         osd_type;
+  int 			old_x;
+  int 			old_y;
+  int 			old_width;
+  int 			old_height;
+
 };
 
 
diff -ruN xine-lib-1.1.2-via/src/xine-engine/vo_scale.c xine-lib-1.1.2-my-2/src/xine-engine/vo_scale.c
--- xine-lib-1.1.2-via/src/xine-engine/vo_scale.c	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/xine-engine/vo_scale.c	2006-10-18 21:43:55.000000000 +0300
@@ -72,9 +72,15 @@
     case XINE_VO_ASPECT_SQUARE:
       desired_ratio = image_ratio;
       break;
+    case XINE_VO_ASPECT_3_2:
+      desired_ratio = 3.0 / 2.0;
+      break;
     case XINE_VO_ASPECT_4_3:
-    default:
       desired_ratio = 4.0 / 3.0;
+      break;
+    case XINE_VO_ASPECT_FULL_WINDOW:
+    default:
+      desired_ratio = (double)this->gui_width / (double)this->gui_height;
     }
 
     this->video_pixel_aspect = desired_ratio / image_ratio;
@@ -126,7 +132,6 @@
   } else {
 
     if ( this->support_zoom ) {
-    
       /* zoom behaviour: 
        * - window size never changes due zooming
        * - output image shall be increased whenever there are
@@ -141,6 +146,7 @@
         if( this->output_height * this->zoom_factor_y <= this->gui_height ) {
           this->displayed_height = cropped_height;
           this->output_height = (double)this->output_height * this->zoom_factor_y + 0.5;
+          
         } else {
           this->displayed_height = (double)cropped_height *
             this->gui_height / this->output_height / this->zoom_factor_y + 0.5;
@@ -245,6 +251,7 @@
 int _x_vo_scale_redraw_needed (vo_scale_t *this) {
   int gui_x, gui_y, gui_width, gui_height, gui_win_x, gui_win_y;
   double gui_pixel_aspect;
+  int gui_screen;
   int ret = 0;
   
   if( this->frame_output_cb ) {
@@ -253,7 +260,7 @@
 			   this->delivered_height - (this->crop_top + this->crop_bottom), 
 			   this->video_pixel_aspect,
 			   &gui_x, &gui_y, &gui_width, &gui_height,
-			   &gui_pixel_aspect, &gui_win_x, &gui_win_y );
+			   &gui_pixel_aspect, &gui_win_x, &gui_win_y, &gui_screen );
   } else {
     printf ("vo_scale: error! frame_output_cb must be set!\n");
   }
@@ -261,15 +268,23 @@
   if ( (gui_x != this->gui_x) || (gui_y != this->gui_y)
       || (gui_width != this->gui_width) || (gui_height != this->gui_height)
       || (gui_pixel_aspect != this->gui_pixel_aspect)
-      || (gui_win_x != this->gui_win_x) || (gui_win_y != this->gui_win_y) ) {
+      || (gui_win_x != this->gui_win_x) || (gui_win_y != this->gui_win_y) 
+      || (gui_screen != this->output_on_snd)) {
 
     this->gui_x      = gui_x;
     this->gui_y      = gui_y;
-    this->gui_width  = gui_width;
-    this->gui_height = gui_height;
+    
+    if(gui_width!=0)
+     	this->gui_width  = gui_width;
+    if(gui_height!=0)
+     	this->gui_height = gui_height;
+
     this->gui_win_x  = gui_win_x;
     this->gui_win_y  = gui_win_y;
-    this->gui_pixel_aspect = gui_pixel_aspect;
+    if(gui_height!=0)
+   	this->gui_pixel_aspect = gui_pixel_aspect;
+    if(gui_screen==1||gui_screen==0)
+     	this->output_on_snd=gui_screen;
 
     ret = 1;
   }
@@ -330,6 +345,10 @@
     return "16:9";
   case XINE_VO_ASPECT_DVB:
     return "2:1";
+  case XINE_VO_ASPECT_3_2:
+    return "3:2";
+  case XINE_VO_ASPECT_FULL_WINDOW:
+    return "full window";
   default:
     return "unknown";
   }
diff -ruN xine-lib-1.1.2-via/src/xine-engine/vo_scale.h xine-lib-1.1.2-my-2/src/xine-engine/vo_scale.h
--- xine-lib-1.1.2-via/src/xine-engine/vo_scale.h	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/xine-engine/vo_scale.h	2006-10-18 21:43:55.000000000 +0300
@@ -107,6 +107,9 @@
    */
   double             gui_pixel_aspect;
   double             video_pixel_aspect;
+  
+  /* under samm,user can change display screen by callback-Dave*/
+  int		    output_on_snd;
 
   /*
    * "output" size:
@@ -134,7 +137,7 @@
 			   int *dest_x, int *dest_y, 
 			   int *dest_width, int *dest_height,
                            double *dest_pixel_aspect,
-			   int *win_x, int *win_y);
+			   int *win_x, int *win_y, int *screen);
   
   void (*dest_size_cb) (void *user_data,
 			int video_width, int video_height, 
diff -ruN xine-lib-1.1.2-via/src/xine-engine/xine_internal.h xine-lib-1.1.2-my-2/src/xine-engine/xine_internal.h
--- xine-lib-1.1.2-via/src/xine-engine/xine_internal.h	2006-07-26 19:44:36.000000000 +0300
+++ xine-lib-1.1.2-my-2/src/xine-engine/xine_internal.h	2006-10-18 21:43:55.000000000 +0300
@@ -227,7 +227,11 @@
 
   /* input_dvd uses this one. is it possible to add helper functions instead? */
   spu_decoder_t             *spu_decoder_plugin;
-    
+
+  //JulionLiang, 2006-4-25
+  // used for mpeg2 Closed Caption.
+  spu_decoder_t             *spucc_decoder_plugin;
+  
   /* dxr3 use this one, should be possible to fix to use the port instead */
   vo_driver_t               *video_driver;
   
@@ -256,6 +260,7 @@
   int                        video_thread_created;
   video_decoder_t           *video_decoder_plugin;
   int                        video_decoder_streamtype;
+  int                        last_video_decoder_streamtype;/*zhaolin:add one var for judge of  update overlay*/
   extra_info_t              *video_decoder_extra_info;
   int                        video_channel;
   
