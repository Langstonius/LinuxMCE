#!/bin/sh -e
##
## 01_play_speed_patch
##

. debian/patches/patch-opts

if [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi

case "$1" in
       -patch) patch $patch_opts -p1 < $0;;
       -unpatch) patch $patch_opts -p1 -R < $0;;
        *)
                echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
                exit 1;;
esac

exit 0

@DPATCH@
diff -ruN -X ex.pat xine-lib-1.1.1-orig/include/xine.h xine-lib-1.1.1/include/xine.h
--- xine-lib-1.1.1-orig/include/xine.h	2005-11-15 13:41:03.000000000 +0200
+++ xine-lib-1.1.1/include/xine.h	2006-05-10 07:58:42.000000000 +0300
@@ -251,6 +251,31 @@
 int  xine_play (xine_stream_t *stream, int start_pos, int start_time);
 
 /*
+ * seeks a stream to a given position
+ * 
+ * semantics is similar to xine_play, but previous playback 
+ * speed is not changed (e.g. if a stream was paused it will remain paused
+ */
+int  xine_seek (xine_stream_t *stream, int start_pos, int start_time);
+
+/* starts seeking playback (audio is muted, video is played with given speed)
+ * trick_speed: 
+ * 1x = 1.000.000 of trick speed, 
+ * positive - forward, negative - backward
+ * returns:
+ * 1 - no error
+ * 0 - error
+ */
+int xine_start_trick_play(xine_stream_t *stream, int trick_speed);
+
+/* stops trick playback and restore original playback mode
+ * returns:
+ * 1 - no error
+ * 0 - error
+ */
+int xine_stop_trick_play(xine_stream_t *stream);
+
+/*
  * set xine to a trick mode for fast forward, backwards playback,
  * low latency seeking. Please note that this works only with some
  * input plugins. mode constants see below.
@@ -905,6 +930,15 @@
 #define XINE_STREAM_INFO_DVD_ANGLE_NUMBER   34
 #define XINE_STREAM_INFO_DVD_ANGLE_COUNT    35
 
+
+/* custom values for xine_(start|stop)_trick_play functionality */
+#define XINE_STREAM_INFO_TRICK_PLAY_SUPPORTED    51 /* 0 - not supported, 1 - supported */
+#define XINE_STREAM_INFO_TRICK_PLAY_ENABLED 52 /* trick play is on now */
+#define XINE_STREAM_INFO_TRICK_PLAY_CURRENT_SPEED 53 /* current trick play speed */
+#define XINE_STREAM_INFO_TRICK_PLAY_ORIGINAL_SPEED 54 /* original speed to restore to */
+#define XINE_STREAM_INFO_TRICK_PLAY_DISTINCTS_FRAME_TYPE 55 /* if stream distincts frames types */
+
+
 /* possible values for XINE_STREAM_INFO_VIDEO_AFD */
 #define XINE_VIDEO_AFD_NOT_PRESENT         -1
 #define XINE_VIDEO_AFD_RESERVED_0          0
diff -ruN -X ex.pat xine-lib-1.1.1-orig/include/xine.h.in xine-lib-1.1.1/include/xine.h.in
--- xine-lib-1.1.1-orig/include/xine.h.in	2005-10-30 04:18:35.000000000 +0200
+++ xine-lib-1.1.1/include/xine.h.in	2006-05-10 08:10:47.000000000 +0300
@@ -251,6 +251,31 @@
 int  xine_play (xine_stream_t *stream, int start_pos, int start_time);
 
 /*
+ * seeks a stream to a given position
+ * 
+ * semantics is similar to xine_play, but previous playback 
+ * speed is not changed (e.g. if a stream was paused it will remain paused
+ */
+int  xine_seek (xine_stream_t *stream, int start_pos, int start_time);
+
+/* starts seeking playback (audio is muted, video is played with given speed)
+ * trick_speed: 
+ * 1x = 1.000.000 of trick speed, 
+ * positive - forward, negative - backward
+ * returns:
+ * 1 - no error
+ * 0 - error
+ */
+int xine_start_trick_play(xine_stream_t *stream, int trick_speed);
+
+/* stops trick playback and restore original playback mode
+ * returns:
+ * 1 - no error
+ * 0 - error
+ */
+int xine_stop_trick_play(xine_stream_t *stream);
+
+/*
  * set xine to a trick mode for fast forward, backwards playback,
  * low latency seeking. Please note that this works only with some
  * input plugins. mode constants see below.
@@ -905,6 +930,15 @@
 #define XINE_STREAM_INFO_DVD_ANGLE_NUMBER   34
 #define XINE_STREAM_INFO_DVD_ANGLE_COUNT    35
 
+
+/* custom values for xine_(start|stop)_trick_play functionality */
+#define XINE_STREAM_INFO_TRICK_PLAY_SUPPORTED    51 /* 0 - not supported, 1 - supported */
+#define XINE_STREAM_INFO_TRICK_PLAY_ENABLED 52 /* trick play is on now */
+#define XINE_STREAM_INFO_TRICK_PLAY_CURRENT_SPEED 53 /* current trick play speed */
+#define XINE_STREAM_INFO_TRICK_PLAY_ORIGINAL_SPEED 54 /* original speed to restore to */
+#define XINE_STREAM_INFO_TRICK_PLAY_DISTINCTS_FRAME_TYPE 55 /* if stream distincts frames types */
+
+
 /* possible values for XINE_STREAM_INFO_VIDEO_AFD */
 #define XINE_VIDEO_AFD_NOT_PRESENT         -1
 #define XINE_VIDEO_AFD_RESERVED_0          0
diff -ruN -X ex.pat xine-lib-1.1.1-orig/src/libmpeg2/decode.c xine-lib-1.1.1/src/libmpeg2/decode.c
--- xine-lib-1.1.1-orig/src/libmpeg2/decode.c	2005-06-18 01:33:02.000000000 +0300
+++ xine-lib-1.1.1/src/libmpeg2/decode.c	2006-05-10 06:19:33.000000000 +0300
@@ -166,6 +166,8 @@
   }
   _x_stream_info_set(mpeg2dec->stream, XINE_STREAM_INFO_FRAME_DURATION, frame->duration);
   /*printf("mpeg2dec: rff=%u\n",frame->repeat_first_field);*/
+  _x_stream_info_set(mpeg2dec->stream, XINE_STREAM_INFO_TRICK_PLAY_SUPPORTED, 1);
+  _x_stream_info_set(mpeg2dec->stream, XINE_STREAM_INFO_TRICK_PLAY_DISTINCTS_FRAME_TYPE, 1);
 } 
 
 static double get_aspect_ratio(mpeg2dec_t *mpeg2dec)
diff -ruN -X ex.pat xine-lib-1.1.1-orig/src/xine-engine/video_out.c xine-lib-1.1.1/src/xine-engine/video_out.c
--- xine-lib-1.1.1-orig/src/xine-engine/video_out.c	2005-11-15 01:48:19.000000000 +0200
+++ xine-lib-1.1.1/src/xine-engine/video_out.c	2006-05-10 06:28:53.000000000 +0300
@@ -497,6 +497,45 @@
       return 0;
     }
   }
+  
+  // trick playback code
+  // doing frames skip depending on skip mode and stream smartness
+  if (stream->trick_play_stream_distincts_frame_type)
+  {
+	  switch (stream->trick_play_frame_skip_mode)
+	  {
+		 // no skip
+		case 0:
+			break;
+		
+		// skip B-frames
+		  case 1:
+			  xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "trick_play: skipping B-frame\n");
+			  frames_to_skip = 2;
+			  if ((img->picture_coding_type!=1)&&(img->picture_coding_type!=2))
+				  return 2;
+			break;
+		
+		// skip B&P-frames
+		  case 2:
+			  xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "trick_play: skipping B/P-frame\n");
+			  frames_to_skip = 4;
+			  if ((img->picture_coding_type!=1))
+				  return 4;
+			  break;
+		// no skip
+		  default:
+			  break;
+	  }
+  }
+  else
+  {
+	  if (stream->trick_play_frame_skip_mode)
+	  {
+		  xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "trick_play: skipping ?-frame\n");
+		  frames_to_skip = 1;
+	  }
+  }
 
 
   if (!img->bad_frame) {
@@ -641,6 +680,7 @@
     this->num_frames_skipped   = 0;
   }
   
+  //return frames_to_skip;
   return frames_to_skip;
 }
 
diff -ruN -X ex.pat xine-lib-1.1.1-orig/src/xine-engine/xine.c xine-lib-1.1.1/src/xine-engine/xine.c
--- xine-lib-1.1.1-orig/src/xine-engine/xine.c	2005-10-30 04:18:35.000000000 +0200
+++ xine-lib-1.1.1/src/xine-engine/xine.c	2006-05-10 07:08:09.000000000 +0300
@@ -1225,6 +1225,241 @@
   return ret;
 }
 
+static int seek_internal (xine_stream_t *stream, int start_pos, int start_time) {
+
+	int        demux_status;
+	int        demux_thread_running;
+	int        xine_original_speed;
+
+	xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "xine_seek\n");
+
+	if (!stream->demux_plugin) {
+		xine_log (stream->xine, XINE_LOG_MSG, _("xine_seek: no demux available\n"));
+		stream->err = XINE_ERROR_NO_DEMUX_PLUGIN;
+
+		return 0;
+	}
+
+	xine_original_speed = _x_get_speed(stream);
+  
+	/* hint demuxer thread we want to interrupt it */
+	stream->demux_action_pending = 1;
+
+	/* set normal speed */
+	if (_x_get_speed(stream) != XINE_SPEED_NORMAL)
+		set_speed_internal (stream, XINE_FINE_SPEED_NORMAL);
+  
+	stream->xine->port_ticket->acquire(stream->xine->port_ticket, 1);
+  
+	/* only flush/discard output ports on master streams */
+	if( stream->master == stream && !stream->gapless_switch) {
+		/* discard audio/video buffers to get engine going and take the lock faster */
+		if (stream->audio_out)
+			stream->audio_out->set_property(stream->audio_out, AO_PROP_DISCARD_BUFFERS, 1);
+		if (stream->video_out)
+			stream->video_out->set_property(stream->video_out, VO_PROP_DISCARD_FRAMES, 1);
+	}
+  
+	pthread_mutex_lock( &stream->demux_lock );
+	/* demux_lock taken. now demuxer is suspended */
+	stream->demux_action_pending = 0;
+
+  /* set normal speed again (now that demuxer/input pair is suspended) 
+	* some input plugin may have changed speed by itself, we must ensure
+	* the engine is not paused.
+  */
+	if (_x_get_speed(stream) != XINE_SPEED_NORMAL)
+		set_speed_internal (stream, XINE_FINE_SPEED_NORMAL);
+  
+  /*
+	* start/seek demux
+  */
+
+	/* seek to new position (no data is sent to decoders yet) */
+	demux_status = stream->demux_plugin->seek (stream->demux_plugin,
+			start_pos, start_time, 
+			stream->demux_thread_running);
+
+	/* only flush/discard output ports on master streams */
+	if( stream->master == stream && !stream->gapless_switch) {
+		if (stream->audio_out)
+			stream->audio_out->set_property(stream->audio_out, AO_PROP_DISCARD_BUFFERS, 0);
+		if (stream->video_out)
+			stream->video_out->set_property(stream->video_out, VO_PROP_DISCARD_FRAMES, 0);
+	}
+  
+	stream->xine->port_ticket->release(stream->xine->port_ticket, 1);
+  
+	/* before resuming the demuxer, set first_frame_flag */
+	pthread_mutex_lock (&stream->first_frame_lock);
+	stream->first_frame_flag = 2;
+	pthread_mutex_unlock (&stream->first_frame_lock);
+
+	/* before resuming the demuxer, reset current position information */
+	pthread_mutex_lock( &stream->current_extra_info_lock );
+	_x_extra_info_reset( stream->current_extra_info );
+	pthread_mutex_unlock( &stream->current_extra_info_lock );
+
+	demux_thread_running = stream->demux_thread_running;
+  
+	/* now resume demuxer thread if it is running already */
+	pthread_mutex_unlock( &stream->demux_lock );
+
+	if (demux_status != DEMUX_OK) {
+		xine_log (stream->xine, XINE_LOG_MSG, _("xine_seek: demux failed to start\n"));
+
+		stream->err = XINE_ERROR_DEMUX_FAILED;
+		stream->first_frame_flag = 0;
+		return 0;
+
+	} else {
+		if (!demux_thread_running) {
+			_x_demux_start_thread( stream );
+			stream->status = XINE_STATUS_PLAY;
+		}
+	}
+
+
+  /* Wait until the first frame produced is displayed
+	* see video_out.c
+  */
+	wait_first_frame (stream);
+
+	set_speed_internal(stream, xine_original_speed);
+  
+	xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "seek_internal ...done\n");
+
+	return 1;
+}
+
+int xine_seek (xine_stream_t *stream, int start_pos, int start_time) {
+
+	int ret;
+
+	pthread_mutex_lock (&stream->frontend_lock);
+
+	ret = seek_internal (stream, start_pos, start_time);
+	if( stream->slave && (stream->slave_affection & XINE_MASTER_SLAVE_PLAY) )
+		xine_seek (stream->slave, start_pos, start_time);
+  
+	stream->gapless_switch = 0;
+
+	pthread_mutex_unlock (&stream->frontend_lock);
+  
+	return ret;
+}
+
+static int start_trick_play_internal(xine_stream_t *stream, int trick_speed)
+{
+	xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "start_trick_play_internal\n");
+
+	if (_x_stream_info_get(stream, XINE_STREAM_INFO_TRICK_PLAY_SUPPORTED)==0)
+	{
+		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "start_trick_play_internal: stream doesn't support trick play\n");
+		return 0;
+	}
+	
+	// backward playback is impossible at the moment
+	if (trick_speed<0)
+	{
+		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "start_trick_play_internal: stream doesn't support reverse trick play\n");
+		return 0;
+	}
+	
+	_x_stream_info_set(stream, XINE_STREAM_INFO_TRICK_PLAY_ORIGINAL_SPEED, _x_get_fine_speed(stream));
+	_x_stream_info_set(stream, XINE_STREAM_INFO_TRICK_PLAY_CURRENT_SPEED, trick_speed);
+	
+	// 0x - 4x => showing all frames
+	// 4x - 8x => skipping B-frames
+	// >8x => skipping P-frames
+	
+	xine_set_param(stream, XINE_PARAM_IGNORE_AUDIO, 1);
+	
+	stream->trick_play_stream_distincts_frame_type = _x_stream_info_get(stream, XINE_STREAM_INFO_TRICK_PLAY_DISTINCTS_FRAME_TYPE);	
+	
+	if (trick_speed<=4*XINE_FINE_SPEED_NORMAL)
+	{
+		stream->trick_play_frame_skip_mode = 0;
+	}
+	else if (trick_speed<=8*XINE_FINE_SPEED_NORMAL)
+	{
+		stream->trick_play_frame_skip_mode = 1;
+	}
+	else
+	{
+		stream->trick_play_frame_skip_mode = 2;
+	}
+	
+	set_speed_internal(stream, trick_speed);
+	
+	_x_stream_info_set(stream, XINE_STREAM_INFO_TRICK_PLAY_ENABLED, 1);
+	
+	xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "start_trick_play_internal: ...done\n");
+	
+	return 1;
+}
+
+int xine_start_trick_play(xine_stream_t *stream, int trick_speed) {
+
+	int ret;
+
+	pthread_mutex_lock (&stream->frontend_lock);
+
+	ret = start_trick_play_internal (stream, trick_speed);
+	if( stream->slave && (stream->slave_affection & XINE_MASTER_SLAVE_PLAY) )
+		xine_start_trick_play (stream->slave, trick_speed);
+  
+	pthread_mutex_unlock (&stream->frontend_lock);
+  
+	return ret;
+}
+
+static int stop_trick_play_internal(xine_stream_t *stream)
+{
+	xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal\n");
+
+	if (_x_stream_info_get(stream, XINE_STREAM_INFO_TRICK_PLAY_SUPPORTED)==0)
+	{
+		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: stream doesn't support trick play\n");
+		return 0;
+	}
+	
+	if (_x_stream_info_get(stream, XINE_STREAM_INFO_TRICK_PLAY_ENABLED)==0)
+	{
+		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: stream is not in trick play mode\n");
+		return 1;
+	}
+	
+	stream->trick_play_frame_skip_mode = 0;
+	
+	set_speed_internal(stream, _x_stream_info_get(stream, XINE_STREAM_INFO_TRICK_PLAY_ORIGINAL_SPEED) );	
+	xine_set_param(stream, XINE_PARAM_IGNORE_AUDIO, 0);
+	
+	_x_stream_info_set(stream, XINE_STREAM_INFO_TRICK_PLAY_ENABLED, 0);
+		
+	_x_stream_info_set(stream, XINE_STREAM_INFO_TRICK_PLAY_ORIGINAL_SPEED, 0);
+	_x_stream_info_set(stream, XINE_STREAM_INFO_TRICK_PLAY_CURRENT_SPEED, 0);
+	
+	
+	xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: ...done\n");
+	
+	return 1;
+}
+
+int xine_stop_trick_play(xine_stream_t *stream) {
+	int ret;
+
+	pthread_mutex_lock (&stream->frontend_lock);
+
+	ret = stop_trick_play_internal (stream);
+	if( stream->slave && (stream->slave_affection & XINE_MASTER_SLAVE_PLAY) )
+		xine_stop_trick_play (stream->slave);
+  
+	pthread_mutex_unlock (&stream->frontend_lock);
+  
+	return ret;
+}
+
 int xine_eject (xine_stream_t *stream) {
   
   int status;
diff -ruN -X ex.pat xine-lib-1.1.1-orig/src/xine-engine/xine_internal.h xine-lib-1.1.1/src/xine-engine/xine_internal.h
--- xine-lib-1.1.1-orig/src/xine-engine/xine_internal.h	2005-10-30 04:18:35.000000000 +0200
+++ xine-lib-1.1.1/src/xine-engine/xine_internal.h	2006-05-10 05:41:16.000000000 +0300
@@ -338,6 +338,12 @@
                                                * layers as they cannot call xine_stop. */
   int                        early_finish_event; /* do not wait fifos get empty before sending event */
   int                        gapless_switch;     /* next stream switch will be gapless */
+  
+  int                        trick_play_frame_skip_mode; /* what frames to skip: 0 - no frames skipped 
+  					* by trick play, 1 - B-frames are skipped, 2 - B&P-frames are skipped, 
+					 * 3 - B&P&I-frames are skipped (impossible) */
+  int                        trick_play_stream_distincts_frame_type; /* 0 - doesn't distinct between I/P/B-frames (ffmpeg decoder), 
+							    * 1 - distincts between I/P/B-frames (see xvmc.h header ) */
 #endif
 };
 
