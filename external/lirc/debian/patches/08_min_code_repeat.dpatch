#! /bin/sh /usr/share/dpatch/dpatch-run
## 08_min_code_repeat.dpatch by Cyril Lacoux <clacoux@easter-eggs.com>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Allow proper interpretation of repeat signals for Creative RM-900
## DP: Closes #367521 reported by Peter Colberg <peterco@gmx.net>

@DPATCH@
diff -urNad trunk~/daemons/config_file.c trunk/daemons/config_file.c
--- trunk~/daemons/config_file.c	2006-05-17 10:56:40.000000000 +0200
+++ trunk/daemons/config_file.c	2006-05-17 10:57:43.000000000 +0200
@@ -1,4 +1,4 @@
-/*      $Id: config_file.c,v 5.20 2005/06/18 20:39:45 lirc Exp $      */
+/*      $Id: config_file.c,v 5.21 2006/01/22 12:58:50 lirc Exp $      */
 
 /****************************************************************************
  ** config_file.c ***********************************************************
@@ -422,6 +422,10 @@
 		rem->min_repeat=s_strtoi(val);
 		return(1);
 	}
+	else if (strcasecmp("min_code_repeat",key)==0){
+		rem->min_code_repeat=s_strtoi(val);
+		return(1);
+	}
 	else if (strcasecmp("frequency",key)==0){
 		rem->freq=s_strtoui(val);
 		return(1);
@@ -910,6 +914,16 @@
 				rem->bits_in_byte=8;
 			}
 		}
+		if(rem->min_code_repeat>0)
+		{
+			if(!has_repeat(rem) ||
+			   rem->min_code_repeat>rem->min_repeat)
+			{
+				logprintf(LOG_WARNING,
+					  "invalid min_code_repeat value");
+				rem->min_code_repeat = 0;
+			}
+		}
 		rem=rem->next;
 	}
 
diff -urNad trunk~/daemons/dump_config.c trunk/daemons/dump_config.c
--- trunk~/daemons/dump_config.c	2006-05-17 10:56:40.000000000 +0200
+++ trunk/daemons/dump_config.c	2006-05-17 10:57:43.000000000 +0200
@@ -1,4 +1,4 @@
-/*      $Id: dump_config.c,v 5.16 2005/02/07 15:44:08 lirc Exp $      */
+/*      $Id: dump_config.c,v 5.17 2006/01/22 12:58:50 lirc Exp $      */
 
 /****************************************************************************
  ** dump_config.c ***********************************************************
@@ -170,6 +170,11 @@
 		{
 			fprintf(f, "  min_repeat      %d\n",rem->min_repeat);
 		}
+		if(rem->min_code_repeat>0)
+		{
+			fprintf(f, "  min_code_repeat %d\n",
+				rem->min_code_repeat);
+		}
 		fprintf(f, "  toggle_bit      %d\n\n",rem->toggle_bit);
 		if(has_toggle_mask(rem))
 		{
diff -urNad trunk~/daemons/ir_remote_types.h trunk/daemons/ir_remote_types.h
--- trunk~/daemons/ir_remote_types.h	2006-05-17 10:56:40.000000000 +0200
+++ trunk/daemons/ir_remote_types.h	2006-05-17 10:57:43.000000000 +0200
@@ -1,4 +1,4 @@
-/*      $Id: ir_remote_types.h,v 5.4 2005/06/18 20:39:45 lirc Exp $      */
+/*      $Id: ir_remote_types.h,v 5.5 2006/01/22 12:58:50 lirc Exp $      */
 
 /****************************************************************************
  ** ir_remote_types.h *******************************************************
@@ -138,6 +138,12 @@
 	int toggle_bit;             /* 1..bits */
 	int min_repeat;             /* code is repeated at least x times
 				       code sent once -> min_repeat=0 */
+	unsigned int min_code_repeat;/*meaningful only if remote sends
+				       a repeat code: in this case
+				       this value indicates how often
+				       the real code is repeated
+				       before the repeat code is being
+				       sent */
 	unsigned int freq;          /* modulation frequency */
 	unsigned int duty_cycle;    /* 0<duty cycle<=100 */
 	ir_code toggle_mask;        /* Sharp (?) error detection scheme */
diff -urNad trunk~/daemons/receive.c trunk/daemons/receive.c
--- trunk~/daemons/receive.c	2006-05-17 10:56:40.000000000 +0200
+++ trunk/daemons/receive.c	2006-05-17 10:57:43.000000000 +0200
@@ -1,4 +1,4 @@
-/*      $Id: receive.c,v 5.29 2005/10/20 18:43:36 lirc Exp $      */
+/*      $Id: receive.c,v 5.30 2006/01/22 12:58:50 lirc Exp $      */
 
 /****************************************************************************
  ** receive.c ***************************************************************
@@ -1258,7 +1258,7 @@
 		} /* end of mode specific code */
 	}
 	*prep=pre;*codep=code;*postp=post;
-	if(!has_repeat(remote) &&
+	if((!has_repeat(remote) || remote->reps<remote->min_code_repeat) &&
 	   expect_at_most(remote, sync, remote->remaining_gap))
 		*repeat_flagp=1;
 	else
