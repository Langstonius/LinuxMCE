#!/bin/sh /usr/share/dpatch/dpatch-run

## opt-37_submenu.dpatch by Jlac, Sad <sad@ntica.com> (submenu plugin)
##
## extracted from submenu plugin 0.0.2
## original filename: vdr-submenu-patch-1.3.1x-from-orig.diff
##
## Thomas Günther <tom@toms-cafe.de>:
##   - made independend from enAIO patch
##   - fixed current menu item
##   http://toms-cafe.de/vdr/download/vdr-submenu-0.5-1.3.1x.diff
##
## Tobias Grimm <tg@e-tobi.net>
##   - free char buffers allocated by asprintf
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: This patch is needed for the submenu plugin.

@DPATCH@
diff -urNad --exclude=CVS --exclude=.svn ./Makefile /tmp/dpep-work.6MlaIL/vdr-1.3.30/Makefile
--- ./Makefile	2005-08-24 00:49:10.000000000 +0200
+++ /tmp/dpep-work.6MlaIL/vdr-1.3.30/Makefile	2005-08-24 00:49:10.000000000 +0200
@@ -41,7 +41,7 @@
        lirc.o menu.o menuitems.o nit.o osdbase.o osd.o pat.o player.o plugin.o rcu.o\
        receiver.o recorder.o recording.o remote.o remux.o ringbuffer.o sdt.o sections.o\
        skinclassic.o skins.o skinsttng.o sources.o spu.o status.o svdrp.o themes.o thread.o\
-       timers.o tools.o transfer.o vdr.o videodir.o
+       timers.o tools.o transfer.o vdr.o videodir.o submenu.o
 
 OBJS += osdcontroller.o rcontroller.o dvbsub.o vdrttxtsubshooks.o
 
diff -urNad --exclude=CVS --exclude=.svn ./menu.c /tmp/dpep-work.6MlaIL/vdr-1.3.30/menu.c
--- ./menu.c	2005-08-24 00:49:10.000000000 +0200
+++ /tmp/dpep-work.6MlaIL/vdr-1.3.30/menu.c	2005-08-24 00:49:10.000000000 +0200
@@ -2699,11 +2699,110 @@
      Add(new cOsdItem(tr(" Cancel editing"), osCancelEdit));
   }
 
-  // Basic menu items:
+//SubMenu Patch
+  bool SubMenuActive=cPluginManager::GetPlugin("submenu");
+  if (SubMenuActive)
+	submenu.offset = Count();
 
-  Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
-  Add(new cOsdItem(hk(tr("Channels")),   osChannels));
-  Add(new cOsdItem(hk(tr("Timers")),     osTimers));
+if ( SubMenuActive && !Plugin)
+{
+cPlugin *p;
+/*
+0::Schedule
+0::Channels
+0:1:Games
+1::games
+1::freecell
+1::solitaire
+*/
+
+// Parse info of current Menu
+// add item of menu
+	for( int i = 0; i < submenu.nbSubMenuItem; i++)
+	{
+		if( submenu.subMenuItem[i].menuLevel == submenu.currentMenuLevel )
+		{
+			if( submenu.subMenuItem[i].kindOfItem == 0 )
+			{
+			// Basic menu items:
+				if( strcmp(submenu.subMenuItem[i].name,"Schedule") == 0 )
+					Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
+
+				if( strcmp(submenu.subMenuItem[i].name,"Channels") == 0 )
+					Add(new cOsdItem(hk(tr("Channels")),   osChannels));
+
+				if( strcmp(submenu.subMenuItem[i].name,"Timers") == 0 )
+					Add(new cOsdItem(hk(tr("Timers")),     osTimers));
+
+				if( strcmp(submenu.subMenuItem[i].name,"Recordings") == 0 )
+					Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
+                                if( strcmp(submenu.subMenuItem[i].name,"Setup") == 0 )
+					                                        Add(new cOsdItem(hk(tr("Setup")),      osSetup));
+
+				if( strcmp(submenu.subMenuItem[i].name,"Commands") == 0 )
+				{
+					if (Commands.Count())
+						Add(new cOsdItem(hk(tr("Commands")),  osCommands));
+				}
+				// Plugins Item:
+				int j=0;
+				do
+				{
+					p = cPluginManager::GetPlugin(j);
+					if( p != NULL )
+					{
+						const char *item = p->MainMenuEntry();
+						if (item)
+						{
+							if( strcmp( submenu.subMenuItem[i].name , p->Name() ) == 0 )
+							Add(new cMenuPluginItem(hk(item), j));
+						}
+				}
+				j++;
+		}
+		while( p != NULL);
+	}
+        else
+	{
+		Add(new cOsdItem(hk(submenu.subMenuItem[i].name), osUser9));
+	}
+    }
+}
+      /* Add all plugin entry not listed in config file  */
+if ( submenu.currentMenuLevel == 0 )
+{
+	int j=0;
+	do
+	{
+		p = cPluginManager::GetPlugin(j);
+		if( p != NULL )
+		{
+			const char *item = p->MainMenuEntry();
+			if (item)
+			{
+				int trv = 0;
+				for( int i = 0; i < submenu.nbSubMenuItem; i++)
+				{
+					if( strcmp( submenu.subMenuItem[i].name , p->Name() ) == 0 )
+						trv = 1;
+				}
+				if(trv == 0)
+					Add(new cMenuPluginItem(hk(item), j));
+			}
+		}
+		j++;
+	}
+	while( p != NULL);
+	}
+
+}
+else
+{
+// Basic menu items:
+
+Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
+Add(new cOsdItem(hk(tr("Channels")),   osChannels));
+Add(new cOsdItem(hk(tr("Timers")),     osTimers));
   Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
 
   // Plugins:
@@ -2726,6 +2825,7 @@
   Add(new cOsdItem(hk(tr("Setup")),      osSetup));
   if (Commands.Count())
      Add(new cOsdItem(hk(tr("Commands")),  osCommands));
+}
 
   if (!Setup.MenuCmdPosition) {
   // Replay control:
@@ -2794,6 +2894,24 @@
                           return osEnd;
                           }
                        break;
+    case osBack:
+		       if (submenu.nbLevelMenu > 0)
+		       {
+			       submenu.nbLevelMenu--;
+			       submenu.currentMenuLevel = submenu.oldNumberMenu[ submenu.nbLevelMenu ];
+			       Set(NULL);
+			       return osContinue;
+		       }	
+		       else
+			       return osEnd;
+		       break;
+    case osUser9:
+		       submenu.oldNumberMenu[ submenu.nbLevelMenu] = submenu.currentMenuLevel;
+		       submenu.nbLevelMenu++;
+		       submenu.currentMenuLevel = submenu.GetByLevel(submenu.currentMenuLevel,Current()-submenu.offset);
+		       Set(NULL);
+		       return osContinue;
+		       break;
     case osPlugin:     {
                          cMenuPluginItem *item = (cMenuPluginItem *)Get(Current());
                          if (item) {
diff -urNad --exclude=CVS --exclude=.svn ./menu.h /tmp/dpep-work.6MlaIL/vdr-1.3.30/menu.h
--- ./menu.h	2005-08-24 00:49:10.000000000 +0200
+++ /tmp/dpep-work.6MlaIL/vdr-1.3.30/menu.h	2005-08-24 00:49:10.000000000 +0200
@@ -17,6 +17,7 @@
 #include "dvbplayer.h"
 #include "recorder.h"
 #include "skins.h"
+#include "submenu.h"
 
 class cMenuText : public cOsdMenu {
 private:
@@ -32,6 +33,7 @@
 class cMenuMain : public cOsdMenu {
 private:
   time_t lastActivity;
+  cSubMenu submenu;
   bool replaying;
   static cOsdObject *pluginOsdObject;
   void Set(const char *Plugin = NULL);
diff -urNad --exclude=CVS --exclude=.svn ./submenu.c /tmp/dpep-work.6MlaIL/vdr-1.3.30/submenu.c
--- ./submenu.c	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6MlaIL/vdr-1.3.30/submenu.c	2005-08-24 00:51:50.000000000 +0200
@@ -0,0 +1,397 @@
+#include "submenu.h"
+#include <string.h>
+#include <stdio.h>
+#include "plugin.h"
+
+cSubMenuItemInfo::cSubMenuItemInfo()
+	{
+	    menuLevel = 0;
+	    kindOfItem = 0;
+	    name[0] = 0;
+	}
+
+cSubMenuItemInfo::~cSubMenuItemInfo()
+{
+}
+
+void cSubMenuItemInfo::setname(const char *n)
+{
+	int i,l;
+	l = strlen(n);
+
+	for(i=0;i<SIZEMAXNAMESUBMENUITEMINFO;i++)
+	name[i] = 0;
+
+	if( l >= SIZEMAXNAMESUBMENUITEMINFO )
+	l = SIZEMAXNAMESUBMENUITEMINFO;
+
+	for(i=0;i<l;i++)
+	{
+		name[i] = n[i];
+	}
+    name[i]=0;
+    name[l]=0;
+} 
+
+
+void cSubMenu::LoadInfoSubMenu(void)
+{
+	FILE *f;
+	char *fichier;
+	char lig[80];
+	int j;
+
+	
+	nbSubMenuItem = 0;
+	asprintf(&fichier,"%s/MainMenu.conf",cPlugin::ConfigDirectory());
+	f = fopen(fichier,"rt");
+	if ( f != NULL)
+	{
+		while (fgets(lig,80,f) ) 
+		{
+			ParseOneLigOfFile( lig );
+		}
+		fclose(f);
+	}
+	else
+	{
+		/* -- create example file -- */
+		FILE *fo;
+		cPlugin *p;
+
+		fo=fopen(fichier,"wt");
+		if (fo!=NULL)
+		{
+			fprintf(fo,"0::Schedule\n");
+			fprintf(fo,"0::Channels\n");
+			fprintf(fo,"0:1:Recorder\n");
+			fprintf(fo,"0:2:Plugins\n");
+			fprintf(fo,"0:3:Games\n");
+			fprintf(fo,"0:4:Installation\n");
+
+			fprintf(fo,"1::Timers\n");
+			fprintf(fo,"1::Recordings\n");
+			fprintf(fo,"4::Setup\n");
+			fprintf(fo,"4::Commands\n");
+
+			// Plugins Item:
+			j=0;
+			do
+			{
+				p = cPluginManager::GetPlugin(j);
+				if ( p != NULL )
+				{
+					fprintf(fo,"2::%s\n",p->Name());
+				}
+				j++;
+			}
+			while (p !=NULL);
+
+			fclose(fo);
+			LoadInfoSubMenu();
+			Arbo.Populate(this);
+		}
+		/* -- Create example file -- */
+	}
+	free(fichier);
+}
+
+void cSubMenu::ParseOneLigOfFile(const char *lig)
+{
+	int level=-1;
+	int kind=-1;
+	int i,j,l;
+	char txt[SIZEMAXNAMESUBMENUITEMINFO];
+	char name[SIZEMAXNAMESUBMENUITEMINFO];
+	int fin,status = 0;
+	int namefound = 0;
+
+	l = strlen(lig);
+
+	name[0]= 0;
+
+	fin = 0;
+
+	i=0;j=0;
+
+	while( fin == 0)
+	{
+		switch(status)
+		{
+			case 0: //looking for level
+				txt[j++] = lig[i];
+				if ( lig[i] == ':' )
+				{
+					txt[j] = 0;
+					status ++;
+					level = atoi(txt);
+					j = 0;
+				}
+
+				break;
+			case 1:
+				txt[j++] = lig[i];
+				if (lig[i] == ':')
+				{
+					txt[j] = 0;
+					status ++;
+					kind = atoi(txt);
+					j = 0;
+				}
+				break;
+			case 2:
+				if (lig[i]>32 || lig[i]<0)
+					name[j++] = lig[i];
+				if(lig[i]== 0)
+				{
+					name[j]=0;
+					namefound=1;
+					status++;
+				}
+
+				break;
+			default:
+				break;
+
+		}
+		if (lig[i] == '/')
+			fin = 1;
+		if (lig[i] == 0)
+			fin = 1;
+		if ( i == l )
+			fin = 1;
+
+		i++;
+	}
+
+	if (level!=-1 && kind!=-1 && namefound==1)
+	{
+		name[j]=0;
+		subMenuItem[nbSubMenuItem].menuLevel = level;
+		subMenuItem[nbSubMenuItem].kindOfItem = kind;
+		subMenuItem[nbSubMenuItem].setname(name);
+		nbSubMenuItem++;
+	}
+}
+
+void cSubMenu::SaveInfoSubMenu()
+{
+	//Dump();
+	FILE *f;
+	char *fichier;
+	asprintf(&fichier,"%s/MainMenu.conf",cPlugin::ConfigDirectory());
+	f=fopen(fichier,"w");
+	if (f)
+	{
+	  for (int i=0;i<nbSubMenuItem;i++)
+	  {
+		  fprintf(f,"%i:%i:%s\n",subMenuItem[i].menuLevel,subMenuItem[i].kindOfItem,subMenuItem[i].name);
+	  }
+	  fclose(f);
+	}
+	free(fichier);
+}
+
+cSubMenu::~cSubMenu()
+{
+	delete [] subMenuItem;
+}
+
+cSubMenu::cSubMenu()
+{
+	subMenuItem = new cSubMenuItemInfo[NBMAXSUBMENUANDITEM];
+
+	nbLevelMenu = 0;
+	currentMenuLevel = 0;
+	LoadInfoSubMenu();
+	Arbo.Populate(this);
+	offset=0;
+}
+
+int cSubMenu::GetByLevel (int Level, int curr)
+{
+	int j=0;
+	int Index[NBMAXSUBMENUANDITEM];
+	for (int i=0;i<nbSubMenuItem;i++)
+	{
+		if (subMenuItem[i].menuLevel==Level)
+		{
+			Index[j]=i;
+			j++;
+		}
+	}
+	return subMenuItem[Index[curr]].kindOfItem;
+}
+int cSubMenu::GetByLevel (int Level)
+{
+	/*
+	int Index[NBMAXSUBMENUANDITEM];
+	int j=0;
+	for (int i=0;i<nbSubMenuItem;i++)
+	{
+		if (subMenuItem[i].menuLevel==Level)
+		{
+			Index[j]=i;
+			j++;
+		}
+	Index[j]=-1;
+	}
+	return Index;
+	*/
+	return 0;
+}
+
+void cSubMenu::CreateItem(int type,int position,int where,char *Name)
+{ 
+	int OldMenuLevel;
+	switch(type)
+	{
+		case 0:
+			switch(where)
+			{
+				case 0:
+					OldMenuLevel=subMenuItem[position].menuLevel;
+					InsertItem(position);
+					subMenuItem[position].setname(Name);
+					subMenuItem[position].menuLevel=OldMenuLevel;
+					subMenuItem[position].kindOfItem=Arbo.MaxLevel+1;
+					break;
+				case 1: 
+					OldMenuLevel=subMenuItem[position].menuLevel;
+					InsertItem(position);
+					subMenuItem[position+1].setname(Name);
+					subMenuItem[position+1].menuLevel=OldMenuLevel;
+					subMenuItem[position+1].kindOfItem=Arbo.MaxLevel+1;
+					break;
+				case 2:
+					OldMenuLevel=subMenuItem[position].kindOfItem;
+					InsertItem(position);
+					subMenuItem[position+1].setname(Name);
+					subMenuItem[position+1].menuLevel=OldMenuLevel;
+					subMenuItem[position+1].kindOfItem=Arbo.MaxLevel+1;
+					break;
+				default:
+					break;
+			}
+			Arbo.Populate(this);
+			break;
+		case 1 :
+			switch(where)
+			{
+				case 0:
+					OldMenuLevel=subMenuItem[position].menuLevel;
+					InsertItem(position);
+					subMenuItem[position].setname(Name);
+					subMenuItem[position].menuLevel=OldMenuLevel;
+					subMenuItem[position].kindOfItem=0;
+					break;
+				case 1:
+					OldMenuLevel=subMenuItem[position].menuLevel;
+					InsertItem(position);
+					subMenuItem[position+1].setname(Name);
+					subMenuItem[position+1].menuLevel=OldMenuLevel;
+					subMenuItem[position+1].kindOfItem=0;
+					break;
+				case 2:
+					OldMenuLevel=subMenuItem[position].kindOfItem;
+					InsertItem(position);
+					subMenuItem[position+1].setname(Name);
+					subMenuItem[position+1].menuLevel=OldMenuLevel;
+					subMenuItem[position+1].kindOfItem=0;
+					break;
+			}
+			Arbo.Populate(this);
+			break;
+		default :
+			break;
+	}
+}
+void cSubMenu::Dump(void)
+{
+	for (int i=0;i<nbSubMenuItem;i++)
+	{
+		fprintf(stderr,"%i Nom : %s Menu : %i Kind : %i\n",i,subMenuItem[i].name,subMenuItem[i].menuLevel,subMenuItem[i].kindOfItem);
+	}
+}
+
+void cSubMenu::DeleteItem(int position,int kindItem)
+{
+	int Kind;
+	if (kindItem!=-1)
+		Kind=kindItem;
+	else
+		Kind=subMenuItem[position].kindOfItem;
+	for(int i=position;i<nbSubMenuItem;i++)
+	{
+		subMenuItem[i]=subMenuItem[i+1];	
+	}
+	nbSubMenuItem--;
+	Arbo.Populate(this);
+	if (Kind!=0)
+	{
+		for(int i=position;i<nbSubMenuItem;i++)
+		{
+			if (subMenuItem[i].menuLevel==Kind)
+			{
+				DeleteItem(i,subMenuItem[i].kindOfItem);
+				i--;
+			}
+		}
+	}
+	Arbo.Populate(this);
+}
+
+void cSubMenu::InsertItem(int position)
+{
+	for (int i=nbSubMenuItem;i>position;i--)
+	{
+		subMenuItem[i]=subMenuItem[i-1];
+	}
+	nbSubMenuItem++;
+	Arbo.Populate(this);
+}
+
+
+cArbo::cArbo(void)
+{
+	MaxLevel=0;
+	for (int i=0;i<NBMAXSUBMENUANDITEM;i++)
+	{
+		MaxItem[i]=0;
+	}
+}
+
+void cArbo::Clear()
+{
+	MaxLevel=0;
+	for (int i=0;i<NBMAXSUBMENUANDITEM;i++)
+	{
+		MaxItem[i]=0;
+		for (int j=0;j<NBMAXSUBMENUANDITEM;j++)
+		{
+			Index[i][j]=0;
+		}
+	}
+}
+
+cArbo::~cArbo(void)
+{
+}
+
+void cArbo::Populate(cSubMenu *submenu)
+{
+  Clear();
+  for (int i=0;i<submenu->nbSubMenuItem;i++)
+  {
+  Index[ submenu->subMenuItem[i].menuLevel ][ submenu->Arbo.MaxItem[submenu->subMenuItem[i].menuLevel]] = i;
+  submenu->Arbo.MaxItem[submenu->subMenuItem[i].menuLevel]++;
+  if (submenu->subMenuItem[i].menuLevel > submenu->Arbo.MaxLevel) 
+	  {
+		  submenu->Arbo.MaxLevel = submenu->subMenuItem[i].menuLevel;
+	  }
+  if (submenu->subMenuItem[i].kindOfItem > submenu->Arbo.MaxLevel)
+	  {
+		  submenu->Arbo.MaxLevel = submenu->subMenuItem[i].kindOfItem;
+	  }
+  }
+}
diff -urNad --exclude=CVS --exclude=.svn ./submenu.h /tmp/dpep-work.6MlaIL/vdr-1.3.30/submenu.h
--- ./submenu.h	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6MlaIL/vdr-1.3.30/submenu.h	2005-08-24 00:49:10.000000000 +0200
@@ -0,0 +1,62 @@
+#ifndef __SUBMENU_H
+#define __SUBMENU_H
+
+#define SIZEMAXNAMESUBMENUITEMINFO 30
+#define NBMAXSUBMENUANDITEM 50
+
+class cSubMenu;
+
+class cSubMenuItemInfo
+{
+	private:
+	public:
+		cSubMenuItemInfo();
+		~cSubMenuItemInfo();
+
+		int menuLevel;
+		int kindOfItem;
+		char name[SIZEMAXNAMESUBMENUITEMINFO];  //todo revoir ca(la taille en dur)
+
+		void setname(const char *n);
+};
+
+class cArbo
+{
+	private:
+	public:
+	      cArbo(void);
+	      ~cArbo(void);
+	      int Index[NBMAXSUBMENUANDITEM][NBMAXSUBMENUANDITEM];
+	      int CurrentIndex[NBMAXSUBMENUANDITEM];
+	      int MaxLevel;
+	      int MaxItem[NBMAXSUBMENUANDITEM];
+	      void Populate(cSubMenu *submenu);
+              void Clear(void);
+};
+
+class cSubMenu
+{
+	private:
+	public:
+		int currentMenuLevel;
+		cSubMenuItemInfo *subMenuItem;
+		cArbo Arbo;
+		int nbSubMenuItem;
+		int oldNumberMenu[ NBMAXSUBMENUANDITEM ];
+		int nbLevelMenu;
+
+		int offset; // For MenuCmdPosition issue
+
+		cSubMenu();
+		virtual ~cSubMenu();
+		void LoadInfoSubMenu(void);
+		void ParseOneLigOfFile (const char *lig);
+		void SaveInfoSubMenu(void);
+		int GetByLevel(int Level, int curr);
+		int GetByLevel(int Level);
+	        void CreateItem(int type,int position,int where,char *Name="");
+	        void DeleteItem(int position,int kindItem=-1);
+		void InsertItem(int position);
+		void Dump(void);
+};
+#endif //__SUBMENU_H
